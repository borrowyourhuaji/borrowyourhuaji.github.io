<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://borrowyourhuaji.github.io/atom.xml" rel="self"/>
  
  <link href="https://borrowyourhuaji.github.io/"/>
  <updated>2025-09-14T05:58:13.781Z</updated>
  <id>https://borrowyourhuaji.github.io/</id>
  
  <author>
    <name>borrowyourhuaji</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>tool command</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/14/ubuntu-tool-command/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/14/ubuntu-tool-command/</id>
    <published>2025-09-14T05:56:52.000Z</published>
    <updated>2025-09-14T05:58:13.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1.-grep-%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3" tabindex="-1">1. grep 工具详解</h3><p><strong>grep</strong>（Global Regular Expression Print）是 Linux 中用于搜索文本的强大工具，通过正则表达式或固定字符串匹配文件内容或标准输入，输出匹配的行。它在文件查看、日志分析、数据过滤等场景中广泛使用。</p><h4 id="1.1-%E5%8A%9F%E8%83%BD" tabindex="-1">1.1 功能</h4><ul><li><strong>搜索文本</strong>: 在文件或标准输入中查找匹配指定模式（pattern）的行。</li><li><strong>支持正则表达式</strong>: 使用正则表达式匹配复杂模式。</li><li><strong>变体</strong>: 包括 <code>egrep</code>（扩展正则表达式）、<code>fgrep</code>（固定字符串匹配）、<code>rgrep</code>（递归搜索）。</li><li><strong>灵活性</strong>: 可结合管道（<code>|</code>）处理其他命令的输出。</li></ul><h4 id="1.2-%E8%AF%AD%E6%B3%95" tabindex="-1">1.2 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] 模式 [文件...]</span><br></pre></td></tr></table></figure><ul><li><strong>模式</strong>: 要搜索的字符串或正则表达式。</li><li><strong>文件</strong>: 一个或多个文件路径，若省略则从标准输入读取。</li><li><strong>选项</strong>: 控制搜索行为、输出格式等。</li></ul><h4 id="1.3-%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9" tabindex="-1">1.3 常用选项</h4><p>以下是 <code>grep</code> 的常用选项，分为搜索控制、输出格式和上下文控制三类：</p><p><strong>搜索控制</strong>:</p><ul><li><code>-i</code>, <code>--ignore-case</code>: 忽略大小写。<br>示例: <code>grep -i &quot;error&quot; log.txt</code>（匹配 “Error” 或 “ERROR”）。</li><li><code>-w</code>, <code>--word-regexp</code>: 仅匹配完整单词（避免部分匹配）。<br>示例: <code>grep -w &quot;run&quot; script.sh</code>（匹配 “run” 但不匹配 “running”）。</li><li><code>-v</code>, <code>--invert-match</code>: 输出不匹配的行。<br>示例: <code>grep -v &quot;^#&quot; config.conf</code>（排除以 <code>#</code> 开头的注释行）。</li><li><code>-r</code>, <code>--recursive</code>: 递归搜索目录中的所有文件。<br>示例: <code>grep -r &quot;TODO&quot; /project/</code>（搜索 <code>/project/</code> 目录下包含 “TODO” 的文件）。</li><li><code>-l</code>, <code>--files-with-matches</code>: 仅输出包含匹配的文件名。<br>示例: <code>grep -l &quot;error&quot; *.log</code>（列出包含 “error” 的日志文件）。</li><li><code>-L</code>, <code>--files-without-match</code>: 输出不包含匹配的文件名。<br>示例: <code>grep -L &quot;error&quot; *.log</code>。</li><li><code>-e 模式</code>, <code>--regexp=模式</code>: 指定多个模式（可多次使用）。<br>示例: <code>grep -e &quot;error&quot; -e &quot;warning&quot; log.txt</code>（匹配 “error” 或 “warning”）。</li><li><code>-E</code>, <code>--extended-regexp</code>: 使用扩展正则表达式（等同 <code>egrep</code>）。<br>示例: <code>grep -E &quot;error|warning&quot; log.txt</code>。</li><li><code>-F</code>, <code>--fixed-strings</code>: 按固定字符串匹配（等同 <code>fgrep</code>，禁用正则）。<br>示例: <code>grep -F &quot;http://&quot; urls.txt</code>（匹配字面字符串 “http://”）。</li><li><code>-P</code>, <code>--perl-regexp</code>: 使用 Perl 兼容正则表达式（需支持）。<br>示例: <code>grep -P &quot;\d+&quot; numbers.txt</code>（匹配数字）。</li></ul><p><strong>输出格式</strong>:</p><ul><li><code>-n</code>, <code>--line-number</code>: 显示匹配行的行号。<br>示例: <code>grep -n &quot;error&quot; log.txt</code>。</li><li><code>-c</code>, <code>--count</code>: 输出匹配行的数量。<br>示例: <code>grep -c &quot;error&quot; log.txt</code>。</li><li><code>-o</code>, <code>--only-matching</code>: 仅输出匹配的部分（而非整行）。<br>示例: <code>grep -o &quot;[0-9]+&quot; data.txt</code>（提取所有数字）。</li><li><code>--color</code>: 高亮显示匹配内容（默认自动启用）。<br>示例: <code>grep --color &quot;error&quot; log.txt</code>。</li><li><code>-b</code>, <code>--byte-offset</code>: 显示匹配内容的字节偏移量。<br>示例: <code>grep -b &quot;key&quot; file.txt</code>。</li></ul><p><strong>上下文控制</strong>:</p><ul><li><code>-A 行数</code>, <code>--after-context=行数</code>: 显示匹配行后的指定行数。<br>示例: <code>grep -A 2 &quot;error&quot; log.txt</code>（显示匹配行及后两行）。</li><li><code>-B 行数</code>, <code>--before-context=行数</code>: 显示匹配行前的指定行数。<br>示例: <code>grep -B 2 &quot;error&quot; log.txt</code>。</li><li><code>-C 行数</code>, <code>--context=行数</code>: 显示匹配行前后各指定行数。<br>示例: <code>grep -C 2 &quot;error&quot; log.txt</code>。</li></ul><h4 id="1.4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">1.4 使用场景</h4><ul><li><strong>日志分析</strong>: 查找错误或特定事件（如 <code>grep &quot;ERROR&quot; /var/log/syslog</code>）。</li><li><strong>配置文件筛选</strong>: 提取非注释行或特定配置项。</li><li><strong>代码搜索</strong>: 在源代码中查找函数或关键字。</li><li><strong>数据处理</strong>: 结合管道过滤命令输出（如 <code>ps aux | grep python</code>）。</li></ul><h4 id="1.5-%E7%A4%BA%E4%BE%8B" tabindex="-1">1.5 示例</h4><ul><li><p>基本搜索：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;error&quot; /var/log/syslog</span><br></pre></td></tr></table></figure><p>输出 <code>syslog</code> 中包含 “error” 的行。</p></li><li><p>忽略大小写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -i &quot;warning&quot; log.txt</span><br></pre></td></tr></table></figure><p>匹配 “Warning” 或 “WARNING”。</p></li><li><p>递归搜索目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -r &quot;TODO&quot; /home/user/project/</span><br></pre></td></tr></table></figure><p>在项目目录下查找所有包含 “TODO” 的文件。</p></li><li><p>显示行号和上下文：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n -C 3 &quot;exception&quot; app.log</span><br></pre></td></tr></table></figure><p>显示包含 “exception” 的行、行号及前后各 3 行。</p></li><li><p>提取匹配部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -o &quot;[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;&quot; log.txt</span><br></pre></td></tr></table></figure><p>提取日志中的 IP 地址。</p></li><li><p>结合管道：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep -i &quot;firefox&quot;</span><br></pre></td></tr></table></figure><p>查找运行中的 Firefox 进程。</p></li><li><p>多个模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -e &quot;error&quot; -e &quot;fail&quot; log.txt</span><br></pre></td></tr></table></figure><p>匹配包含 “error” 或 “fail” 的行。</p></li></ul><h4 id="1.6-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80" tabindex="-1">1.6 正则表达式基础</h4><p><code>grep</code> 默认使用基本正则表达式（BRE），<code>-E</code> 启用扩展正则表达式（ERE），<code>-P</code> 启用 Perl 正则表达式。常用正则语法：</p><ul><li><code>.</code>: 任意单个字符。</li><li><code>*</code>: 前字符 0 次或多次。</li><li><code>+</code>: 前字符 1 次或多次（需 <code>-E</code> 或 <code>-P</code>）。</li><li><code>?</code>: 前字符 0 次或 1 次（需 <code>-E</code> 或 <code>-P</code>）。</li><li><code>[]</code>: 字符集，如 <code>[a-z]</code> 匹配小写字母。</li><li><code>^</code>: 行首。</li><li><code>$</code>: 行尾。</li><li><code>|</code>: 或操作（如 <code>error|warning</code>，需 <code>-E</code>）。</li><li><code>\d</code>: 数字（需 <code>-P</code>）。</li><li><code>\w</code>: 单词字符（需 <code>-P</code>）。</li></ul><p><strong>示例</strong>:</p><ul><li><code>grep &quot;^[A-Z]&quot; file.txt</code>: 匹配以大写字母开头的行。</li><li><code>grep -E &quot;error|warning&quot; log.txt</code>: 匹配 “error” 或 “warning”。</li><li><code>grep -P &quot;\d&#123;3&#125;-\d&#123;2&#125;-\d&#123;4&#125;&quot; data.txt</code>: 匹配类似 “123-45-6789” 的模式。</li></ul><h4 id="1.7-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" tabindex="-1">1.7 高级用法</h4><ul><li><p><strong>结合 <code>find</code></strong>: 搜索特定类型文件中的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/log -name &quot;*.log&quot; -exec grep &quot;error&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>在所有 <code>.log</code> 文件中搜索 “error”。</p></li><li><p><strong>管道过滤</strong>: 处理复杂输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i &quot;usb&quot; | grep -v &quot;disconnected&quot;</span><br></pre></td></tr></table></figure><p>查找 USB 相关消息，排除 “disconnected”。</p></li><li><p><strong>统计匹配</strong>: 计算特定模式出现次数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -c &quot;GET&quot; access.log</span><br></pre></td></tr></table></figure><p>统计 HTTP GET 请求次数。</p></li><li><p><strong>脚本化</strong>: 在 shell 脚本中动态搜索。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> grep -q <span class="string">&quot;error&quot;</span> log.txt; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Error found!&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><code>-q</code> 选项静默检查是否存在匹配。</p></li></ul><h4 id="1.8-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" tabindex="-1">1.8 注意事项</h4><ul><li><strong>性能</strong>: 对大文件或目录递归搜索（<code>-r</code>）可能较慢，考虑使用 <code>fgrep</code>（固定字符串）或 <code>ripgrep</code>（见下文）。</li><li><strong>正则表达式转义</strong>: 特殊字符（如 <code>.</code>、<code>*</code>）需用 <code>\</code> 转义（除非用 <code>-F</code>）。</li><li><strong>权限</strong>: 搜索系统文件（如 <code>/var/log</code>）可能需 <code>sudo</code>。</li><li><strong>编码</strong>: 非 ASCII 文件可能需指定编码（如 <code>LC_ALL=C grep ...</code>）。</li></ul><hr><h3 id="2.-grep-%E5%8F%98%E4%BD%93" tabindex="-1">2. grep 变体</h3><p><code>grep</code> 有以下变体，功能类似但侧重点不同：</p><ul><li><p><strong>egrep</strong><br><strong>功能</strong>: 等同于 <code>grep -E</code>，使用扩展正则表达式（ERE），无需转义 <code>|</code>、<code>+</code> 等。<br><strong>语法</strong>: <code>egrep [选项] 模式 [文件...]</code><br><strong>场景</strong>: 需要复杂正则表达式（如 <code>error|warning</code>）时。<br><strong>示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep &quot;error|warning&quot; log.txt</span><br></pre></td></tr></table></figure><p>匹配 “error” 或 “warning”。<br><strong>注意</strong>: <code>egrep</code> 是 <code>grep -E</code> 的别名，现代系统中建议直接用 <code>grep -E</code>。</p></li><li><p><strong>fgrep</strong><br><strong>功能</strong>: 等同于 <code>grep -F</code>，按固定字符串匹配，不解析正则表达式，速度更快。<br><strong>语法</strong>: <code>fgrep [选项] 字符串 [文件...]</code><br><strong>场景</strong>: 搜索字面字符串（如 URL 或代码片段）无需正则。<br><strong>示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fgrep &quot;http://&quot; urls.txt</span><br></pre></td></tr></table></figure><p>匹配字面字符串 “http://”。<br><strong>注意</strong>: 适合搜索特殊字符，避免转义麻烦。</p></li><li><p><strong>rgrep</strong><br><strong>功能</strong>: 等同于 <code>grep -r</code>，递归搜索目录中的文件。<br><strong>语法</strong>: <code>rgrep [选项] 模式 [目录...]</code><br><strong>场景</strong>: 搜索项目目录中的代码或配置文件。<br><strong>示例</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgrep &quot;TODO&quot; /home/user/project/</span><br></pre></td></tr></table></figure><p>递归搜索包含 “TODO” 的文件。<br><strong>注意</strong>: <code>rgrep</code> 是 <code>grep -r</code> 的别名，建议用 <code>grep -r</code>。</p></li></ul><hr><h3 id="3.-%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7" tabindex="-1">3. 相关工具</h3><p>以下工具与 <code>grep</code> 常结合使用，扩展文件查看和编辑功能，简要讲解其语法和用途。</p><h4 id="3.1-sed%EF%BC%88stream-editor%EF%BC%89" tabindex="-1">3.1 sed（Stream Editor）</h4><p><strong>功能</strong>: 流编辑器，用于文本替换、删除、插入等操作，适合批量处理。<br><strong>语法</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] &#x27;命令&#x27; [文件...]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 直接修改原文件（建议备份，如 <code>-i.bak</code>）。</li><li><code>-e</code>: 执行多个命令。</li><li><code>-r</code>: 使用扩展正则表达式。<br><strong>常用命令</strong>:</li><li><code>s/模式/替换/g</code>: 全局替换。</li><li><code>d</code>: 删除匹配行。</li><li><code>p</code>: 打印匹配行。<br><strong>示例</strong>:</li><li><code>sed 's/error/warning/g' log.txt</code>: 将 “error” 替换为 “warning”。</li><li><code>sed -i.bak '/^#/d' config.txt</code>: 删除注释行并备份原文件。</li><li><code>sed '10,20d' data.txt</code>: 删除第 10 到 20 行。<br><strong>与 grep 结合</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;error&quot; log.txt | sed &#x27;s/error/ERROR/g&#x27;</span><br></pre></td></tr></table></figure><p>筛选 “error” 行并将其改为 “ERROR”。<br><strong>场景</strong>: 批量修改配置文件、清理日志。</p><h4 id="3.2-awk" tabindex="-1">3.2 awk</h4><p><strong>功能</strong>: 文本处理工具，适合处理结构化数据（如 CSV、日志），支持字段提取和计算。<br><strong>语法</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk [选项] &#x27;程序&#x27; [文件...]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>:</p><ul><li><code>-F 分隔符</code>: 指定字段分隔符（如 <code>','</code>）。</li><li><code>-v 变量=值</code>: 定义变量。<br><strong>常用程序</strong>:</li><li><code>&#123;print $n&#125;</code>: 打印第 n 列。</li><li><code>/模式/ &#123;动作&#125;</code>: 对匹配模式执行动作。</li><li><code>BEGIN &#123;动作&#125;</code>: 文件处理前执行。</li><li><code>END &#123;动作&#125;</code>: 文件处理后执行。<br><strong>示例</strong>:</li><li><code>awk -F',' '&#123;print $1&#125;' data.csv</code>: 打印 CSV 第一列。</li><li><code>awk '/error/ &#123;print&#125;' log.txt</code>: 打印包含 “error” 的行。</li><li><code>awk '&#123;sum+=$2&#125; END &#123;print sum&#125;' numbers.txt</code>: 计算第二列总和。<br><strong>与 grep 结合</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;error&quot; log.txt | awk &#x27;&#123;print $1, $3&#125;&#x27;</span><br></pre></td></tr></table></figure><p>筛选 “error” 行并打印第一和第三列。<br><strong>场景</strong>: 提取日志字段、统计数据。</p><h4 id="3.3-ripgrep-(rg)" tabindex="-1">3.3 ripgrep (rg)</h4><p><strong>功能</strong>: 现代高性能搜索工具，类似 <code>grep</code> 但更快，支持更多功能（需安装 <code>sudo apt install ripgrep</code>）。<br><strong>语法</strong>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg [选项] 模式 [路径]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 忽略大小写。</li><li><code>-w</code>: 匹配完整单词。</li><li><code>-g 模式</code>: 按文件名模式过滤（如 <code>*.py</code>）。</li><li><code>--no-heading</code>: 不显示文件名标题。</li><li><code>--files</code>: 仅列出匹配文件。<br><strong>场景</strong>: 大型项目代码搜索、快速日志分析。<br><strong>示例</strong>:</li><li><code>rg &quot;TODO&quot; /project/</code>: 递归搜索 “TODO”。</li><li><code>rg -i &quot;error&quot; *.log</code>: 在日志文件中搜索 “error”。</li><li><code>rg -g &quot;*.py&quot; &quot;def&quot;</code>: 在 Python 文件中搜索函数定义。<br><strong>与 grep 的区别</strong>:</li><li>更快：利用多线程和优化算法。</li><li>默认递归且忽略 <code>.git</code> 等隐藏目录。</li><li>更智能：支持复杂正则和文件类型过滤。<br><strong>注意</strong>: <code>ripgrep</code> 需安装，适合高性能场景。</li></ul><hr><h3 id="4.-%E9%AB%98%E7%BA%A7%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B" tabindex="-1">4. 高级使用场景与示例</h3><p>以下展示 <code>grep</code> 及相关工具在实际任务中的组合应用：</p><ol><li><p><strong>日志分析</strong>:</p><ul><li>查找最近 10 分钟的错误日志：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 1000 /var/log/syslog | grep &quot;error&quot;</span><br></pre></td></tr></table></figure></li><li>提取错误相关的 IP 地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;error&quot; log.txt | grep -o &quot;[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>批量修改配置文件</strong>:</p><ul><li>删除所有注释行并替换关键字：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -v &quot;^#&quot; config.txt | sed &#x27;s/server/host/g&#x27; &gt; newconfig.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>统计特定模式</strong>:</p><ul><li>计算 HTTP 请求类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E &quot;GET|POST&quot; access.log | awk &#x27;&#123;print $6&#125;&#x27; | sort | uniq -c</span><br></pre></td></tr></table></figure>输出每种请求类型的出现次数。</li></ul></li><li><p><strong>代码搜索与清理</strong>:</p><ul><li>查找所有 Python 文件中的 TODO：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rg -g &quot;*.py&quot; &quot;TODO&quot; /project/</span><br></pre></td></tr></table></figure></li><li>替换代码中的旧变量名：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /project -name &quot;*.py&quot; -exec sed -i &#x27;s/old_var/new_var/g&#x27; &#123;&#125; \;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>实时监控与过滤</strong>:</p><ul><li>实时监控错误日志并提取时间戳：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f /var/log/syslog | grep &quot;error&quot; | awk &#x27;&#123;print $1, $2, $3&#125;&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="5.-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%89%A9%E5%B1%95" tabindex="-1">5. 注意事项与扩展</h3><ol><li><strong>性能优化</strong>:<ul><li>使用 <code>fgrep</code> 或 <code>ripgrep</code> 处理固定字符串搜索以提高速度。</li><li>限制搜索范围（如 <code>grep -r &quot;pattern&quot; /specific/dir</code>）避免全盘扫描。</li></ul></li><li><strong>正则表达式调试</strong>:<ul><li>测试复杂正则表达式时，先用 <code>grep -o</code> 查看匹配部分。</li><li>使用工具如 <code>regex101.com</code> 验证正则语法。</li></ul></li><li><strong>权限问题</strong>:<ul><li>搜索系统文件（如 <code>/var/log</code>）可能需 <code>sudo</code>，如 <code>sudo grep &quot;error&quot; /var/log/secure</code>.</li></ul></li><li><strong>编码问题</strong>:<ul><li>处理非 ASCII 文件时，可能需设置 <code>LC_ALL=C</code>。</li><li>示例: <code>LC_ALL=C grep &quot;pattern&quot; file.txt</code>.</li></ul></li><li><strong>学习资源</strong>:<ul><li>查看手册：<code>man grep</code>, <code>man sed</code>, <code>man awk</code>。</li><li>安装 <code>tldr</code>（<code>sudo apt install tldr</code>）获取简明示例。</li><li>在线教程：如 DigitalOcean 的 grep 指南或 Ubuntu 社区文档。</li></ul></li><li><strong>替代工具</strong>:<ul><li><strong>ripgrep (rg)</strong>: 更快、更现代，适合大型项目。</li><li><strong>ack</strong>: 面向开发者的搜索工具，专注于代码。</li><li><strong>ag (silversearcher)</strong>: 类似 <code>ripgrep</code>，高性能搜索。</li></ul></li></ol><hr><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1.-grep-%E5%B7%A5%E5%85%B7%E8%AF%A6%E8%A7%A3&quot; tabindex=&quot;-1&quot;&gt;1. grep 工具详解&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;grep&lt;/strong&gt;（Global Regular Expression Pri</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ubuntu services cmommand</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/ubuntu-services-cmommand/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/ubuntu-services-cmommand/</id>
    <published>2025-09-13T15:42:12.000Z</published>
    <updated>2025-09-14T04:36:32.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%F0%9F%94%B9-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%86%85%E7%BD%AE%2F%E9%80%9A%E7%94%A8%EF%BC%89" tabindex="-1">🔹 一、基础网络命令（内置/通用）</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试连通性</td><td><code>ping baidu.com</code></td></tr><tr><td><code>curl</code></td><td>HTTP/HTTPS 请求</td><td><code>curl -I https://example.com</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget https://example.com/file.zip</code></td></tr><tr><td><code>traceroute</code></td><td>路由跟踪</td><td><code>traceroute 8.8.8.8</code></td></tr><tr><td><code>mtr</code></td><td>动态路由跟踪（集成 ping+traceroute）</td><td><code>mtr google.com</code></td></tr><tr><td><code>telnet</code></td><td>测试 TCP 端口连通</td><td><code>telnet example.com 80</code></td></tr><tr><td><code>nc</code> / <code>netcat</code></td><td>网络测试、端口扫描、socket调试</td><td><code>nc -zv 192.168.1.1 22-80</code></td></tr><tr><td><code>dig</code></td><td>DNS 查询（来自 <code>dnsutils</code> 包）</td><td><code>dig google.com</code></td></tr><tr><td><code>nslookup</code></td><td>DNS 查询（老工具）</td><td><code>nslookup baidu.com</code></td></tr><tr><td><code>host</code></td><td>简单 DNS 查询</td><td><code>host github.com</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%BA%8C%E3%80%81%E6%97%A7%E5%B7%A5%E5%85%B7-net-tools%EF%BC%88%E9%80%90%E6%B8%90%E8%A2%AB%E6%9B%BF%E4%BB%A3%EF%BC%8C%E4%BD%86%E4%BB%8D%E5%B8%B8%E7%94%A8%EF%BC%89" tabindex="-1">🔹 二、旧工具 Net-tools（逐渐被替代，但仍常用）</h1><p>需安装：<code>sudo apt install net-tools</code></p><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>查看/配置网络接口</td><td><code>ifconfig eth0 up</code></td></tr><tr><td><code>route</code></td><td>查看/配置路由表</td><td><code>route -n</code></td></tr><tr><td><code>arp</code></td><td>查看/管理 ARP 缓存</td><td><code>arp -a</code></td></tr><tr><td><code>netstat</code></td><td>查看端口、连接、路由</td><td><code>netstat -tulnp</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B8%89%E3%80%81%E6%96%B0%E5%B7%A5%E5%85%B7-iproute2%EF%BC%88%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89" tabindex="-1">🔹 三、新工具 iproute2（现代替代方案，推荐）</h1><p>自带在 Ubuntu，无需安装。</p><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ip addr</code></td><td>查看/管理 IP 地址</td><td><code>ip addr show</code></td></tr><tr><td><code>ip link</code></td><td>查看/配置网卡</td><td><code>ip link set eth0 up</code></td></tr><tr><td><code>ip route</code></td><td>查看/管理路由表</td><td><code>ip route add default via 192.168.1.1</code></td></tr><tr><td><code>ip neigh</code></td><td>查看/管理 ARP 表</td><td><code>ip neigh show</code></td></tr><tr><td><code>ss</code></td><td>替代 <code>netstat</code>，查看 socket</td><td><code>ss -tulnp</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%B5%8B%E8%AF%95" tabindex="-1">🔹 四、网络诊断与测试</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ethtool</code></td><td>网卡信息、速率</td><td><code>ethtool eth0</code></td></tr><tr><td><code>iwconfig</code></td><td>无线网卡配置（Wi-Fi）</td><td><code>iwconfig wlan0</code></td></tr><tr><td><code>iwlist</code></td><td>扫描无线网络</td><td><code>iwlist wlan0 scan</code></td></tr><tr><td><code>nmcli</code></td><td>NetworkManager CLI，配置网络</td><td><code>nmcli device status</code></td></tr><tr><td><code>systemd-resolve</code></td><td>DNS 解析调试（systemd-resolved）</td><td><code>systemd-resolve google.com</code></td></tr><tr><td><code>curl ifconfig.me</code></td><td>查看公网 IP</td><td><code>curl ifconfig.me</code></td></tr><tr><td><code>whois</code></td><td>域名/IP 查询</td><td><code>whois example.com</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%BA%94%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3" tabindex="-1">🔹 五、服务管理相关</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>service networking restart</code></td><td>重启网络服务</td><td></td></tr><tr><td><code>systemctl restart NetworkManager</code></td><td>重启 NetworkManager</td><td></td></tr><tr><td><code>nmcli</code></td><td>全面网络管理工具</td><td><code>nmcli con up id mywifi</code></td></tr><tr><td><code>wpa_cli</code> / <code>wpa_supplicant</code></td><td>Wi-Fi 配置工具</td><td><code>wpa_cli status</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%85%AD%E3%80%81%E6%8A%93%E5%8C%85%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90" tabindex="-1">🔹 六、抓包与流量分析</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>tcpdump</code></td><td>抓包分析</td><td><code>tcpdump -i eth0 port 80</code></td></tr><tr><td><code>wireshark</code> / <code>tshark</code></td><td>高级抓包工具</td><td><code>tshark -i wlan0</code></td></tr><tr><td><code>iftop</code></td><td>实时流量监控</td><td><code>iftop -i eth0</code></td></tr><tr><td><code>nload</code></td><td>网络流量实时曲线</td><td><code>nload</code></td></tr><tr><td><code>iptraf-ng</code></td><td>网络统计工具</td><td><code>iptraf-ng</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B8%83%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E5%AE%89%E5%85%A8" tabindex="-1">🔹 七、防火墙与安全</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ufw</code></td><td>简易防火墙管理（Ubuntu 默认推荐）</td><td><code>ufw allow 22/tcp</code></td></tr><tr><td><code>iptables</code></td><td>底层防火墙配置</td><td><code>iptables -L -n -v</code></td></tr><tr><td><code>firewalld</code></td><td>另一套防火墙（部分系统用）</td><td><code>firewall-cmd --list-all</code></td></tr><tr><td><code>fail2ban-client</code></td><td>SSH 防暴力破解工具</td><td><code>fail2ban-client status</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%85%AB%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4" tabindex="-1">🔹 八、其他常见网络命令</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>scp</code></td><td>远程拷贝文件（基于 SSH）</td><td><code>scp file user@host:/path/</code></td></tr><tr><td><code>rsync</code></td><td>高效同步文件</td><td><code>rsync -avz dir user@host:/path/</code></td></tr><tr><td><code>ftp</code> / <code>sftp</code></td><td>文件传输</td><td><code>sftp user@host</code></td></tr><tr><td><code>ssh</code></td><td>远程登录</td><td><code>ssh user@host</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B9%9D%E3%80%81%E7%BB%83%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E7%BB%99%E4%BD%A0%E7%BB%83%E6%89%8B%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%89" tabindex="-1">🔹 九、练习路线（给你练手的建议）</h1><ol><li><p><strong>入门</strong>：</p><ul><li>用 <code>ping</code>、<code>curl</code>、<code>wget</code> 测试网络</li><li>用 <code>ip addr</code>、<code>ifconfig</code> 查看网卡</li></ul></li><li><p><strong>进阶</strong>：</p><ul><li>用 <code>ss -tulnp</code> 找出占用端口的服务</li><li>用 <code>ip route</code> 修改默认路由</li><li>用 <code>ufw</code> 添加规则限制端口</li></ul></li><li><p><strong>高级</strong>：</p><ul><li>用 <code>tcpdump</code> 抓包，配合 <code>wireshark</code> 分析 HTTP/HTTPS</li><li>用 <code>iptables</code> 手写 NAT 转发规则</li><li>用 <code>nload</code> 或 <code>iftop</code> 看实时流量</li></ul></li></ol><h1 id="ubuntu-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8" tabindex="-1">Ubuntu 网络相关命令列表</h1><h2 id="1.-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86" tabindex="-1">1. 网络接口管理</h2><ul><li><strong>ifconfig</strong>: 显示或配置网络接口（传统工具，需安装 <code>net-tools</code>）。<br>示例: <code>ifconfig eth0</code> (显示 eth0 接口信息)。</li><li><strong>ip</strong>: 现代网络接口管理工具，显示或配置 IP 地址、路由等。<br>示例: <code>ip addr show</code> (显示所有接口信息)。</li><li><strong>nmcli</strong>: NetworkManager 命令行工具，管理网络连接。<br>示例: <code>nmcli con show</code> (列出网络连接)。</li><li><strong>ethtool</strong>: 显示或配置网络接口状态（如速度、双工模式）。<br>示例: <code>ethtool eth0</code> (显示 eth0 状态)。</li><li><strong>iwconfig</strong>: 配置无线网络接口（需安装 <code>wireless-tools</code>）。<br>示例: <code>iwconfig wlan0</code> (显示无线接口信息)。</li><li><strong>iw</strong>: 现代无线网络接口管理工具。<br>示例: <code>iw dev wlan0 scan</code> (扫描无线网络)。</li><li><strong>ifup</strong>: 启用网络接口（需配置 /etc/network/interfaces）。<br>示例: <code>sudo ifup eth0</code>。</li><li><strong>ifdown</strong>: 禁用网络接口。<br>示例: <code>sudo ifdown eth0</code>。</li><li><strong>route</strong>: 显示或配置路由表（需安装 <code>net-tools</code>）。<br>示例: <code>route -n</code> (显示数字格式路由表)。</li><li><strong>ip route</strong>: 现代路由表管理工具。<br>示例: <code>ip route show</code> (显示路由表)。</li></ul><h2 id="2.-%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%B5%8B%E8%AF%95" tabindex="-1">2. 网络诊断与测试</h2><ul><li><strong>ping</strong>: 测试与目标主机的网络连通性。<br>示例: <code>ping -c 4 google.com</code> (发送 4 个数据包)。</li><li><strong>traceroute</strong>: 显示数据包到目标主机的路由路径（需安装）。<br>示例: <code>traceroute google.com</code>。</li><li><strong>mtr</strong>: 结合 ping 和 traceroute 的实时网络诊断工具（需安装）。<br>示例: <code>mtr google.com</code>。</li><li><strong>dig</strong>: 查询 DNS 记录（需安装 <code>dnsutils</code>）。<br>示例: <code>dig example.com</code>。</li><li><strong>nslookup</strong>: 查询 DNS 名称解析。<br>示例: <code>nslookup example.com</code>。</li><li><strong>host</strong>: 简单 DNS 查询工具。<br>示例: <code>host example.com</code>。</li><li><strong>netstat</strong>: 显示网络连接、路由表、接口统计（需安装 <code>net-tools</code>）。<br>示例: <code>netstat -tuln</code> (显示监听的 TCP/UDP 端口)。</li><li><strong>ss</strong>: 现代网络套接字统计工具，替代 netstat。<br>示例: <code>ss -tuln</code> (显示监听端口)。</li><li><strong>nmap</strong>: 网络扫描和端口探测工具（需安装）。<br>示例: <code>nmap localhost</code> (扫描本地主机端口)。</li><li><strong>telnet</strong>: 测试远程主机端口连通性。<br>示例: <code>telnet example.com 80</code> (测试 80 端口)。</li><li><strong>nc</strong> (netcat): 多功能网络工具，用于端口测试、数据传输等。<br>示例: <code>nc -zv localhost 22</code> (测试端口连接)。</li><li><strong>arp</strong>: 显示或管理 ARP 缓存（地址解析协议）。<br>示例: <code>arp -n</code> (显示 ARP 表)。</li><li><strong>ip neighbor</strong>: 现代 ARP 表管理工具。<br>示例: <code>ip neighbor show</code> (显示邻居表)。</li></ul><h2 id="3.-%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" tabindex="-1">3. 网络文件传输</h2><ul><li><strong>curl</strong>: 从 URL 下载或发送数据，支持 HTTP/HTTPS/FTP 等。<br>示例: <code>curl -O https://example.com/file.txt</code> (下载文件)。</li><li><strong>wget</strong>: 非交互式文件下载工具。<br>示例: <code>wget https://example.com/file.zip</code>。</li><li><strong>scp</strong>: 通过 SSH 安全复制文件到远程主机。<br>示例: <code>scp file.txt user@host:/path</code>。</li><li><strong>rsync</strong>: 高效的文件同步和传输工具。<br>示例: <code>rsync -avz file.txt user@host:/path</code> (同步文件)。</li><li><strong>ftp</strong>: 交互式 FTP 文件传输（需安装 FTP 客户端）。<br>示例: <code>ftp ftp.example.com</code>。</li><li><strong>sftp</strong>: 通过 SSH 进行安全的 FTP 文件传输。<br>示例: <code>sftp user@host</code>。</li></ul><h2 id="4.-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%AE%A1%E7%90%86" tabindex="-1">4. 远程连接与管理</h2><ul><li><strong>ssh</strong>: 安全远程登录到另一台主机。<br>示例: <code>ssh user@host</code>。</li><li><strong>ssh-keygen</strong>: 生成 SSH 密钥对。<br>示例: <code>ssh-keygen -t rsa</code>。</li><li><strong>ssh-copy-id</strong>: 将公钥复制到远程主机以实现免密码登录。<br>示例: <code>ssh-copy-id user@host</code>。</li><li><strong>telnet</strong>: 非安全远程连接（不推荐，测试用）。<br>示例: <code>telnet host 23</code>。</li></ul><h2 id="5.-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86" tabindex="-1">5. 网络服务管理</h2><ul><li><strong>systemctl</strong>: 管理网络相关服务（如 NetworkManager、sshd）。<br>示例: <code>sudo systemctl restart ssh</code>。</li><li><strong>service</strong>: 传统方式管理系统服务。<br>示例: <code>sudo service networking restart</code>。</li><li><strong>ufw</strong>: 简易防火墙配置工具。<br>示例: <code>sudo ufw allow 22</code> (允许 SSH 端口)。</li><li><strong>iptables</strong>: 配置内核防火墙规则（高级用户）。<br>示例: <code>sudo iptables -L</code> (列出规则)。</li><li><strong>firewalld</strong>: 动态防火墙管理工具（需安装）。<br>示例: <code>sudo firewall-cmd --list-all</code>。</li></ul><h2 id="6.-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90" tabindex="-1">6. 网络监控与分析</h2><ul><li><strong>tcpdump</strong>: 捕获和分析网络数据包（需安装）。<br>示例: <code>sudo tcpdump -i eth0</code> (捕获 eth0 接口数据包)。</li><li><strong>wireshark</strong>: 图形化网络协议分析工具（需安装）。<br>示例: <code>wireshark &amp;</code> (启动 GUI 界面)。</li><li><strong>iftop</strong>: 实时显示网络接口带宽使用情况（需安装）。<br>示例: <code>sudo iftop -i eth0</code>。</li><li><strong>nload</strong>: 监控网络带宽使用情况（需安装）。<br>示例: <code>nload eth0</code>。</li><li><strong>vnstat</strong>: 统计网络流量（需安装）。<br>示例: <code>vnstat -i eth0</code> (显示 eth0 流量统计)。</li></ul><h2 id="7.-%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7" tabindex="-1">7. 其他网络相关工具</h2><ul><li><strong>hostname</strong>: 显示或设置系统主机名。<br>示例: <code>hostname</code>。</li><li><strong>hostnamectl</strong>: 管理主机名（现代 systemd 工具）。<br>示例: <code>hostnamectl set-hostname newname</code>。</li><li><strong>whois</strong>: 查询域名注册信息（需安装）。<br>示例: <code>whois example.com</code>。</li><li><strong>curlftpfs</strong>: 将 FTP 服务器挂载为本地文件系统（需安装）。<br>示例: <code>curlftpfs ftp://user:pass@host /mnt/ftp</code>。</li><li><strong>avahi-discover</strong>: 发现局域网内 mDNS/DNS-SD 服务（需安装）。<br>示例: <code>avahi-discover</code>。</li><li><strong>ipcalc</strong>: 计算 IP 地址和子网信息（需安装）。<br>示例: <code>ipcalc 192.168.1.0/24</code>。</li><li><strong>dhclient</strong>: 获取或释放 DHCP 租约。<br>示例: <code>sudo dhclient eth0</code>。</li><li><strong>dnsmasq</strong>: 轻量级 DNS 和 DHCP 服务器（需安装）。<br>示例: <code>sudo dnsmasq</code>。</li></ul><h2 id="%E8%AF%B4%E6%98%8E" tabindex="-1">说明</h2><ul><li><strong>安装说明</strong>: 部分命令（如 <code>net-tools</code>、<code>nmap</code>、<code>wireshark</code> 等）可能需要安装，运行 <code>sudo apt install &lt;包名&gt;</code>。</li><li><strong>权限</strong>: 网络配置或监控命令通常需要 <code>sudo</code> 权限。</li><li><strong>文档查询</strong>: 使用 <code>man &lt;命令&gt;</code> 或 <code>tldr &lt;命令&gt;</code> 获取详细用法（<code>tldr</code> 需安装）。</li><li><strong>扩展</strong>: 更多高级工具可通过 <code>apt search network</code> 或 <code>compgen -c | grep network</code> 发现。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%F0%9F%94%B9-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%86%85%E7%BD%AE%2F%E9%80%9A%E7%94%A</summary>
      
    
    
    
    
    <category term="service" scheme="https://borrowyourhuaji.github.io/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu common cmommand</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/ubuntu-common-cmommand/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/ubuntu-common-cmommand/</id>
    <published>2025-09-13T15:37:46.000Z</published>
    <updated>2025-09-14T06:07:40.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%F0%9F%94%B9-1.-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4" tabindex="-1">🔹 1. 基础操作命令</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看当前目录</td><td><code>pwd</code></td><td>print working directory</td></tr><tr><td>列出文件</td><td><code>ls</code>、<code>ls -l</code>、<code>ls -a</code></td><td>加 <code>-l</code> 显示详细，加 <code>-a</code> 显示隐藏文件</td></tr><tr><td>切换目录</td><td><code>cd 目录名</code></td><td><code>cd ..</code> 返回上一级，<code>cd ~</code> 回家目录</td></tr><tr><td>创建目录</td><td><code>mkdir test</code></td><td>递归创建：<code>mkdir -p a/b/c</code></td></tr><tr><td>创建文件</td><td><code>touch file.txt</code></td><td>更新文件时间，若不存在就新建</td></tr><tr><td>删除文件</td><td><code>rm file.txt</code></td><td>删除目录：<code>rm -r dirname</code></td></tr><tr><td>拷贝</td><td><code>cp a b</code></td><td>拷贝文件；<code>cp -r dir1 dir2</code> 复制目录</td></tr><tr><td>移动/重命名</td><td><code>mv a b</code></td><td>文件移动/改名</td></tr><tr><td>查看文件内容</td><td><code>cat file</code>、<code>less file</code>、<code>head file</code>、<code>tail file</code></td><td><code>tail -f log.txt</code> 实时看日志</td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-2.-%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90" tabindex="-1">🔹 2. 用户和权限</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>当前用户</td><td><code>whoami</code></td><td></td></tr><tr><td>切换用户</td><td><code>su 用户名</code></td><td></td></tr><tr><td>临时管理员</td><td><code>sudo 命令</code></td><td></td></tr><tr><td>修改权限</td><td><code>chmod 755 file</code></td><td>读/写/执行权限</td></tr><tr><td>修改属主</td><td><code>chown user:group file</code></td><td></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-3.-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86-(ubuntu-apt)" tabindex="-1">🔹 3. 软件管理 (Ubuntu apt)</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>更新源</td><td><code>sudo apt update</code></td><td>更新索引，不升级</td></tr><tr><td>升级系统</td><td><code>sudo apt upgrade</code></td><td>升级已安装包</td></tr><tr><td>安装软件</td><td><code>sudo apt install 包名</code></td><td></td></tr><tr><td>卸载软件</td><td><code>sudo apt remove 包名</code></td><td></td></tr><tr><td>搜索软件</td><td><code>apt search 关键词</code></td><td></td></tr><tr><td>查看已安装</td><td>`dpkg -l</td><td>grep 包名`</td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-4.-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F" tabindex="-1">🔹 4. 进程和系统</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看进程</td><td><code>ps aux</code>、<code>top</code>、<code>htop</code></td><td></td></tr><tr><td>杀进程</td><td><code>kill -9 pid</code></td><td></td></tr><tr><td>系统状态</td><td><code>uptime</code>（负载）、<code>free -h</code>（内存）、<code>df -h</code>（磁盘）、<code>du -sh</code>（目录大小）</td><td></td></tr><tr><td>网络</td><td><code>ping baidu.com</code>、<code>curl ifconfig.me</code>（查看公网 IP）、<code>ss -tulpn</code>（监听端口）</td><td></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-5.-wsl-%E4%B8%93%E5%B1%9E%E5%91%BD%E4%BB%A4%EF%BC%88%E5%9C%A8-windows-powershell-%2F-cmd-%E7%94%A8%EF%BC%89" tabindex="-1">🔹 5. WSL 专属命令（在 Windows PowerShell / CMD 用）</h1><p>这些是 <strong>WSL 特有的</strong>，在 Windows 的命令行运行，而不是 Ubuntu 内：</p><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>进入 WSL</td><td><code>wsl</code></td><td>默认发行版</td></tr><tr><td>指定发行版</td><td><code>wsl -d Ubuntu-22.04</code></td><td></td></tr><tr><td>查看已安装发行版</td><td><code>wsl -l -v</code></td><td></td></tr><tr><td>运行 Linux 命令</td><td><code>wsl ls -la</code></td><td>在 Windows 下直接执行</td></tr><tr><td>导入导出</td><td><code>wsl --export</code> / <code>wsl --import</code></td><td></td></tr><tr><td>关闭</td><td><code>wsl --shutdown</code></td><td></td></tr></tbody></table><hr><h1 id="ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8" tabindex="-1">Ubuntu 常用命令列表</h1><h2 id="1.-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%EF%BC%88file-%26-directory-management%EF%BC%89" tabindex="-1">1. 文件和目录管理（File &amp; Directory Management）</h2><h4 id="1.-%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95%E5%86%85%E5%AE%B9" tabindex="-1">1. 查看目录内容</h4><ul><li><p><strong>ls</strong><br><strong>功能</strong>: 列出当前或指定目录中的文件和文件夹。<br><strong>语法</strong>: <code>ls [选项] [路径]</code><br><strong>常用选项</strong>:</p><ul><li><code>-l</code>: 长格式显示，包含权限、所有者、大小、修改时间等。</li><li><code>-a</code>: 显示隐藏文件（以 <code>.</code> 开头的文件）。</li><li><code>-h</code>: 以人类可读格式显示文件大小（如 KB、MB）。</li><li><code>-R</code>: 递归列出子目录内容。</li><li><code>-t</code>: 按修改时间排序（最新优先）。<br><strong>场景</strong>: 检查目录内容、确认文件存在、查看文件属性。<br><strong>示例</strong>:</li><li><code>ls -la /home/user</code>: 显示 <code>/home/user</code> 目录下所有文件（包括隐藏文件）的详细信息。</li><li><code>ls -lh /var/log</code>: 显示日志目录中文件的可读大小。</li><li><code>ls -R /etc</code>: 递归列出 <code>/etc</code> 及其子目录内容。</li></ul></li><li><p><strong>dir</strong><br><strong>功能</strong>: 类似 <code>ls</code>，但以更详细的格式显示目录内容（类似 DOS 的 <code>dir</code>）。<br><strong>语法</strong>: <code>dir [选项] [路径]</code><br><strong>常用选项</strong>:</p><ul><li><code>-a</code>: 显示所有文件（包括隐藏）。</li><li><code>-l</code>: 纵向列表显示。</li><li><code>--color</code>: 以颜色区分文件类型。<br><strong>场景</strong>: 需要与传统 DOS 风格类似的输出，或在脚本中需要更结构化的列表。<br><strong>示例</strong>:</li><li><code>dir -a /tmp</code>: 显示 <code>/tmp</code> 目录下所有文件。</li><li><code>dir --color /home</code>: 以彩色输出列出家目录内容。</li></ul></li><li><p><strong>tree</strong><br><strong>功能</strong>: 以树状结构显示目录内容（需安装 <code>sudo apt install tree</code>）。<br><strong>语法</strong>: <code>tree [选项] [路径]</code><br><strong>常用选项</strong>:</p><ul><li><code>-a</code>: 显示隐藏文件。</li><li><code>-d</code>: 仅显示目录。</li><li><code>-L 级别</code>: 限制递归深度。</li><li><code>-f</code>: 显示完整路径。<br><strong>场景</strong>: 可视化目录结构，适合文档整理或教学。<br><strong>示例</strong>:</li><li><code>tree -a /home/user</code>: 显示家目录及其子目录的完整树状结构。</li><li><code>tree -d -L 2 /etc</code>: 显示 <code>/etc</code> 目录下两级目录结构。</li></ul></li></ul><h4 id="2.-%E5%88%87%E6%8D%A2%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%9B%AE%E5%BD%95" tabindex="-1">2. 切换和查看目录</h4><ul><li><p><strong>cd</strong><br><strong>功能</strong>: 更改当前工作目录。<br><strong>语法</strong>: <code>cd [路径]</code><br><strong>常用选项/用法</strong>:</p><ul><li><code>cd ..</code>: 返回上一级目录。</li><li><code>cd -</code>: 返回上一个工作目录。</li><li><code>cd ~</code>: 切换到用户家目录。</li><li><code>cd /</code>: 切换到根目录。<br><strong>场景</strong>: 在终端导航文件系统，进入特定目录进行操作。<br><strong>示例</strong>:</li><li><code>cd /var/log</code>: 进入日志目录。</li><li><code>cd ~/Documents</code>: 进入用户家目录下的 Documents 文件夹。</li><li><code>cd .. &amp;&amp; cd /tmp</code>: 返回上一级目录后进入 <code>/tmp</code>。</li></ul></li><li><p><strong>pwd</strong><br><strong>功能</strong>: 显示当前工作目录的绝对路径。<br><strong>语法</strong>: <code>pwd [选项]</code><br><strong>常用选项</strong>:</p><ul><li><code>-P</code>: 显示物理路径（解析符号链接）。</li><li><code>-L</code>: 显示逻辑路径（包含符号链接）。<br><strong>场景</strong>: 确认当前所在目录，尤其在复杂脚本或符号链接环境中。<br><strong>示例</strong>:</li><li><code>pwd</code>: 显示当前路径，如 <code>/home/user/project</code>。</li><li><code>pwd -P</code>: 显示解析符号链接后的实际路径。</li></ul></li></ul><h4 id="3.-%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95" tabindex="-1">3. 创建文件和目录</h4><ul><li><p><strong>touch</strong><br><strong>功能</strong>: 创建空文件或更新文件的时间戳。<br><strong>语法</strong>: <code>touch [选项] 文件名</code><br><strong>常用选项</strong>:</p><ul><li><code>-t 时间</code>: 设置特定时间戳（如 <code>YYYYMMDDhhmm</code>）。</li><li><code>-m</code>: 仅更新修改时间。</li><li><code>-a</code>: 仅更新访问时间。</li><li><code>-c</code>: 若文件不存在，不创建。<br><strong>场景</strong>: 创建占位文件、更新时间戳以标记文件状态。<br><strong>示例</strong>:</li><li><code>touch file.txt</code>: 创建空文件 <code>file.txt</code>。</li><li><code>touch -t 202509141200 file.txt</code>: 将文件时间戳设为 2025 年 9 月 14 日 12:00。</li><li><code>touch -c existing_file.txt</code>: 更新现有文件时间戳，不创建新文件。</li></ul></li><li><p><strong>mkdir</strong><br><strong>功能</strong>: 创建新目录。<br><strong>语法</strong>: <code>mkdir [选项] 目录名</code><br><strong>常用选项</strong>:</p><ul><li><code>-p</code>: 创建父目录（若不存在）。</li><li><code>-m 权限</code>: 设置目录权限（如 <code>755</code>）。</li><li><code>-v</code>: 显示创建过程。<br><strong>场景</strong>: 组织文件系统、创建项目目录。<br><strong>示例</strong>:</li><li><code>mkdir newfolder</code>: 创建名为 <code>newfolder</code> 的目录。</li><li><code>mkdir -p /path/to/nested/dir</code>: 创建嵌套目录结构。</li><li><code>mkdir -m 700 private_dir</code>: 创建权限为 700 的目录。</li></ul></li></ul><h4 id="4.-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95" tabindex="-1">4. 删除文件和目录</h4><ul><li><p><strong>rm</strong><br><strong>功能</strong>: 删除文件或目录。<br><strong>语法</strong>: <code>rm [选项] 文件/目录</code><br><strong>常用选项</strong>:</p><ul><li><code>-r</code> 或 <code>-R</code>: 递归删除目录及其内容。</li><li><code>-f</code>: 强制删除，不提示确认。</li><li><code>-i</code>: 交互式删除，逐个确认。</li><li><code>-v</code>: 显示删除过程。<br><strong>场景</strong>: 清理无用文件、释放磁盘空间。<br><strong>注意</strong>: 使用 <code>-rf</code> 需谨慎，可能导致不可恢复的数据丢失。<br><strong>示例</strong>:</li><li><code>rm file.txt</code>: 删除单个文件。</li><li><code>rm -r folder</code>: 递归删除 <code>folder</code> 及其内容。</li><li><code>rm -rf /tmp/*</code>: 强制删除 <code>/tmp</code> 下的所有内容（需谨慎）。</li></ul></li><li><p><strong>rmdir</strong><br><strong>功能</strong>: 删除空目录。<br><strong>语法</strong>: <code>rmdir [选项] 目录名</code><br><strong>常用选项</strong>:</p><ul><li><code>-p</code>: 删除空目录及其空父目录。</li><li><code>-v</code>: 显示删除过程。<br><strong>场景</strong>: 删除不再需要的空目录。<br><strong>示例</strong>:</li><li><code>rmdir emptyfolder</code>: 删除空目录 <code>emptyfolder</code>。</li><li><code>rmdir -p parent/child</code>: 删除 <code>child</code> 及其空父目录 <code>parent</code>。</li></ul></li></ul><h4 id="5.-%E5%A4%8D%E5%88%B6%E5%92%8C%E7%A7%BB%E5%8A%A8" tabindex="-1">5. 复制和移动</h4><ul><li><p><strong>cp</strong><br><strong>功能</strong>: 复制文件或目录到指定位置。<br><strong>语法</strong>: <code>cp [选项] 源 目标</code><br><strong>常用选项</strong>:</p><ul><li><code>-r</code> 或 <code>-R</code>: 递归复制目录及其内容。</li><li><code>-p</code>: 保留文件属性（如权限、时间戳）。</li><li><code>-i</code>: 交互式复制，覆盖前提示。</li><li><code>-u</code>: 仅复制比目标新或不存在的文件。</li><li><code>-v</code>: 显示复制过程。<br><strong>场景</strong>: 备份文件、复制项目目录。<br><strong>示例</strong>:</li><li><code>cp file.txt /backup/</code>: 复制 <code>file.txt</code> 到 <code>/backup/</code>。</li><li><code>cp -r project /backup/</code>: 递归复制 <code>project</code> 目录。</li><li><code>cp -up *.txt /backup/</code>: 仅复制更新或新的 <code>.txt</code> 文件。</li></ul></li><li><p><strong>mv</strong><br><strong>功能</strong>: 移动或重命名文件/目录。<br><strong>语法</strong>: <code>mv [选项] 源 目标</code><br><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 交互式移动，覆盖前提示。</li><li><code>-f</code>: 强制覆盖目标文件。</li><li><code>-u</code>: 仅移动比目标新或不存在的文件。</li><li><code>-v</code>: 显示移动过程。<br><strong>场景</strong>: 重命名文件、移动文件到新位置。<br><strong>示例</strong>:</li><li><code>mv oldname.txt newname.txt</code>: 重命名文件。</li><li><code>mv project /archive/</code>: 移动 <code>project</code> 目录到 <code>/archive/</code>。</li><li><code>mv -i file.txt /existing/</code>: 若目标存在，提示是否覆盖。</li></ul></li></ul><h4 id="6.-%E9%93%BE%E6%8E%A5%E7%AE%A1%E7%90%86" tabindex="-1">6. 链接管理</h4><ul><li><strong>ln</strong><br><strong>功能</strong>: 创建硬链接或符号链接。<br><strong>语法</strong>: <code>ln [选项] 源 链接名</code><br><strong>常用选项</strong>:<ul><li><code>-s</code>: 创建符号链接（软链接）。</li><li><code>-f</code>: 强制创建，覆盖现有链接。</li><li><code>-n</code>: 不将目标视为目录。<br><strong>场景</strong>: 创建文件/目录的快捷方式，节省空间或便于访问。<br><strong>示例</strong>:</li><li><code>ln -s /var/log/app.log app_link</code>: 创建指向 <code>app.log</code> 的符号链接。</li><li><code>ln file.txt hardlink.txt</code>: 创建 <code>file.txt</code> 的硬链接。<br><strong>注意</strong>: 硬链接共享 inode，符号链接是独立文件，指向源路径。</li></ul></li></ul><h4 id="7.-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95" tabindex="-1">7. 查找文件和目录</h4><ul><li><p><strong>find</strong><br><strong>功能</strong>: 在目录中搜索文件或目录，基于名称、类型、时间等条件。<br><strong>语法</strong>: <code>find [路径] [选项]</code><br><strong>常用选项</strong>:</p><ul><li><code>-name 模式</code>: 按文件名搜索（支持通配符）。</li><li><code>-type 类型</code>: 指定类型（如 <code>f</code> 表示文件，<code>d</code> 表示目录）。</li><li><code>-mtime 天数</code>: 按修改时间搜索（如 <code>-mtime -7</code> 表示 7 天内修改）。</li><li><code>-exec 命令</code>: 对找到的文件执行命令。</li><li><code>-size 大小</code>: 按文件大小搜索（如 <code>+100M</code> 表示大于 100MB）。<br><strong>场景</strong>: 查找丢失文件、清理大文件、批量操作。<br><strong>示例</strong>:</li><li><code>find /home -name &quot;*.txt&quot;</code>: 查找家目录下所有 <code>.txt</code> 文件。</li><li><code>find / -type d -name &quot;temp&quot;</code>: 查找所有名为 <code>temp</code> 的目录。</li><li><code>find /var -size +1G -exec rm -v &#123;&#125; \;</code>: 删除 <code>/var</code> 下大于 1GB 的文件。</li></ul></li><li><p><strong>locate</strong><br><strong>功能</strong>: 快速查找文件（基于预构建的数据库）。<br><strong>语法</strong>: <code>locate [选项] 模式</code><br><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 忽略大小写。</li><li><code>-r</code>: 使用正则表达式。</li><li><code>-c</code>: 显示匹配计数。<br><strong>场景</strong>: 快速定位文件，适合频繁查找。<br><strong>注意</strong>: 需定期运行 <code>sudo updatedb</code> 更新数据库。<br><strong>示例</strong>:</li><li><code>locate config.yaml</code>: 查找所有名为 <code>config.yaml</code> 的文件。</li><li><code>locate -i readme</code>: 查找忽略大小写的 <code>readme</code> 文件。</li></ul></li></ul><h4 id="8.-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF" tabindex="-1">8. 文件系统信息</h4><ul><li><p><strong>du</strong><br><strong>功能</strong>: 计算目录或文件的磁盘使用量。<br><strong>语法</strong>: <code>du [选项] [路径]</code><br><strong>常用选项</strong>:</p><ul><li><code>-h</code>: 人类可读格式（如 KB、MB）。</li><li><code>-s</code>: 汇总目录总大小。</li><li><code>-c</code>: 显示总计。</li><li><code>--max-depth=N</code>: 限制目录深度。<br><strong>场景</strong>: 检查磁盘占用、识别大文件/目录。<br><strong>示例</strong>:</li><li><code>du -sh /home/user</code>: 显示家目录总大小。</li><li><code>du -h --max-depth=1 /var</code>: 显示 <code>/var</code> 下子目录的占用情况。</li><li><code>du -hc *.log</code>: 显示当前目录下 <code>.log</code> 文件的总大小。</li></ul></li><li><p><strong>df</strong><br><strong>功能</strong>: 显示文件系统的磁盘使用情况。<br><strong>语法</strong>: <code>df [选项] [文件系统]</code><br><strong>常用选项</strong>:</p><ul><li><code>-h</code>: 人类可读格式。</li><li><code>-T</code>: 显示文件系统类型。</li><li><code>-i</code>: 显示 inode 使用情况。<br><strong>场景</strong>: 检查磁盘剩余空间、监控存储设备。<br><strong>示例</strong>:</li><li><code>df -h</code>: 显示所有文件系统的磁盘使用情况。</li><li><code>df -T /home</code>: 显示 <code>/home</code> 的文件系统类型和使用量。</li></ul></li></ul><h4 id="9.-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E5%B1%9E%E6%80%A7" tabindex="-1">9. 文件权限与属性</h4><ul><li><p><strong>chmod</strong><br><strong>功能</strong>: 修改文件或目录的权限。<br><strong>语法</strong>: <code>chmod [选项] 权限 文件/目录</code><br><strong>常用选项</strong>:</p><ul><li><code>-R</code>: 递归修改目录及其内容。</li><li><code>-v</code>: 显示修改过程。<br><strong>权限表示</strong>:</li><li>数字表示（如 <code>755</code>: 所有者读/写/执行，组和其他读/执行）。</li><li>符号表示（如 <code>u+x</code>: 给所有者添加执行权限）。<br><strong>场景</strong>: 设置文件访问权限，保护敏感数据。<br><strong>示例</strong>:</li><li><code>chmod 644 file.txt</code>: 设置文件为所有者读写、其他读。</li><li><code>chmod -R 755 /web</code>: 递归设置 <code>/web</code> 目录权限。</li><li><code>chmod u+x script.sh</code>: 给 <code>script.sh</code> 的所有者添加执行权限。</li></ul></li><li><p><strong>chown</strong><br><strong>功能</strong>: 更改文件或目录的所有者和组。<br><strong>语法</strong>: <code>chown [选项] 用户[:组] 文件/目录</code><br><strong>常用选项</strong>:</p><ul><li><code>-R</code>: 递归更改目录及其内容。</li><li><code>-v</code>: 显示更改过程。</li><li><code>--reference=文件</code>: 使用参考文件的用户/组。<br><strong>场景</strong>: 转移文件所有权、修复权限问题。<br><strong>示例</strong>:</li><li><code>sudo chown user1 file.txt</code>: 将 <code>file.txt</code> 的所有者改为 <code>user1</code>。</li><li><code>sudo chown -R user1:group1 /data</code>: 递归更改 <code>/data</code> 的所有者和组。</li><li><code>sudo chown --reference=file1 file2</code>: 将 <code>file2</code> 的所有者/组设为与 <code>file1</code> 相同。</li></ul></li><li><p><strong>chgrp</strong><br><strong>功能</strong>: 更改文件或目录的所属组。<br><strong>语法</strong>: <code>chgrp [选项] 组 文件/目录</code><br><strong>常用选项</strong>:</p><ul><li><code>-R</code>: 递归更改。</li><li><code>-v</code>: 显示更改过程。<br><strong>场景</strong>: 调整文件所属组，管理团队访问权限。<br><strong>示例</strong>:</li><li><code>chgrp developers project</code>: 将 <code>project</code> 的所属组改为 <code>developers</code>。</li><li><code>chgrp -R staff /shared</code>: 递归更改 <code>/shared</code> 的组。</li></ul></li></ul><h4 id="10.-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E4%B8%8E%E6%93%8D%E4%BD%9C" tabindex="-1">10. 文件查看与操作</h4><ul><li><p><strong>cat</strong><br><strong>功能</strong>: 连接并显示文件内容，或创建文件。<br><strong>语法</strong>: <code>cat [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-n</code>: 显示行号。</li><li><code>-E</code>: 显示行尾的 <code>$</code> 符号。</li><li><code>-s</code>: 压缩连续空行。<br><strong>场景</strong>: 查看小文件内容、合并文件。<br><strong>示例</strong>:</li><li><code>cat file.txt</code>: 显示 <code>file.txt</code> 内容。</li><li><code>cat file1.txt file2.txt &gt; combined.txt</code>: 合并文件到 <code>combined.txt</code>。</li><li><code>cat -n log.txt</code>: 显示 <code>log.txt</code> 带行号的内容。</li></ul></li><li><p><strong>less</strong><br><strong>功能</strong>: 分页查看文件内容，支持上下滚动。<br><strong>语法</strong>: <code>less [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-N</code>: 显示行号。</li><li><code>-S</code>: 不换行显示长行。</li><li><code>-i</code>: 忽略搜索大小写。<br><strong>场景</strong>: 查看大文件、浏览日志。<br><strong>示例</strong>:</li><li><code>less /var/log/syslog</code>: 分页查看系统日志。</li><li><code>less -N config.conf</code>: 显示带行号的配置文件。</li></ul></li><li><p><strong>more</strong><br><strong>功能</strong>: 分页查看文件内容（较老，功能少于 <code>less</code>）。<br><strong>语法</strong>: <code>more [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-d</code>: 显示交互提示。</li><li><code>+num</code>: 从第 <code>num</code> 行开始显示。<br><strong>场景</strong>: 快速查看文件内容。<br><strong>示例</strong>:</li><li><code>more file.txt</code>: 分页显示 <code>file.txt</code>。</li><li><code>more +50 log.txt</code>: 从第 50 行开始显示。</li></ul></li><li><p><strong>head</strong><br><strong>功能</strong>: 显示文件开头几行（默认 10 行）。<br><strong>语法</strong>: <code>head [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-n 行数</code>: 指定显示行数。</li><li><code>-c 字节数</code>: 显示指定字节数。<br><strong>场景</strong>: 查看文件开头，检查日志或配置文件。<br><strong>示例</strong>:</li><li><code>head -n 5 file.txt</code>: 显示 <code>file.txt</code> 前 5 行。</li><li><code>head -c 100 log.txt</code>: 显示 <code>log.txt</code> 前 100 字节。</li></ul></li><li><p><strong>tail</strong><br><strong>功能</strong>: 显示文件末尾几行（默认 10 行）。<br><strong>语法</strong>: <code>tail [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-n 行数</code>: 指定显示行数。</li><li><code>-f</code>: 实时监控文件变化。<br><strong>场景</strong>: 监控日志文件、查看最新数据。<br><strong>示例</strong>:</li><li><code>tail -n 20 log.txt</code>: 显示 <code>log.txt</code> 最后 20 行。</li><li><code>tail -f /var/log/syslog</code>: 实时监控系统日志。</li></ul></li></ul><h4 id="11.-%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E5%91%BD%E4%BB%A4" tabindex="-1">11. 其他高级命令</h4><ul><li><p><strong>file</strong><br><strong>功能</strong>: 确定文件类型（如文本、二进制、目录）。<br><strong>语法</strong>: <code>file [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 输出 MIME 类型。</li><li><code>-b</code>: 仅输出文件类型，不包括文件名。<br><strong>场景</strong>: 识别文件格式，排查未知文件。<br><strong>示例</strong>:</li><li><code>file image.png</code>: 显示 <code>image.png</code> 的类型（如 PNG image）。</li><li><code>file -i /bin/ls</code>: 输出 <code>/bin/ls</code> 的 MIME 类型。</li></ul></li><li><p><strong>stat</strong><br><strong>功能</strong>: 显示文件或文件系统的详细状态信息（如时间戳、权限、inode）。<br><strong>语法</strong>: <code>stat [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-f</code>: 显示文件系统状态而非文件。</li><li><code>-c 格式</code>: 自定义输出格式。<br><strong>场景</strong>: 调试文件系统问题、查看元数据。<br><strong>示例</strong>:</li><li><code>stat file.txt</code>: 显示 <code>file.txt</code> 的详细信息。</li><li><code>stat -c %s file.txt</code>: 仅输出文件大小（字节）。</li></ul></li><li><p><strong>truncate</strong><br><strong>功能</strong>: 调整文件大小（扩展或截断）。<br><strong>语法</strong>: <code>truncate [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-s 大小</code>: 设置文件大小（如 <code>+10M</code> 扩展 10MB，<code>-10M</code> 减少 10MB）。</li><li><code>-c</code>: 不创建不存在的文件。<br><strong>场景</strong>: 创建固定大小文件、清理大文件内容。<br><strong>示例</strong>:</li><li><code>truncate -s 10M bigfile</code>: 创建或调整 <code>bigfile</code> 为 10MB。</li><li><code>truncate -s 0 log.txt</code>: 清空 <code>log.txt</code>。</li></ul></li></ul><hr><h2 id="2.-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%BC%96%E8%BE%91%EF%BC%88file-viewing-%26-editing%EF%BC%89" tabindex="-1">2. 文件查看和编辑（File Viewing &amp; Editing）</h2><h4 id="1.-%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9F%A5%E7%9C%8B" tabindex="-1">1. 文件内容查看</h4><p>这些命令用于快速查看文件内容，适合不同场景（如小文件、大文件、实时监控等）。</p><ul><li><p><strong>cat</strong><br><strong>功能</strong>: 连接并显示文件内容，或将多个文件内容合并输出，也可用于创建文件。<br><strong>语法</strong>: <code>cat [选项] [文件...]</code><br><strong>常用选项</strong>:</p><ul><li><code>-n</code>: 显示行号（包括空行）。</li><li><code>-b</code>: 显示非空行号。</li><li><code>-E</code>: 在行尾显示 <code>$</code> 符号。</li><li><code>-s</code>: 压缩连续空行为一空行。</li><li><code>-T</code>: 显示制表符为 <code>^I</code>。<br><strong>场景</strong>:</li><li>查看小型文本文件内容（如配置文件）。</li><li>合并多个文件输出到终端或新文件。</li><li>通过重定向快速创建小文件。<br><strong>示例</strong>:</li><li><code>cat config.txt</code>: 显示 <code>config.txt</code> 的内容。</li><li><code>cat -n log.txt</code>: 显示 <code>log.txt</code> 内容并带行号。</li><li><code>cat file1.txt file2.txt &gt; combined.txt</code>: 合并两个文件到 <code>combined.txt</code>。</li><li><code>cat &gt; newfile.txt</code>: 接受用户输入创建新文件（按 Ctrl+D 保存退出）。<br><strong>高级用法</strong>:</li><li>结合管道：<code>cat access.log | grep &quot;error&quot;</code>: 筛选包含 “error” 的行。</li><li>查看二进制文件（谨慎）：<code>cat -v binaryfile</code> 显示不可打印字符。<br><strong>注意</strong>: 对于大文件，<code>cat</code> 一次性输出可能导致终端卡顿，建议使用 <code>less</code> 或 <code>tail</code>。</li></ul></li><li><p><strong>less</strong><br><strong>功能</strong>: 分页查看文件内容，支持上下滚动、前后搜索，适合大文件。<br><strong>语法</strong>: <code>less [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-N</code>: 显示行号。</li><li><code>-S</code>: 不换行显示长行（水平滚动）。</li><li><code>-i</code>: 搜索时忽略大小写。</li><li><code>-m</code>: 显示类似 <code>more</code> 的百分比提示。</li><li><code>-F</code>: 若文件较小，直接显示并退出。<br><strong>场景</strong>:</li><li>浏览大型日志文件（如 <code>/var/log/syslog</code>）。</li><li>在配置文件中搜索特定内容。</li><li>查看长文档而无需加载全部内容。<br><strong>交互键</strong>:</li><li>上下箭头或 <code>j</code>/<code>k</code>: 上下移动。</li><li><code>/关键字</code>: 向前搜索。</li><li><code>?关键字</code>: 向后搜索。</li><li><code>q</code>: 退出。</li><li><code>g</code>/<code>G</code>: 跳到文件开头/结尾。<br><strong>示例</strong>:</li><li><code>less /var/log/syslog</code>: 分页查看系统日志。</li><li><code>less -N config.conf</code>: 显示带行号的配置文件。</li><li><code>less +/error log.txt</code>: 打开文件并跳转到第一个 “error” 出现处。<br><strong>高级用法</strong>:</li><li>实时监控：<code>less +F log.txt</code>（类似 <code>tail -f</code>，按 Ctrl+C 切换交互模式）。</li><li>多个文件：<code>less file1.txt file2.txt</code>，使用 <code>:n</code> 和 <code>:p</code> 切换文件。<br><strong>注意</strong>: <code>less</code> 比 <code>more</code> 更强大，支持双向滚动和搜索。</li></ul></li><li><p><strong>more</strong><br><strong>功能</strong>: 分页查看文件内容，仅支持向下滚动，功能较 <code>less</code> 简单。<br><strong>语法</strong>: <code>more [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-d</code>: 显示交互提示（如按空格继续）。</li><li><code>+num</code>: 从第 <code>num</code> 行开始显示。</li><li><code>-s</code>: 压缩连续空行。</li><li><code>-p</code>: 清屏后显示。<br><strong>场景</strong>:</li><li>快速查看中小型文件内容。</li><li>在资源受限的系统上替代 <code>less</code>。<br><strong>交互键</strong>:</li><li>空格: 下一页。</li><li><code>Enter</code>: 下一行。</li><li><code>q</code>: 退出。</li><li><code>/关键字</code>: 搜索。<br><strong>示例</strong>:</li><li><code>more file.txt</code>: 分页显示 <code>file.txt</code>。</li><li><code>more +50 log.txt</code>: 从第 50 行开始显示。</li><li><code>more -s data.txt</code>: 压缩空行后显示。<br><strong>高级用法</strong>:</li><li>结合管道：<code>ls -l | more</code>: 分页显示目录列表。<br><strong>注意</strong>: <code>more</code> 功能有限，推荐优先使用 <code>less</code>。</li></ul></li><li><p><strong>head</strong><br><strong>功能</strong>: 显示文件开头几行（默认 10 行），适合快速检查文件。<br><strong>语法</strong>: <code>head [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-n 行数</code>: 指定显示行数。</li><li><code>-c 字节数</code>: 显示指定字节数。</li><li><code>-q</code>: 多个文件时不显示文件名。</li><li><code>-v</code>: 显示文件名标题。<br><strong>场景</strong>:</li><li>查看日志或配置文件的开头。</li><li>提取 CSV 文件的表头。<br><strong>示例</strong>:</li><li><code>head -n 5 file.txt</code>: 显示 <code>file.txt</code> 前 5 行。</li><li><code>head -c 100 log.txt</code>: 显示 <code>log.txt</code> 前 100 字节。</li><li><code>head *.txt</code>: 显示当前目录下所有 <code>.txt</code> 文件的前 10 行。<br><strong>高级用法</strong>:</li><li>结合管道：<code>head -n 1 data.csv | cut -d',' -f1</code>: 提取 CSV 文件第一列的表头。<br><strong>注意</strong>: 对于二进制文件，<code>-c</code> 选项更适合。</li></ul></li><li><p><strong>tail</strong><br><strong>功能</strong>: 显示文件末尾几行（默认 10 行），支持实时监控。<br><strong>语法</strong>: <code>tail [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-n 行数</code>: 指定显示行数。</li><li><code>-f</code>: 实时监控文件变化（常用于日志）。</li><li><code>-F</code>: 监控文件，即使文件被替换。</li><li><code>-c 字节数</code>: 显示指定字节数。<br><strong>场景</strong>:</li><li>实时监控日志文件（如服务器错误日志）。</li><li>查看文件最新内容。<br><strong>示例</strong>:</li><li><code>tail -n 20 log.txt</code>: 显示 <code>log.txt</code> 最后 20 行。</li><li><code>tail -f /var/log/apache2/access.log</code>: 实时监控 Apache 访问日志。</li><li><code>tail -c 500 data.bin</code>: 显示 <code>data.bin</code> 最后 500 字节。<br><strong>高级用法</strong>:</li><li>结合管道：<code>tail -f log.txt | grep &quot;error&quot;</code>: 实时筛选日志中的错误。</li><li>监控多个文件：<code>tail -f file1.txt file2.txt</code>: 显示多个文件尾部。<br><strong>注意</strong>: 使用 <code>-f</code> 时，需按 Ctrl+C 退出监控。</li></ul></li></ul><h4 id="2.-%E6%96%87%E4%BB%B6%E7%BC%96%E8%BE%91" tabindex="-1">2. 文件编辑</h4><p>这些命令用于编辑文本文件，适合从简单修改到复杂脚本编写。</p><ul><li><p><strong>nano</strong><br><strong>功能</strong>: 简单、用户友好的终端文本编辑器，适合初学者。<br><strong>语法</strong>: <code>nano [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-w</code>: 禁用自动换行。</li><li><code>-i</code>: 自动缩进。</li><li><code>-l</code>: 显示行号。</li><li><code>-m</code>: 启用鼠标支持（若终端支持）。</li><li><code>-B</code>: 保存前备份文件。<br><strong>场景</strong>:</li><li>编辑配置文件（如 <code>/etc/apt/sources.list</code>）。</li><li>快速修改小型脚本或文本文件。<br><strong>交互键</strong>:</li><li><code>Ctrl+O</code>: 保存文件。</li><li><code>Ctrl+X</code>: 退出。</li><li><code>Ctrl+W</code>: 搜索。</li><li><code>Ctrl+\</code>: 替换。</li><li><code>Ctrl+G</code>: 查看帮助。<br><strong>示例</strong>:</li><li><code>nano config.txt</code>: 打开或创建 <code>config.txt</code> 进行编辑。</li><li><code>sudo nano -l /etc/fstab</code>: 以 root 权限编辑文件系统表并显示行号。</li><li><code>nano -B script.sh</code>: 编辑脚本并备份原文件。<br><strong>高级用法</strong>:</li><li>语法高亮：<code>nano</code> 默认支持常见文件类型的高亮，可通过 <code>~/.nanorc</code> 自定义。</li><li>打开特定行：<code>nano +10 file.txt</code> 直接跳转到第 10 行。<br><strong>注意</strong>: <code>nano</code> 适合快速编辑，复杂任务建议使用 <code>vim</code> 或 IDE。</li></ul></li><li><p><strong>vim</strong> / <strong>vi</strong><br><strong>功能</strong>: 功能强大的终端文本编辑器，支持模式化操作，适合高级用户。<br><strong>语法</strong>: <code>vim [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-R</code>: 只读模式（等同于 <code>view</code> 命令）。</li><li><code>-o</code>: 水平分割打开多个文件。</li><li><code>-O</code>: 垂直分割打开多个文件。</li><li><code>+行号</code>: 打开文件并跳转到指定行。<br><strong>模式</strong>:</li><li><strong>正常模式</strong>: 默认模式，用于导航和命令。</li><li><strong>插入模式</strong>: 输入 <code>i</code> 进入，用于编辑文本。</li><li><strong>命令模式</strong>: 输入 <code>:</code> 进入，用于执行命令（如 <code>:w</code> 保存，<code>:q</code> 退出）。</li><li><strong>可视模式</strong>: 输入 <code>v</code> 或 <code>V</code> 进入，用于选择文本。<br><strong>场景</strong>:</li><li>编辑复杂脚本、配置文件或代码。</li><li>批量文本处理（如搜索替换）。<br><strong>常用命令</strong>:</li><li><code>:w</code>: 保存文件。</li><li><code>:q</code>: 退出。</li><li><code>:wq</code> 或 <code>ZZ</code>: 保存并退出。</li><li><code>/关键字</code>: 搜索。</li><li><code>:%s/old/new/g</code>: 全局替换 <code>old</code> 为 <code>new</code>。</li><li><code>dd</code>: 删除当前行。</li><li><code>yy</code>: 复制当前行。</li><li><code>p</code>: 粘贴。<br><strong>示例</strong>:</li><li><code>vim script.py</code>: 编辑 Python 脚本。</li><li><code>sudo vim -o /etc/file1 /etc/file2</code>: 同时编辑两个配置文件。</li><li><code>vim +50 log.txt</code>: 打开 <code>log.txt</code> 并跳转到第 50 行。<br><strong>高级用法</strong>:</li><li>插件支持：通过 <code>~/.vimrc</code> 配置插件（如语法高亮、自动补全）。</li><li>批量操作：<code>vim file1 file2</code> 并用 <code>:n</code> 切换文件。</li><li>宏录制：按 <code>q</code> 录制宏，重复复杂操作。<br><strong>注意</strong>: 学习曲线较陡，建议初学者从 <code>nano</code> 开始，或使用 <code>vimtutor</code> 学习。</li></ul></li><li><p><strong>ed</strong><br><strong>功能</strong>: 经典行编辑器，功能简单，适合脚本或低资源环境。<br><strong>语法</strong>: <code>ed [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-p 提示</code>: 设置自定义提示符。</li><li><code>-s</code>: 静默模式，减少输出。<br><strong>场景</strong>:</li><li>在嵌入式系统或无 <code>nano</code>/<code>vim</code> 的环境中编辑文件。</li><li>脚本中自动化编辑。<br><strong>常用命令</strong>:</li><li><code>a</code>: 追加文本。</li><li><code>w</code>: 保存文件。</li><li><code>q</code>: 退出。</li><li><code>,p</code>: 显示全部内容。<br><strong>示例</strong>:</li><li><code>ed file.txt</code>: 打开 <code>file.txt</code> 进行行编辑。</li><li><code>echo -e &quot;1i\nHello\n.\nw\nq&quot; | ed file.txt</code>: 插入 “Hello” 并保存。<br><strong>高级用法</strong>:</li><li>脚本化编辑：<code>ed file.txt &lt; script.ed</code> 使用预定义命令编辑文件。<br><strong>注意</strong>: <code>ed</code> 操作复杂，现代系统较少使用，推荐 <code>nano</code> 或 <code>vim</code>。</li></ul></li></ul><h4 id="3.-%E6%96%87%E6%9C%AC%E8%BE%93%E5%87%BA%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91" tabindex="-1">3. 文本输出与重定向</h4><ul><li><p><strong>echo</strong><br><strong>功能</strong>: 输出文本到终端或文件，常用于脚本或创建简单内容。<br><strong>语法</strong>: <code>echo [选项] 字符串</code><br><strong>常用选项</strong>:</p><ul><li><code>-n</code>: 不添加换行符。</li><li><code>-e</code>: 启用转义字符解释（如 <code>\n</code> 表示换行）。<br><strong>场景</strong>:</li><li>快速创建小文件。</li><li>在脚本中输出变量或提示。<br><strong>示例</strong>:</li><li><code>echo &quot;Hello World&quot; &gt; file.txt</code>: 将文本写入 <code>file.txt</code>。</li><li><code>echo -e &quot;Line1\nLine2&quot; &gt;&gt; file.txt</code>: 追加两行到 <code>file.txt</code>。</li><li><code>echo $PATH</code>: 显示环境变量 <code>PATH</code>。<br><strong>高级用法</strong>:</li><li>结合管道：<code>echo &quot;Error&quot; | tee -a log.txt</code>: 输出到终端并追加到文件。</li><li>变量扩展：<code>echo &quot;User: $USER&quot; &gt; user.txt</code>: 写入当前用户名。<br><strong>注意</strong>: 对于复杂输出，考虑使用 <code>printf</code>。</li></ul></li><li><p><strong>printf</strong><br><strong>功能</strong>: 格式化输出文本到终端或文件，支持复杂格式化。<br><strong>语法</strong>: <code>printf 格式字符串 [参数...]</code><br><strong>常用选项</strong>:</p><ul><li>格式占位符：<code>%s</code>（字符串）、<code>%d</code>（整数）、<code>%f</code>（浮点数）。<br><strong>场景</strong>:</li><li>创建格式化配置文件。</li><li>在脚本中生成结构化输出。<br><strong>示例</strong>:</li><li><code>printf &quot;Name: %s, Age: %d\n&quot; &quot;Alice&quot; 25</code>: 输出格式化文本。</li><li><code>printf &quot;Value: %.2f\n&quot; 3.14159 &gt; data.txt</code>: 写入格式化浮点数。<br><strong>高级用法</strong>:</li><li>循环输出：<code>for i in &#123;1..3&#125;; do printf &quot;Item %d\n&quot; $i; done</code> 生成序列。<br><strong>注意</strong>: <code>printf</code> 比 <code>echo</code> 更适合需要精确格式的场景。</li></ul></li></ul><h4 id="4.-%E9%AB%98%E7%BA%A7%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%EF%BC%88%E9%83%A8%E5%88%86%E9%87%8D%E5%8F%A0%E6%90%9C%E7%B4%A2%2F%E5%A4%84%E7%90%86%EF%BC%89" tabindex="-1">4. 高级文本处理（部分重叠搜索/处理）</h4><p>以下命令虽常用于文本处理，但也可用于查看和编辑场景。</p><ul><li><p><strong>tee</strong><br><strong>功能</strong>: 从标准输入读取数据，同时输出到终端和文件。<br><strong>语法</strong>: <code>tee [选项] 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-a</code>: 追加而非覆盖文件。</li><li><code>-i</code>: 忽略中断信号。<br><strong>场景</strong>:</li><li>保存命令输出到文件并同时查看。</li><li>在管道中记录中间结果。<br><strong>示例</strong>:</li><li><code>ls -l | tee dirlist.txt</code>: 保存目录列表到 <code>dirlist.txt</code> 并显示。</li><li><code>echo &quot;Log entry&quot; | tee -a log.txt</code>: 追加日志条目到 <code>log.txt</code>。<br><strong>高级用法</strong>:</li><li>多文件输出：<code>ls | tee file1.txt file2.txt</code>: 写入多个文件。</li><li>结合 <code>sudo</code>：<code>ls /root | sudo tee rootlist.txt</code>: 保存受限目录列表。<br><strong>注意</strong>: 需注意文件权限，尤其是使用 <code>sudo</code> 时。</li></ul></li><li><p><strong>sed</strong><br><strong>功能</strong>: 流编辑器，用于文本替换、删除、插入等操作。<br><strong>语法</strong>: <code>sed [选项] '命令' 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-i</code>: 直接修改原文件（建议备份）。</li><li><code>-e</code>: 执行多个命令。</li><li><code>-r</code>: 使用扩展正则表达式。<br><strong>常用命令</strong>:</li><li><code>s/old/new/g</code>: 全局替换 <code>old</code> 为 <code>new</code>。</li><li><code>d</code>: 删除匹配行。</li><li><code>p</code>: 打印匹配行。<br><strong>场景</strong>:</li><li>批量修改配置文件内容。</li><li>提取特定行或字段。<br><strong>示例</strong>:</li><li><code>sed 's/error/warning/g' log.txt</code>: 将 <code>log.txt</code> 中的 “error” 替换为 “warning”。</li><li><code>sed -i.bak 's/old/new/' file.txt</code>: 替换并备份原文件到 <code>file.txt.bak</code>。</li><li><code>sed '10,20d' data.txt</code>: 删除第 10 到 20 行。<br><strong>高级用法</strong>:</li><li>结合管道：<code>cat config.txt | sed '/^#/d'</code>: 删除注释行。</li><li>多条件替换：<code>sed -e 's/old1/new1/' -e 's/old2/new2/' file.txt</code>。<br><strong>注意</strong>: <code>-i</code> 修改文件不可恢复，建议测试后使用。</li></ul></li><li><p><strong>awk</strong><br><strong>功能</strong>: 文本处理工具，适合处理结构化数据（如 CSV、日志）。<br><strong>语法</strong>: <code>awk [选项] '程序' 文件</code><br><strong>常用选项</strong>:</p><ul><li><code>-F 分隔符</code>: 指定字段分隔符。</li><li><code>-v 变量=值</code>: 定义变量。<br><strong>常用程序</strong>:</li><li><code>&#123;print $n&#125;</code>: 打印第 n 列。</li><li><code>/模式/ &#123;动作&#125;</code>: 对匹配模式执行动作。<br><strong>场景</strong>:</li><li>提取日志或 CSV 文件的特定字段。</li><li>统计和格式化文本数据。<br><strong>示例</strong>:</li><li><code>awk -F',' '&#123;print $1&#125;' data.csv</code>: 打印 CSV 文件第一列。</li><li><code>awk '/error/ &#123;print&#125;' log.txt</code>: 打印包含 “error” 的行。</li><li><code>awk '&#123;sum+=$2&#125; END &#123;print sum&#125;' numbers.txt</code>: 计算第二列总和。<br><strong>高级用法</strong>:</li><li>复杂脚本：<code>awk 'BEGIN &#123;print &quot;Start&quot;&#125; &#123;print $1&#125; END &#123;print &quot;End&quot;&#125;' file.txt</code>。</li><li>结合管道：<code>cat log.txt | awk '$3 &gt; 100 &#123;print&#125;'</code>: 筛选第三列大于 100 的行。<br><strong>注意</strong>: <code>awk</code> 功能强大，适合数据处理，但学习曲线稍陡。</li></ul></li></ul><hr><h2 id="3.-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%88permissions%EF%BC%89" tabindex="-1">3. 权限管理（Permissions）</h2><p>权限管理是 Linux 系统中确保安全和访问控制的核心功能，涉及文件和目录的所有者、所属组、访问权限（读、写、执行）以及特殊权限（如 setuid）。Ubuntu 使用基于用户（user）、组（group）和其他人（others）的权限模型，结合文件系统元数据实现访问控制。以下是与权限管理相关的核心命令及其详细说明。</p><h4 id="1.-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86" tabindex="-1">1. 权限管理基础知识</h4><p>在讲解命令之前，先简要介绍 Linux 文件权限模型，以便理解命令的作用：</p><ul><li><strong>权限组成</strong>：<ul><li><strong>用户（u）</strong>: 文件的所有者。</li><li><strong>组（g）</strong>: 文件所属的组。</li><li><strong>其他人（o）</strong>: 非所有者、非组成员的用户。</li><li><strong>权限类型</strong>：<ul><li><code>r</code>（读，read）：允许查看文件内容或列出目录。</li><li><code>w</code>（写，write）：允许修改文件内容或在目录中创建/删除文件。</li><li><code>x</code>（执行，execute）：允许运行文件（如脚本或二进制文件）或进入目录。</li></ul></li><li><strong>特殊权限</strong>：<ul><li><code>setuid</code>（s）：以文件所有者身份执行（常见于 <code>/usr/bin/passwd</code>）。</li><li><code>setgid</code>（s）：以文件所属组身份执行，或目录中新建文件继承父目录组。</li><li><code>sticky bit</code>（t）：限制目录中文件的删除（仅限文件所有者或 root，如 <code>/tmp</code>）。</li></ul></li></ul></li><li><strong>权限表示</strong>：<ul><li><strong>符号表示</strong>：如 <code>rwxr-xr-x</code>（用户读写执行，组和其他读执行）。</li><li><strong>八进制表示</strong>：如 <code>755</code>（<code>rwx=4+2+1=7</code>, <code>r-x=4+1=5</code>）。</li></ul></li><li><strong>查看权限</strong>：使用 <code>ls -l</code> 查看文件权限，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x 1 user group 1234 Sep 14 12:00 script.sh</span><br></pre></td></tr></table></figure><ul><li>第一个字符（<code>-</code> 表示文件，<code>d</code> 表示目录）。</li><li>接下来 9 个字符表示用户（<code>rwx</code>）、组（<code>r-x</code>）、其他（<code>r-x</code>）权限。</li><li><code>1</code> 表示硬链接数，<code>user</code> 是所有者，<code>group</code> 是所属组。</li></ul></li></ul><h4 id="2.-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4" tabindex="-1">2. 权限管理命令</h4><h5 id="2.1-chmod%EF%BC%88change-mode%EF%BC%89" tabindex="-1">2.1 chmod（Change Mode）</h5><p><strong>功能</strong>：修改文件或目录的访问权限（读、写、执行）及特殊权限。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [选项] 权限 文件/目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-R</code>：递归修改目录及其内容。</li><li><code>-v</code>：显示修改过程。</li><li><code>-c</code>：仅显示更改的文件。</li><li><code>--reference=参考文件</code>：使用参考文件的权限。<br><strong>权限指定方式</strong>：</li><li><strong>符号表示</strong>：<ul><li>格式：<code>[ugoa][+-=][rwxXst]</code></li><li><code>u</code>（用户）、<code>g</code>（组）、<code>o</code>（其他）、<code>a</code>（所有）。</li><li><code>+</code>（添加）、<code>-</code>（移除）、<code>=</code>（设置）。</li><li><code>r</code>（读）、<code>w</code>（写）、<code>x</code>（执行）、<code>X</code>（仅对目录或已有执行权限的文件添加执行）、<code>s</code>（setuid/setgid）、<code>t</code>（sticky bit）。</li></ul></li><li><strong>八进制表示</strong>：<ul><li>读（4）、写（2）、执行（1），相加组成三位数。</li><li>如 <code>755</code> 表示 <code>rwxr-xr-x</code>，<code>600</code> 表示 <code>rw-------</code>。<br><strong>场景</strong>：</li></ul></li><li>设置脚本可执行权限。</li><li>保护敏感文件（如私钥）。</li><li>配置共享目录权限。<br><strong>示例</strong>：</li><li><code>chmod 644 file.txt</code>：设置文件为所有者读写（<code>rw-</code>），组和其他只读（<code>r--</code>）。</li><li><code>chmod u+x script.sh</code>：为所有者添加执行权限。</li><li><code>chmod -R 755 /web</code>：递归设置 <code>/web</code> 目录及内容为 <code>rwxr-xr-x</code>。</li><li><code>chmod +t /tmp</code>：为 <code>/tmp</code> 设置 sticky bit，限制非所有者删除文件。</li><li><code>chmod --reference=template.txt file.txt</code>：将 <code>file.txt</code> 权限设为与 <code>template.txt</code> 相同。<br><strong>高级用法</strong>：</li><li>设置特殊权限：<ul><li><code>chmod u+s /bin/program</code>：设置 setuid，程序以所有者身份运行。</li><li><code>chmod g+s /shared</code>：目录中新建文件继承 <code>shared</code> 组。</li></ul></li><li>条件修改：<ul><li><code>chmod -R u+w,g-w,o-rwx /data</code>：用户添加写权限，组移除写权限，其他移除所有权限。</li></ul></li><li>结合 <code>find</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path -type f -exec chmod 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure>将目录下所有文件设为 <code>644</code>。<br><strong>注意</strong>：</li><li>使用八进制更简洁，符号表示更灵活。</li><li>递归修改（<code>-R</code>）需谨慎，避免意外更改子目录权限。</li><li>特殊权限（如 <code>setuid</code>）可能引入安全风险，需仔细验证。</li></ul><h5 id="2.2-chown%EF%BC%88change-owner%EF%BC%89" tabindex="-1">2.2 chown（Change Owner）</h5><p><strong>功能</strong>：更改文件或目录的所有者和/或所属组。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] 用户[:组] 文件/目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-R</code>：递归更改目录及其内容。</li><li><code>-v</code>：显示更改过程。</li><li><code>-c</code>：仅显示更改的文件。</li><li><code>--reference=参考文件</code>：使用参考文件的所有者/组。</li><li><code>--from=当前用户:当前组</code>：仅更改匹配当前用户/组的文件。<br><strong>参数</strong>：</li><li><code>用户</code>：用户名或 UID（如 <code>#1000</code>）。</li><li><code>组</code>：组名或 GID（如 <code>#1000</code>），可省略（如 <code>chown user file</code>）。<br><strong>场景</strong>：</li><li>转移文件所有权（如将备份文件交给其他用户）。</li><li>修复错误的所有者/组设置。</li><li>配置共享目录的组访问。<br><strong>示例</strong>：</li><li><code>sudo chown user1 file.txt</code>：将 <code>file.txt</code> 的所有者改为 <code>user1</code>。</li><li><code>sudo chown user1:group1 data.txt</code>：设置所有者和组为 <code>user1:group1</code>。</li><li><code>sudo chown -R user1:group1 /data</code>：递归更改 <code>/data</code> 的所有者和组。</li><li><code>sudo chown --reference=template.txt file.txt</code>：将 <code>file.txt</code> 的所有者/组设为与 <code>template.txt</code> 相同。</li><li><code>sudo chown --from=user2:group2 user1:group1 file.txt</code>：仅当文件属于 <code>user2:group2</code> 时更改。<br><strong>高级用法</strong>：</li><li>结合 <code>find</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path -type d -exec chown user1:group1 &#123;&#125; \;</span><br></pre></td></tr></table></figure>将目录下所有子目录的所有者和组改为 <code>user1:group1</code>。</li><li>只更改组：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown :group1 file.txt</span><br></pre></td></tr></table></figure>仅更改所属组。<br><strong>注意</strong>：</li><li>通常需要 <code>sudo</code> 权限更改系统文件或非当前用户拥有的文件。</li><li>UID/GID 格式（如 <code>#1000</code>）需在某些 shell 中转义（如 <code>\#1000</code>）。</li><li>递归操作（<code>-R</code>）需检查目标范围，避免影响无关文件。</li></ul><h5 id="2.3-chgrp%EF%BC%88change-group%EF%BC%89" tabindex="-1">2.3 chgrp（Change Group）</h5><p><strong>功能</strong>：更改文件或目录的所属组（功能是 <code>chown</code> 的子集）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] 组 文件/目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-R</code>：递归更改。</li><li><code>-v</code>：显示更改过程。</li><li><code>-c</code>：仅显示更改的文件。</li><li><code>--reference=参考文件</code>：使用参考文件的组。<br><strong>参数</strong>：</li><li><code>组</code>：组名或 GID（如 <code>#1000</code>）。<br><strong>场景</strong>：</li><li>设置共享目录的组权限（如团队协作目录）。</li><li>修复组分配错误。<br><strong>示例</strong>：</li><li><code>sudo chgrp developers project</code>：将 <code>project</code> 的所属组改为 <code>developers</code>。</li><li><code>sudo chgrp -R staff /shared</code>：递归更改 <code>/shared</code> 的组为 <code>staff</code>。</li><li><code>sudo chgrp --reference=template.txt file.txt</code>：将 <code>file.txt</code> 的组设为与 <code>template.txt</code> 相同。<br><strong>高级用法</strong>：</li><li>结合 <code>find</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /path -type f -exec chgrp users &#123;&#125; \;</span><br></pre></td></tr></table></figure>将目录下所有文件的组改为 <code>users</code>。</li><li>设置目录继承组：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod g+s /shared &amp;&amp; chgrp staff /shared</span><br></pre></td></tr></table></figure>确保 <code>/shared</code> 中新建文件继承 <code>staff</code> 组。<br><strong>注意</strong>：</li><li><code>chgrp</code> 是 <code>chown</code> 的简化版，推荐优先使用 <code>chown :group</code>。</li><li>需要 <code>sudo</code> 更改非当前用户组的文件。</li></ul><h5 id="2.4-setfacl%EF%BC%88set-file-access-control-list%EF%BC%89" tabindex="-1">2.4 setfacl（Set File Access Control List）</h5><p><strong>功能</strong>：设置访问控制列表（ACL），为文件或目录分配更细粒度的权限（如特定用户/组的权限）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl [选项] -m|-x 规则 文件/目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-m</code>：添加或修改 ACL 规则。</li><li><code>-x</code>：删除指定 ACL 规则。</li><li><code>-R</code>：递归应用。</li><li><code>-b</code>：删除所有 ACL 规则。</li><li><code>--set</code>：完全替换 ACL。</li><li><code>-d</code>：设置默认 ACL（目录中新文件继承）。<br><strong>规则格式</strong>：</li><li><code>u:用户:权限</code>：为特定用户设置权限（如 <code>u:user1:rwx</code>）。</li><li><code>g:组:权限</code>：为特定组设置权限。</li><li><code>m:权限</code>：设置掩码（限制 ACL 权限）。</li><li><code>o:权限</code>：设置其他用户权限。<br><strong>场景</strong>：</li><li>为特定用户/组设置权限，而不影响标准权限。</li><li>配置共享目录的复杂访问控制。<br><strong>示例</strong>：</li><li><code>setfacl -m u:user1:rw file.txt</code>：为 <code>user1</code> 设置读写权限。</li><li><code>setfacl -R -m g:developers:rwx /project</code>：为 <code>developers</code> 组递归设置读写执行权限。</li><li><code>setfacl -d -m u:user1:rwx /shared</code>：目录中新文件默认授予 <code>user1</code> 读写执行权限。</li><li><code>setfacl -x u:user1 file.txt</code>：移除 <code>user1</code> 的 ACL 权限。</li><li><code>setfacl -b file.txt</code>：删除所有 ACL 规则。<br><strong>查看 ACL</strong>：</li><li><code>getfacl file.txt</code>：显示 <code>file.txt</code> 的 ACL 信息。<br><strong>高级用法</strong>：</li><li>结合标准权限：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 /data &amp;&amp; setfacl -m u:user1:rwx /data</span><br></pre></td></tr></table></figure>限制目录仅限所有者和 <code>user1</code> 访问。</li><li>递归恢复默认 ACL：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setfacl -R -m d:g:staff:rwx /shared</span><br></pre></td></tr></table></figure>确保目录及子目录新文件继承 <code>staff</code> 组权限。<br><strong>注意</strong>：</li><li>需要文件系统支持 ACL（如 ext4，需启用 <code>acl</code> 挂载选项）。</li><li>安装 ACL 工具：<code>sudo apt install acl</code>。</li><li>ACL 与标准权限（<code>chmod</code>）共存，掩码（<code>mask</code>）可能限制 ACL 权限。</li></ul><h5 id="2.5-umask%EF%BC%88user-mask%EF%BC%89" tabindex="-1">2.5 umask（User Mask）</h5><p><strong>功能</strong>：设置新建文件和目录的默认权限掩码，影响默认权限（文件默认 <code>666</code>，目录默认 <code>777</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask [掩码]</span><br></pre></td></tr></table></figure><p><strong>掩码格式</strong>：</p><ul><li>八进制值，如 <code>022</code>（从默认权限减去掩码）。</li><li>结果：文件权限为 <code>666 - umask</code>，目录为 <code>777 - umask</code>。<ul><li>如 <code>umask 022</code>，新建文件为 <code>644</code>（<code>rw-r--r--</code>），目录为 <code>755</code>（<code>rwxr-xr-x</code>）。<br><strong>场景</strong>：</li></ul></li><li>控制用户或脚本创建文件/目录的默认权限。</li><li>确保共享目录的安全性。<br><strong>示例</strong>：</li><li><code>umask 022</code>：设置掩码，新建文件为 <code>644</code>，目录为 <code>755</code>。</li><li><code>umask 077</code>：新建文件为 <code>600</code>（<code>rw-------</code>），目录为 <code>700</code>（<code>rwx------</code>）。</li><li>查看当前掩码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask</span><br></pre></td></tr></table></figure>输出如 <code>0022</code>。</li><li>符号表示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask u=rwx,g=rx,o=rx</span><br></pre></td></tr></table></figure>等同于 <code>022</code>。<br><strong>高级用法</strong>：</li><li>在 shell 配置文件（如 <code>~/.bashrc</code>）设置默认 <code>umask</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;umask 027&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>新建文件为 <code>640</code>（<code>rw-r-----</code>），目录为 <code>750</code>（<code>rwxr-x---</code>）。</li><li>临时修改：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask 002 &amp;&amp; touch file.txt</span><br></pre></td></tr></table></figure>创建 <code>file.txt</code> 为 <code>664</code>（<code>rw-rw-r--</code>）。<br><strong>注意</strong>：</li><li><code>umask</code> 仅影响新文件/目录，不修改现有文件。</li><li>系统默认 <code>umask</code> 通常为 <code>022</code>（普通用户）或 <code>002</code>（共享环境）。</li><li>检查 <code>/etc/login.defs</code> 或 <code>/etc/profile</code> 中的全局 <code>umask</code> 设置。</li></ul><h5 id="2.6-sudo%EF%BC%88%E4%B8%8E%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%EF%BC%89" tabindex="-1">2.6 sudo（与权限管理相关）</h5><p><strong>功能</strong>：以其他用户（通常 root）身份执行命令，间接管理权限敏感操作。<br><strong>语法</strong>（参考前文提供的 <code>sudo_manual.txt</code> 翻译）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo [选项] 命令</span><br></pre></td></tr></table></figure><p><strong>与权限管理相关选项</strong>：</p><ul><li><code>-u 用户</code>：以指定用户身份运行命令。</li><li><code>-g 组</code>：以指定组身份运行命令。</li><li><code>-e</code>（sudoedit）：编辑文件，保留调用者环境。<br><strong>场景</strong>：</li><li>修改系统文件（如 <code>/etc/fstab</code>）的权限。</li><li>更改受限文件的所有者或组。<br><strong>示例</strong>：</li><li><code>sudo chmod 600 /etc/shadow</code>：设置影子文件仅 root 可读写。</li><li><code>sudo chown root:root /etc/passwd</code>：确保密码文件由 root 拥有。</li><li><code>sudo -u user1 touch /home/user1/file.txt</code>：以 <code>user1</code> 身份创建文件。<br><strong>高级用法</strong>：</li><li>编辑受限文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudoedit /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>使用用户编辑器编辑配置文件。</li><li>结合 <code>chown</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo -u user1 chown user1:group1 /home/user1/data</span><br></pre></td></tr></table></figure>以 <code>user1</code> 身份更改文件所有者。<br><strong>注意</strong>：</li><li><code>sudo</code> 需要在 <code>/etc/sudoers</code> 中配置权限，建议用 <code>visudo</code> 编辑。</li><li>滥用 <code>sudo</code> 可能导致安全风险，需谨慎配置。</li></ul><h4 id="3.-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B" tabindex="-1">3. 使用场景与示例</h4><p>以下是权限管理命令在实际任务中的应用：</p><ol><li><p><strong>保护敏感文件</strong>：</p><ul><li>设置私钥文件仅所有者可读：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 600 ~/.ssh/id_rsa</span><br><span class="line">chown user1 ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure></li><li>确保只有 root 访问影子文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 600 /etc/shadow</span><br><span class="line">sudo chown root:shadow /etc/shadow</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>配置共享目录</strong>：</p><ul><li>创建团队共享目录，组内可读写：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /shared</span><br><span class="line">sudo chown :developers /shared</span><br><span class="line">sudo chmod 770 /shared</span><br><span class="line">sudo chmod g+s /shared</span><br></pre></td></tr></table></figure>新文件继承 <code>developers</code> 组。</li></ul></li><li><p><strong>细粒度权限控制</strong>：</p><ul><li>允许特定用户访问目录：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo setfacl -m u:user1:rwx /data</span><br><span class="line">getfacl /data</span><br></pre></td></tr></table></figure></li><li>设置目录默认 ACL：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo setfacl -d -m g:staff:rwx /shared</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修复权限错误</strong>：</p><ul><li>批量恢复 <code>/var/log</code> 权限：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo find /var/log -type f -exec chmod 644 &#123;&#125; \;</span><br><span class="line">sudo find /var/log -type d -exec chmod 755 &#123;&#125; \;</span><br><span class="line">sudo chown -R root:adm /var/log</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>控制默认权限</strong>：</p><ul><li>设置用户默认创建文件为 <code>640</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;umask 027&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br><span class="line">touch newfile.txt  # 权限为 rw-r-----</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="4.-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" tabindex="-1">4. 高级用法</h4><ul><li><p><strong>自动化权限管理</strong>：</p><ul><li>使用脚本批量设置权限：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">find /data -<span class="built_in">type</span> f -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 &#123;&#125; \;</span><br><span class="line">find /data -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 755 &#123;&#125; \;</span><br><span class="line"><span class="built_in">chown</span> -R user1:group1 /data</span><br></pre></td></tr></table></figure>保存为 <code>set_permissions.sh</code>，运行 <code>bash set_permissions.sh</code>。</li></ul></li><li><p><strong>ACL 与标准权限结合</strong>：</p><ul><li>限制目录访问，但允许特定用户：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 /private</span><br><span class="line">setfacl -m u:user1:rwx /private</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>监控权限变化</strong>：</p><ul><li>使用 <code>inotifywait</code>（需安装 <code>inotify-tools</code>）监控权限变化：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install inotify-tools</span><br><span class="line">inotifywait -m /data -e attrib</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结合 <code>sudoers</code> 限制权限操作</strong>：</p><ul><li>编辑 <code>/etc/sudoers</code> 限制用户只能运行特定权限命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user1 ALL=(ALL) /bin/chmod, /bin/chown</span><br></pre></td></tr></table></figure>允许 <code>user1</code> 使用 <code>sudo chmod</code> 和 <code>sudo chown</code>。</li></ul></li></ul><h4 id="5.-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%89%A9%E5%B1%95" tabindex="-1">5. 注意事项与扩展</h4><ol><li><strong>权限安全</strong>：<ul><li>避免为非必要文件设置 <code>setuid</code> 或 <code>setgid</code>，防止提权漏洞。</li><li>定期检查敏感文件权限（如 <code>/etc/shadow</code>、<code>~/.ssh/*</code>）。</li><li>使用 <code>ls -l</code> 或 <code>getfacl</code> 验证权限设置。</li></ul></li><li><strong>递归操作风险</strong>：<ul><li><code>chmod -R</code>、<code>chown -R</code> 等需明确路径，避免影响系统文件。</li><li>测试前备份：<code>cp -r /dir /dir.bak</code>。</li></ul></li><li><strong>ACL 支持</strong>：<ul><li>确保文件系统支持 ACL（检查 <code>/etc/fstab</code> 是否有 <code>acl</code> 选项）。</li><li>使用 <code>tune2fs -o acl /dev/sdX</code> 启用 ACL（需谨慎）。</li></ul></li><li><strong>学习资源</strong>：<ul><li>查看手册：<code>man chmod</code>, <code>man chown</code>, <code>man setfacl</code>, <code>man umask</code>。</li><li>安装 <code>tldr</code>（<code>sudo apt install tldr</code>）获取简明示例。</li><li>在线教程：如 Ubuntu 社区文档或 DigitalOcean 的权限管理指南。</li></ul></li><li><strong>相关工具</strong>：<ul><li><strong>lsattr</strong> / <strong>chattr</strong>：管理文件属性（如不可变文件）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chattr +i file.txt  # 设为不可修改</span><br><span class="line">lsattr file.txt</span><br></pre></td></tr></table></figure></li><li><strong>getfacl</strong>：查看 ACL 信息。</li><li><strong>stat</strong>：查看文件元数据（包括权限、所有者）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stat -c &quot;%A %U %G&quot; file.txt</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="4.-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88process-management%EF%BC%89" tabindex="-1">4. 进程管理（Process Management）</h2><p>进程管理是 Linux 系统中监控和控制运行程序（进程）的关键任务，涉及查看进程状态、调整优先级、终止进程、后台运行等操作。Ubuntu 的进程管理工具提供了从简单查看（如 <code>ps</code>）到复杂监控（如 <code>htop</code>）的功能，适合系统管理员、开发者和普通用户。以下按功能分类讲解相关命令。</p><h4 id="1.-%E8%BF%9B%E7%A8%8B%E6%9F%A5%E7%9C%8B%E4%B8%8E%E7%9B%91%E6%8E%A7" tabindex="-1">1. 进程查看与监控</h4><p>这些命令用于查看运行中的进程、资源使用情况和系统状态。</p><h5 id="1.1-ps%EF%BC%88process-status%EF%BC%89" tabindex="-1">1.1 ps（Process Status）</h5><p><strong>功能</strong>：显示当前系统进程的快照，列出进程 ID（PID）、用户、命令等信息。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-e</code> 或 <code>aux</code>：显示所有进程（包括其他用户的）。</li><li><code>-u 用户</code>：显示指定用户的进程。</li><li><code>-f</code>：显示完整格式（包括 PPID、启动时间等）。</li><li><code>-p PID</code>：显示指定 PID 的进程。</li><li><code>--forest</code>：以树状结构显示进程层次。</li><li><code>-o 字段</code>：自定义输出字段（如 <code>pid,comm,%cpu</code>）。<br><strong>场景</strong>：</li><li>检查特定进程是否运行。</li><li>查看进程的父子关系。</li><li>获取进程详细信息（如 CPU/内存使用）。<br><strong>示例</strong>：</li><li><code>ps aux</code>：列出所有进程，包含用户、PID、CPU/内存使用等。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">user1     1234  0.0  0.1 123456  7890 pts/0    S    12:00   0:01 bash</span><br></pre></td></tr></table></figure></li><li><code>ps -u user1</code>：显示 <code>user1</code> 用户的进程。</li><li><code>ps -ef --forest</code>：显示进程树，查看父子关系。</li><li><code>ps -p 1234 -o pid,comm</code>：显示 PID 为 1234 的进程名称。<br><strong>高级用法</strong>：</li><li>结合 <code>grep</code> 筛选：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep firefox</span><br></pre></td></tr></table></figure>查找 Firefox 进程。</li><li>自定义输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eo pid,ppid,%cpu,comm --sort=-%cpu</span><br></pre></td></tr></table></figure>按 CPU 使用率降序显示进程。<br><strong>注意</strong>：</li><li><code>ps aux</code> 是 BSD 风格，<code>ps -ef</code> 是 System V 风格，输出格式略有不同。</li><li>输出可能较多，建议结合 <code>less</code> 或 <code>grep</code> 过滤。</li></ul><h5 id="1.2-top" tabindex="-1">1.2 top</h5><p><strong>功能</strong>：实时显示系统进程状态，包括 CPU、内存使用、进程列表等。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-d 秒</code>：设置刷新间隔（默认 3 秒）。</li><li><code>-p PID</code>：仅监控指定 PID。</li><li><code>-u 用户</code>：显示指定用户的进程。<br><strong>交互键</strong>：</li><li><code>q</code>：退出。</li><li><code>k</code>：输入 PID 终止进程。</li><li><code>r</code>：输入 PID 修改进程优先级（nice 值）。</li><li><code>f</code>：进入字段管理，选择显示列。</li><li><code>P</code>：按 CPU 使用排序。</li><li><code>M</code>：按内存使用排序。<br><strong>场景</strong>：</li><li>实时监控系统负载和进程资源使用。</li><li>识别占用 CPU/内存过高的进程。<br><strong>示例</strong>：</li><li><code>top</code>：启动实时监控。</li><li><code>top -d 1</code>：每秒刷新进程状态。</li><li><code>top -u user1</code>：仅显示 <code>user1</code> 的进程。<br><strong>高级用法</strong>：</li><li>保存快照：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -b -n 1 &gt; top_output.txt</span><br></pre></td></tr></table></figure>运行一次并保存输出（批处理模式）。</li><li>监控特定进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -p 1234</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>top</code> 是交互式工具，适合手动监控。</li><li>对于更现代化的界面，推荐使用 <code>htop</code>。</li></ul><h5 id="1.3-htop" tabindex="-1">1.3 htop</h5><p><strong>功能</strong>：增强版的 <code>top</code>，提供彩色界面、交互式操作和直观显示（需安装 <code>sudo apt install htop</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-d 秒</code>：设置刷新间隔。</li><li><code>-u 用户</code>：仅显示指定用户的进程。</li><li><code>-s 列</code>：按指定列排序（如 <code>CPU</code>、<code>MEM</code>）。<br><strong>交互键</strong>：</li><li><code>F2</code>：配置界面（调整显示列）。</li><li><code>F3</code> 或 <code>/</code>：搜索进程。</li><li><code>F5</code>：显示进程树。</li><li><code>F9</code>：终止进程（选择信号）。</li><li><code>F7/F8</code>：降低/提高进程优先级（nice 值）。</li><li><code>q</code>：退出。<br><strong>场景</strong>：</li><li>直观监控系统性能。</li><li>快速终止或调整进程优先级。<br><strong>示例</strong>：</li><li><code>htop</code>：启动交互界面。</li><li><code>htop -u user1</code>：显示 <code>user1</code> 的进程。</li><li><code>htop -s PERCENT_CPU</code>：按 CPU 使用率排序。<br><strong>高级用法</strong>：</li><li>筛选进程：<ul><li>按 <code>F3</code> 输入关键字（如 “python”）过滤。</li></ul></li><li>批量操作：<ul><li>使用 <code>F7</code>/<code>F8</code> 调整多个进程优先级。<br><strong>注意</strong>：</li></ul></li><li><code>htop</code> 需要安装，默认不包含在 Ubuntu 中。</li><li>比 <code>top</code> 更用户友好，支持鼠标操作。</li></ul><h5 id="1.4-pstree" tabindex="-1">1.4 pstree</h5><p><strong>功能</strong>：以树状结构显示进程层次关系，突出父子进程。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree [选项] [PID|用户]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-p</code>：显示 PID。</li><li><code>-u</code>：显示用户转换（当进程切换用户时）。</li><li><code>-a</code>：显示命令行参数。</li><li><code>-h</code>：高亮当前用户的进程。<br><strong>场景</strong>：</li><li>查看进程的父子关系（如服务进程的子进程）。</li><li>分析复杂进程结构。<br><strong>示例</strong>：</li><li><code>pstree</code>：显示所有进程树。</li><li><code>pstree -p user1</code>：显示 <code>user1</code> 的进程树，包含 PID。</li><li><code>pstree -a 1234</code>：显示 PID 为 1234 的进程及其子进程的命令行。<br><strong>高级用法</strong>：</li><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -a | grep apache</span><br></pre></td></tr></table></figure>查看 Apache 相关的进程树。<br><strong>注意</strong>：</li><li>输出可能较长，建议结合 <code>less</code> 查看。</li></ul><h4 id="2.-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6" tabindex="-1">2. 进程控制</h4><p>这些命令用于控制进程的运行状态，如终止、暂停、调整优先级等。</p><h5 id="2.1-kill" tabindex="-1">2.1 kill</h5><p><strong>功能</strong>：向指定进程发送信号（默认 SIGTERM）以终止或控制其行为。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [选项] PID...</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-信号</code>：指定信号编号或名称（如 <code>-9</code> 或 <code>-SIGKILL</code>）。</li><li><code>-l</code>：列出支持的信号。<br><strong>常用信号</strong>：</li><li><code>1</code>（SIGHUP）：重新加载配置（常用于服务）。</li><li><code>2</code>（SIGINT）：中断进程（类似 Ctrl+C）。</li><li><code>9</code>（SIGKILL）：强制终止（不可捕获）。</li><li><code>15</code>（SIGTERM）：优雅终止（默认）。<br><strong>场景</strong>：</li><li>终止无响应的进程。</li><li>重新加载服务配置。<br><strong>示例</strong>：</li><li><code>kill 1234</code>：向 PID 1234 发送 SIGTERM。</li><li><code>kill -9 1234</code>：强制终止 PID 1234。</li><li><code>kill -HUP 5678</code>：使 PID 5678 重新加载配置。</li><li><code>kill -l</code>：列出所有信号名称。<br><strong>高级用法</strong>：</li><li>批量终止：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill $(pgrep firefox)</span><br></pre></td></tr></table></figure>终止所有 Firefox 进程。</li><li>结合 <code>ps</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep python | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill</span><br></pre></td></tr></table></figure>终止所有 Python 进程。<br><strong>注意</strong>：</li><li><code>SIGKILL</code>（<code>-9</code>）不可捕获，可能导致数据丢失，优先使用 <code>SIGTERM</code>。</li><li>需确保 PID 正确，避免误杀系统进程。</li></ul><h5 id="2.2-killall" tabindex="-1">2.2 killall</h5><p><strong>功能</strong>：按进程名称（而非 PID）发送信号终止进程。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [选项] 进程名</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-i</code>：交互式，逐个确认。</li><li><code>-u 用户</code>：终止指定用户的进程。</li><li><code>-s 信号</code>：指定信号（如 <code>-s SIGKILL</code>）。<br><strong>场景</strong>：</li><li>快速终止所有同名进程（如停止所有 <code>apache2</code> 实例）。</li><li>清理用户会话中的进程。<br><strong>示例</strong>：</li><li><code>killall firefox</code>：终止所有 Firefox 进程。</li><li><code>killall -u user1</code>：终止 <code>user1</code> 的所有进程。</li><li><code>killall -i python</code>：交互式终止 Python 进程。<br><strong>高级用法</strong>：</li><li>结合信号：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -s SIGHUP nginx</span><br></pre></td></tr></table></figure>重新加载 Nginx 配置。<br><strong>注意</strong>：</li><li>进程名需精确匹配，避免终止无关进程。</li><li>需要 <code>sudo</code> 终止非当前用户的进程。</li></ul><h5 id="2.3-pkill" tabindex="-1">2.3 pkill</h5><p><strong>功能</strong>：按进程名、用户或其他属性发送信号，类似 <code>killall</code> 但更灵活。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill [选项] 模式</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-u 用户</code>：匹配指定用户的进程。</li><li><code>-f</code>：匹配完整命令行（而非仅进程名）。</li><li><code>-signal</code>：指定信号（如 <code>-9</code>）。<br><strong>场景</strong>：</li><li>按模式终止进程（如正则匹配）。</li><li>清理特定用户的进程。<br><strong>示例</strong>：</li><li><code>pkill firefox</code>：终止所有 Firefox 进程。</li><li><code>pkill -u user1</code>：终止 <code>user1</code> 的所有进程。</li><li><code>pkill -f &quot;python script.py&quot;</code>：终止运行 <code>script.py</code> 的 Python 进程。<br><strong>高级用法</strong>：</li><li>按正则匹配：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -f &quot;.*python.*&quot;</span><br></pre></td></tr></table></figure>终止所有包含 “python” 的进程。<br><strong>注意</strong>：</li><li><code>-f</code> 选项可能匹配过多，需谨慎使用。</li><li>建议先用 <code>pgrep</code> 验证匹配的进程。</li></ul><h5 id="2.4-pgrep" tabindex="-1">2.4 pgrep</h5><p><strong>功能</strong>：查找匹配进程名或其他属性的进程 PID。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep [选项] 模式</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-u 用户</code>：匹配指定用户的进程。</li><li><code>-f</code>：匹配完整命令行。</li><li><code>-l</code>：显示 PID 和进程名。</li><li><code>-c</code>：输出匹配进程数量。<br><strong>场景</strong>：</li><li>获取进程 PID 供 <code>kill</code> 或其他命令使用。</li><li>检查特定进程是否运行。<br><strong>示例</strong>：</li><li><code>pgrep firefox</code>：输出所有 Firefox 进程的 PID。</li><li><code>pgrep -l python</code>：显示 Python 进程的 PID 和名称。</li><li><code>pgrep -u user1</code>：列出 <code>user1</code> 的进程 PID。</li><li><code>pgrep -c apache2</code>：统计 Apache2 进程数量。<br><strong>高级用法</strong>：</li><li>结合 <code>kill</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pgrep nginx | xargs kill -HUP</span><br></pre></td></tr></table></figure>重新加载所有 Nginx 进程。<br><strong>注意</strong>：</li><li>模式是正则表达式，需避免匹配无关进程。</li><li>使用 <code>-f</code> 时需精确匹配命令行。</li></ul><h4 id="3.-%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%8E%E8%B0%83%E5%BA%A6" tabindex="-1">3. 进程优先级与调度</h4><p>这些命令用于调整进程的优先级和调度行为。</p><h5 id="3.1-nice" tabindex="-1">3.1 nice</h5><p><strong>功能</strong>：设置新启动进程的优先级（nice 值，范围 -20 到 19，值越大优先级越低）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice [选项] 命令</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-n 值</code>：设置 nice 值（默认 +10）。<br><strong>场景</strong>：</li><li>降低后台任务的优先级，减少对系统的干扰。</li><li>为关键任务设置高优先级。<br><strong>示例</strong>：</li><li><code>nice -n 10 backup.sh</code>：以 nice 值 10 运行备份脚本。</li><li><code>nice -n -5 critical_task</code>：以高优先级（-5）运行任务（需 <code>sudo</code>）。<br><strong>高级用法</strong>：</li><li>结合 <code>sudo</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nice -n -10 service start</span><br></pre></td></tr></table></figure>以高优先级启动服务。<br><strong>注意</strong>：</li><li>普通用户只能增加 nice 值（降低优先级），降低 nice 值需 <code>sudo</code>。</li><li>nice 值影响 CPU 调度，非实时优先级。</li></ul><h5 id="3.2-renice" tabindex="-1">3.2 renice</h5><p><strong>功能</strong>：修改运行中进程的 nice 值。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice 值 -p PID</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-p PID</code>：指定进程 PID。</li><li><code>-u 用户</code>：修改指定用户的所有进程。</li><li><code>-g 组</code>：修改指定组的进程。<br><strong>场景</strong>：</li><li>调整正在运行的进程优先级。</li><li>优化系统资源分配。<br><strong>示例</strong>：</li><li><code>renice 10 -p 1234</code>：将 PID 1234 的 nice 值设为 10。</li><li><code>sudo renice -5 -u user1</code>：将 <code>user1</code> 的所有进程优先级设为 -5。<br><strong>高级用法</strong>：</li><li>批量调整：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice 15 -p $(pgrep python)</span><br></pre></td></tr></table></figure>降低所有 Python 进程的优先级。<br><strong>注意</strong>：</li><li>降低 nice 值（提高优先级）需 <code>sudo</code>。</li><li>调整优先级对 I/O 密集型任务影响有限。</li></ul><h4 id="4.-%E5%90%8E%E5%8F%B0%E4%B8%8E%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6" tabindex="-1">4. 后台与作业控制</h4><p>这些命令用于管理前台/后台进程和 shell 作业。</p><h5 id="4.1-bg" tabindex="-1">4.1 bg</h5><p><strong>功能</strong>：将暂停的作业移到后台运行。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg [作业ID]</span><br></pre></td></tr></table></figure><p><strong>场景</strong>：</p><ul><li>恢复暂停的进程（如 Ctrl+Z 暂停的程序）。</li><li>在终端运行长时间任务。<br><strong>示例</strong>：</li><li>运行脚本并暂停：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 1000</span><br><span class="line"># 按 Ctrl+Z 暂停</span><br><span class="line">bg</span><br></pre></td></tr></table></figure>将 <code>sleep</code> 移到后台运行。</li><li>指定作业：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %1</span><br></pre></td></tr></table></figure>恢复作业 ID 为 1 的进程。<br><strong>高级用法</strong>：</li><li>查看作业：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br></pre></td></tr></table></figure>显示当前 shell 的作业列表。<br><strong>注意</strong>：</li><li>作业 ID 通过 <code>jobs</code> 查看。</li><li>后台进程断开终端后可能终止（除非使用 <code>nohup</code> 或 <code>disown</code>）。</li></ul><h5 id="4.2-fg" tabindex="-1">4.2 fg</h5><p><strong>功能</strong>：将后台或暂停的作业移到前台运行。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg [作业ID]</span><br></pre></td></tr></table></figure><p><strong>场景</strong>：</p><ul><li>恢复后台进程以交互。</li><li>继续暂停的任务。<br><strong>示例</strong>：</li><li><code>fg %1</code>：将作业 ID 1 移到前台。</li><li>暂停后恢复：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sleep 1000</span><br><span class="line"># 按 Ctrl+Z</span><br><span class="line">fg</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>结合 <code>jobs</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br><span class="line">fg %2</span><br></pre></td></tr></table></figure>查看并恢复特定作业。<br><strong>注意</strong>：</li><li>前台进程会占用终端，直到完成或再次暂停。</li></ul><h5 id="4.3-nohup" tabindex="-1">4.3 nohup</h5><p><strong>功能</strong>：使进程在终端断开后继续运行，忽略挂起信号（SIGHUP）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup 命令 [参数] &amp;</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li>输出默认写入 <code>nohup.out</code>。<br><strong>场景</strong>：</li><li>运行长时间任务（如备份、编译），即使终端关闭。</li><li>远程 SSH 会话中保持进程运行。<br><strong>示例</strong>：</li><li><code>nohup python script.py &amp;</code>：后台运行 Python 脚本，输出到 <code>nohup.out</code>。</li><li><code>nohup backup.sh &gt; backup.log 2&gt;&amp;1 &amp;</code>：重定向输出到 <code>backup.log</code>。<br><strong>高级用法</strong>：</li><li>结合 <code>nice</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup nice -n 10 long_task.sh &amp;</span><br></pre></td></tr></table></figure>以低优先级运行后台任务。<br><strong>注意</strong>：</li><li>进程仍在后台运行，需用 <code>ps</code> 或 <code>jobs</code> 检查。</li><li>建议重定向输出，避免 <code>nohup.out</code> 过大。</li></ul><h5 id="4.4-disown" tabindex="-1">4.4 disown</h5><p><strong>功能</strong>：从当前 shell 的作业表中移除进程，使其不受终端关闭影响。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disown [选项] [作业ID]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-h</code>：保持作业接收 SIGHUP。</li><li><code>-a</code>：移除所有作业。<br><strong>场景</strong>：</li><li>防止后台进程因终端关闭而终止。</li><li>清理 shell 作业表。<br><strong>示例</strong>：</li><li><code>sleep 1000 &amp;</code> 后：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disown %1</span><br></pre></td></tr></table></figure>移除作业 ID 1，终端关闭后继续运行。</li><li><code>disown -a</code>：移除所有后台作业。<br><strong>高级用法</strong>：</li><li>结合 <code>nohup</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup sleep 1000 &amp; disown</span><br></pre></td></tr></table></figure>确保进程完全独立。<br><strong>注意</strong>：</li><li><code>disown</code> 不重定向输出，建议结合 <code>&gt; file</code>。</li></ul><h4 id="5.-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B" tabindex="-1">5. 使用场景与示例</h4><p>以下是进程管理命令在实际任务中的应用：</p><ol><li><p><strong>监控高负载进程</strong>：</p><ul><li>查找占用 CPU 最高的进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top</span><br><span class="line"># 按 P 排序，或：</span><br><span class="line">ps -eo pid,comm,%cpu --sort=-%cpu | head</span><br></pre></td></tr></table></figure></li><li>使用 <code>htop</code> 筛选：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop -s PERCENT_CPU</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>终止无响应进程</strong>：</p><ul><li>查找并终止 Firefox：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pgrep firefox</span><br><span class="line">killall firefox</span><br></pre></td></tr></table></figure></li><li>强制终止：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -9 -f firefox</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>管理后台任务</strong>：</p><ul><li>运行长时间备份：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup tar -czf backup.tar.gz /data &gt; backup.log 2&gt;&amp;1 &amp;</span><br><span class="line">disown</span><br></pre></td></tr></table></figure></li><li>检查后台进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br><span class="line">ps aux | grep tar</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>调整进程优先级</strong>：</p><ul><li>降低编译任务优先级：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nice -n 15 make</span><br></pre></td></tr></table></figure></li><li>提高数据库进程优先级：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo renice -10 -p $(pgrep mysqld)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>分析进程树</strong>：</p><ul><li>查看 Nginx 进程结构：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pstree -a -p nginx</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="6.-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" tabindex="-1">6. 高级用法</h4><ul><li><p><strong>自动化进程管理</strong>：</p><ul><li>脚本监控进程并重启：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="keyword">if</span> ! pgrep -f <span class="string">&quot;myapp&quot;</span> &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">nohup</span> /path/to/myapp &amp;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Restarted myapp&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>保存为 <code>monitor.sh</code>，用 <code>crontab</code> 定时运行。</li></ul></li><li><p><strong>实时监控</strong>：</p><ul><li>使用 <code>watch</code> 动态查看：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &#x27;ps -eo pid,comm,%cpu --sort=-%cpu | head -5&#x27;</span><br></pre></td></tr></table></figure>每秒显示 CPU 使用最高的 5 个进程。</li></ul></li><li><p><strong>进程信号处理</strong>：</p><ul><li>优雅重启服务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -HUP $(pgrep nginx)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>结合 <code>systemd</code></strong>：</p><ul><li>管理服务进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart apache2</span><br><span class="line">systemctl status apache2</span><br></pre></td></tr></table></figure>查看服务状态和日志。</li></ul></li></ul><h4 id="7.-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%89%A9%E5%B1%95" tabindex="-1">7. 注意事项与扩展</h4><ol><li><strong>安全提示</strong>：<ul><li>避免随意使用 <code>kill -9</code>，可能导致数据丢失或系统不稳定。</li><li>终止系统进程（如 <code>init</code> 或 <code>systemd</code>）需谨慎。</li><li>修改优先级或终止其他用户进程需 <code>sudo</code>。</li></ul></li><li><strong>性能优化</strong>：<ul><li>大量进程时，使用 <code>pgrep</code> 或 <code>htop</code> 替代 <code>ps aux | grep</code>。</li><li>实时监控大文件日志可能影响性能，建议用 <code>tail -f</code> 结合 <code>grep</code>。</li></ul></li><li><strong>相关工具</strong>：<ul><li><strong>systemctl</strong>：管理 systemd 服务进程。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop nginx</span><br></pre></td></tr></table></figure></li><li><strong>lsof</strong>：查看进程打开的文件。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 1234</span><br></pre></td></tr></table></figure></li><li><strong>strace</strong>：跟踪进程系统调用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strace -p 1234</span><br></pre></td></tr></table></figure></li><li><strong>pidstat</strong>（需安装 <code>sysstat</code>）：监控进程资源使用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pidstat -p 1234 1</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>学习资源</strong>：<ul><li>查看手册：<code>man ps</code>, <code>man kill</code>, <code>man htop</code>。</li><li>安装 <code>tldr</code>（<code>sudo apt install tldr</code>）获取简明示例。</li><li>在线教程：如 Ubuntu 社区文档或 DigitalOcean 的进程管理指南。</li></ul></li><li><strong>高级替代工具</strong>：<ul><li><strong>btop</strong>：更现代化的 <code>htop</code> 替代（需安装）。</li><li><strong>glances</strong>：系统监控工具，包含进程管理。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install glances</span><br><span class="line">glances</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="5.-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%92%8C%E7%9B%91%E6%8E%A7%EF%BC%88system-information%EF%BC%89" tabindex="-1">5. 系统信息和监控（System Information）</h2><p>系统信息和监控是 Ubuntu/Linux 系统中用于了解系统状态、硬件配置、资源使用和性能瓶颈的关键任务。这些命令帮助管理员和用户诊断问题、优化性能并确保系统稳定。以下按功能分类讲解相关命令，涵盖硬件信息、系统状态、资源监控和日志分析。</p><h4 id="1.-%E7%B3%BB%E7%BB%9F%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF" tabindex="-1">1. 系统硬件信息</h4><p>这些命令用于查看 CPU、内存、磁盘、设备等硬件信息。</p><h5 id="1.1-lscpu" tabindex="-1">1.1 lscpu</h5><p><strong>功能</strong>：显示 CPU 架构和详细信息，如核心数、频率、架构等。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-p</code>：以机器可读格式输出（适合脚本）。</li><li><code>-e</code>：显示扩展信息（如每核状态）。</li><li><code>-c</code>：仅显示在线 CPU。<br><strong>场景</strong>：</li><li>检查 CPU 核心数和虚拟化支持。</li><li>分析多核系统性能。<br><strong>示例</strong>：</li><li><code>lscpu</code>：显示 CPU 详细信息。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Architecture:        x86_64</span><br><span class="line">CPU(s):              8</span><br><span class="line">Thread(s) per core:  2</span><br><span class="line">Core(s) per socket:  4</span><br><span class="line">Vendor ID:           GenuineIntel</span><br><span class="line">Model name:          Intel(R) Core(TM) i7-9700</span><br></pre></td></tr></table></figure></li><li><code>lscpu -p</code>：输出机器可读格式，适合脚本解析。</li><li><code>lscpu -e</code>：显示每核详细信息。<br><strong>高级用法</strong>：</li><li>检查虚拟化支持：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep Virtualization</span><br></pre></td></tr></table></figure></li><li>统计 CPU 核心：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu | grep &quot;^CPU(s):&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>输出依赖于 <code>/proc/cpuinfo</code>，确保权限正常。</li><li>虚拟机中可能显示虚拟 CPU 而非物理 CPU。</li></ul><h5 id="1.2-lsmem" tabindex="-1">1.2 lsmem</h5><p><strong>功能</strong>：显示系统内存信息，包括总量、可用量和内存块状态。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmem [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-s</code>：以人类可读格式显示（如 MB、GB）。</li><li><code>-a</code>：显示所有内存块（包括离线）。<br><strong>场景</strong>：</li><li>检查内存分配和 NUMA 架构。</li><li>诊断内存不足问题。<br><strong>示例</strong>：</li><li><code>lsmem</code>：显示内存状态。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RANGE                                 SIZE  STATE REMOVABLE  BLOCK</span><br><span class="line">0x0000000000000000-0x00000000ffffffff  4G online       yes   0-31</span><br><span class="line">Total online memory:  4G</span><br></pre></td></tr></table></figure></li><li><code>lsmem -s</code>：以 GB 显示内存信息。<br><strong>高级用法</strong>：</li><li>结合 <code>free</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsmem | grep &quot;Total online&quot; &amp;&amp; free -h</span><br></pre></td></tr></table></figure>对比内存总量和使用情况。<br><strong>注意</strong>：</li><li>需要 <code>util-linux</code> 包支持（默认安装）。</li><li>NUMA 系统可能显示复杂内存分布。</li></ul><h5 id="1.3-lsblk" tabindex="-1">1.3 lsblk</h5><p><strong>功能</strong>：列出块设备（如硬盘、SSD、USB）及其分区信息。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-a</code>：显示所有设备（包括空设备）。</li><li><code>-f</code>：显示文件系统类型（如 ext4、ntfs）。</li><li><code>-o 字段</code>：自定义输出（如 <code>NAME,SIZE,FSTYPE</code>）。</li><li><code>-p</code>：显示完整设备路径（如 <code>/dev/sda</code>）。<br><strong>场景</strong>：</li><li>检查磁盘分区和挂载点。</li><li>识别新插入的存储设备。<br><strong>示例</strong>：</li><li><code>lsblk</code>：列出所有块设备。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda      8:0    0  500G  0 disk</span><br><span class="line">├─sda1   8:1    0  100G  0 part /boot</span><br><span class="line">└─sda2   8:2    0  400G  0 part /</span><br></pre></td></tr></table></figure></li><li><code>lsblk -f</code>：显示文件系统和挂载点。</li><li><code>lsblk -o NAME,SIZE,TYPE</code>：仅显示设备名、大小和类型。<br><strong>高级用法</strong>：</li><li>筛选未挂载分区：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -f | grep -v &quot;[SWAP]\|/&quot;</span><br></pre></td></tr></table></figure></li><li>检查 USB 设备：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk -p | grep /dev/sd[b-z]</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 查看某些受限设备。</li><li>配合 <code>fdisk</code> 或 <code>parted</code> 管理分区。</li></ul><h5 id="1.4-lshw" tabindex="-1">1.4 lshw</h5><p><strong>功能</strong>：列出系统硬件详细信息，包括 CPU、内存、磁盘、网络等（需安装 <code>sudo apt install lshw</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lshw [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-C 类</code>：显示特定硬件类别（如 <code>cpu</code>、<code>memory</code>、<code>disk</code>）。</li><li><code>-short</code>：简洁输出。</li><li><code>-html</code>：输出 HTML 格式。<br><strong>场景</strong>：</li><li>收集硬件清单（如服务器审计）。</li><li>诊断硬件兼容性问题。<br><strong>示例</strong>：</li><li><code>sudo lshw</code>：显示完整硬件信息。</li><li><code>sudo lshw -C cpu</code>：显示 CPU 详情。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">*-cpu</span><br><span class="line">     description: CPU</span><br><span class="line">     product: Intel(R) Core(TM) i7-9700</span><br><span class="line">     vendor: Intel Corp.</span><br><span class="line">     physical id: 4</span><br><span class="line">     bus info: cpu@0</span><br><span class="line">     size: 3600MHz</span><br><span class="line">     capacity: 4600MHz</span><br></pre></td></tr></table></figure></li><li><code>sudo lshw -short</code>：简洁硬件概览。<br><strong>高级用法</strong>：</li><li>输出到文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lshw -html &gt; hardware.html</span><br></pre></td></tr></table></figure></li><li>筛选网络设备：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lshw -C network</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 获取完整信息。</li><li>输出较详细，建议结合 <code>grep</code> 或 <code>less</code>。</li></ul><h5 id="1.5-dmidecode" tabindex="-1">1.5 dmidecode</h5><p><strong>功能</strong>：读取 DMI/SMBIOS 信息，显示硬件细节（如 BIOS、主板、内存）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmidecode [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-t 类型</code>：指定类型（如 <code>bios</code>、<code>memory</code>、<code>processor</code>）。</li><li><code>-s 关键字</code>：提取特定字段（如 <code>bios-version</code>）。<br><strong>场景</strong>：</li><li>检查 BIOS 版本或硬件序列号。</li><li>验证服务器硬件规格。<br><strong>示例</strong>：</li><li><code>sudo dmidecode -t processor</code>：显示 CPU 信息。</li><li><code>sudo dmidecode -s bios-version</code>：显示 BIOS 版本。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.2.3</span><br></pre></td></tr></table></figure></li><li><code>sudo dmidecode -t memory</code>：显示内存条信息。<br><strong>高级用法</strong>：</li><li>提取主板信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode -t baseboard</span><br></pre></td></tr></table></figure></li><li>结合脚本：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dmidecode -s system-serial-number &gt; serial.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 访问硬件信息。</li><li>某些虚拟机可能无法获取完整 DMI 数据。</li></ul><h4 id="2.-%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E7%9B%91%E6%8E%A7" tabindex="-1">2. 系统资源监控</h4><p>这些命令用于监控 CPU、内存、磁盘和网络的实时使用情况。</p><h5 id="2.1-free" tabindex="-1">2.1 free</h5><p><strong>功能</strong>：显示系统内存和交换空间的使用情况。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-h</code>：人类可读格式（如 GB、MB）。</li><li><code>-s 秒</code>：每隔几秒刷新。</li><li><code>-m</code>：以 MB 显示。</li><li><code>-t</code>：显示总计行。<br><strong>场景</strong>：</li><li>检查可用内存。</li><li>诊断内存泄漏或高负载。<br><strong>示例</strong>：</li><li><code>free -h</code>：显示内存使用情况。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">     total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:   7.8Gi       2.5Gi       3.2Gi       0.1Gi       2.0Gi       5.0Gi</span><br><span class="line">Swap:  2.0Gi       0.0Gi       2.0Gi</span><br></pre></td></tr></table></figure></li><li><code>free -s 2</code>：每 2 秒刷新内存状态。</li><li><code>free -mt</code>：以 MB 显示并包含总计。<br><strong>高级用法</strong>：</li><li>结合 <code>watch</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 free -h</span><br></pre></td></tr></table></figure>每秒刷新内存状态。</li><li>检查低内存：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -h | grep Mem | awk &#x27;&#123;print $7&#125;&#x27;  # 输出 available 内存</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>available</code> 比 <code>free</code> 更准确反映可用内存。</li><li>高 <code>buff/cache</code> 通常正常（Linux 缓存机制）。</li></ul><h5 id="2.2-vmstat" tabindex="-1">2.2 vmstat</h5><p><strong>功能</strong>：报告虚拟内存、进程、CPU 和 I/O 统计信息。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat [选项] [间隔 [次数]]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-s</code>：显示详细统计表。</li><li><code>-m</code>：显示内存 slab 信息。</li><li><code>-d</code>：显示磁盘统计。</li><li><code>-t</code>：添加时间戳。<br><strong>场景</strong>：</li><li>监控内存交换和 CPU 活动。</li><li>分析 I/O 瓶颈。<br><strong>示例</strong>：</li><li><code>vmstat 2</code>：每 2 秒刷新统计。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 3200000 200000 1800000   0    0     0     0  100  200 10  5 85  0  0</span><br></pre></td></tr></table></figure></li><li><code>vmstat -s</code>：显示内存统计表。</li><li><code>vmstat -d</code>：显示磁盘读写统计。<br><strong>高级用法</strong>：</li><li>监控 I/O 瓶颈：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat -t 1 | grep -v procs</span><br></pre></td></tr></table></figure>每秒显示带时间戳的统计。<br><strong>注意</strong>：</li><li><code>si/so</code>（swap in/out）高表示内存压力，可能需增加 RAM。</li><li>需要结合其他工具（如 <code>iostat</code>）分析具体问题。</li></ul><h5 id="2.3-iostat" tabindex="-1">2.3 iostat</h5><p><strong>功能</strong>：报告 CPU 和 I/O（磁盘、网络）统计信息（需安装 <code>sudo apt install sysstat</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [选项] [间隔 [次数]]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-c</code>：仅显示 CPU 统计。</li><li><code>-d</code>：仅显示磁盘统计。</li><li><code>-x</code>：显示扩展统计（如设备利用率）。</li><li><code>-h</code>：人类可读格式。<br><strong>场景</strong>：</li><li>分析磁盘读写性能。</li><li>检查 CPU 负载分布。<br><strong>示例</strong>：</li><li><code>iostat</code>：显示 CPU 和磁盘概览。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">          10.00    0.00    5.00    0.10    0.00   84.90</span><br><span class="line">Device    tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda       5.00      100.00       50.00     100000      50000</span><br></pre></td></tr></table></figure></li><li><code>iostat -x 2</code>：每 2 秒显示扩展磁盘统计。</li><li><code>iostat -c</code>：仅显示 CPU 统计。<br><strong>高级用法</strong>：</li><li>监控特定设备：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x /dev/sda 1</span><br></pre></td></tr></table></figure></li><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x | grep sda</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sysstat</code> 包支持。</li><li>高 <code>%iowait</code> 表示磁盘 I/O 瓶颈。</li></ul><h5 id="2.4-top" tabindex="-1">2.4 top</h5><p><strong>功能</strong>：实时显示系统进程状态、CPU 和内存使用情况（已在进程管理中介绍，此处侧重系统监控）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-d 秒</code>：设置刷新间隔。</li><li><code>-b</code>：批处理模式（输出到文件）。</li><li><code>-n 次数</code>：运行指定次数后退出。<br><strong>场景</strong>：</li><li>实时监控系统负载。</li><li>识别高资源占用进程。<br><strong>示例</strong>：</li><li><code>top</code>：启动实时监控。</li><li><code>top -b -n 1 &gt; top_output.txt</code>：保存一次快照。<br><strong>高级用法</strong>：</li><li>筛选用户进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top -u user1</span><br></pre></td></tr></table></figure></li><li>动态调整显示：<ul><li>按 <code>f</code> 进入字段管理，添加 <code>%CPU</code> 或 <code>MEM</code> 列。<br><strong>注意</strong>：</li></ul></li><li>按 <code>1</code> 显示每个 CPU 核心的负载。</li><li>适合交互式监控，脚本中建议用 <code>vmstat</code> 或 <code>iostat</code>。</li></ul><h5 id="2.5-htop" tabindex="-1">2.5 htop</h5><p><strong>功能</strong>：增强版 <code>top</code>，提供彩色界面和交互式监控（需安装 <code>sudo apt install htop</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-d 秒</code>：设置刷新间隔。</li><li><code>-s 列</code>：按指定列排序（如 <code>CPU</code>、<code>MEM</code>）。<br><strong>场景</strong>：</li><li>直观查看系统资源使用。</li><li>快速调整进程优先级或终止进程。<br><strong>示例</strong>：</li><li><code>htop</code>：启动交互界面。</li><li><code>htop -s PERCENT_CPU</code>：按 CPU 使用率排序。<br><strong>高级用法</strong>：</li><li>过滤进程：<ul><li>按 <code>F3</code> 输入关键字（如 “apache”）。</li></ul></li><li>导出数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htop --tree &gt; htop_output.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>比 <code>top</code> 更直观，支持鼠标操作。</li><li>建议安装以替换 <code>top</code>。</li></ul><h4 id="3.-%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7" tabindex="-1">3. 磁盘与文件系统监控</h4><p>这些命令用于检查磁盘使用量和文件系统状态。</p><h5 id="3.1-df" tabindex="-1">3.1 df</h5><p><strong>功能</strong>：显示文件系统的磁盘使用情况。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [文件系统]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-h</code>：人类可读格式（如 GB、MB）。</li><li><code>-T</code>：显示文件系统类型（如 ext4）。</li><li><code>-i</code>：显示 inode 使用情况。</li><li><code>--output=字段</code>：自定义输出（如 <code>source,fstype,used,avail</code>）。<br><strong>场景</strong>：</li><li>检查磁盘剩余空间。</li><li>验证挂载点状态。<br><strong>示例</strong>：</li><li><code>df -h</code>：显示磁盘使用情况。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda2       400G  200G  180G  53% /</span><br><span class="line">/dev/sda1       100G   10G   90G  10% /boot</span><br></pre></td></tr></table></figure></li><li><code>df -T /home</code>：显示 <code>/home</code> 的文件系统类型。</li><li><code>df -i</code>：检查 inode 使用情况。<br><strong>高级用法</strong>：</li><li>筛选特定挂载点：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h --output=source,avail / | grep /dev</span><br></pre></td></tr></table></figure></li><li>监控磁盘满载：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 5 &#x27;df -h /&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>inode 耗尽可能导致无法创建新文件，即使磁盘有空间。</li><li>需 <code>sudo</code> 查看某些受限文件系统。</li></ul><h5 id="3.2-du" tabindex="-1">3.2 du</h5><p><strong>功能</strong>：计算目录或文件的磁盘使用量。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [路径]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-h</code>：人类可读格式。</li><li><code>-s</code>：汇总目录总大小。</li><li><code>-c</code>：显示总计。</li><li><code>--max-depth=N</code>：限制目录深度。<br><strong>场景</strong>：</li><li>查找占用磁盘空间大的目录。</li><li>清理无用文件。<br><strong>示例</strong>：</li><li><code>du -sh /home/user</code>：显示用户家目录总大小。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.5G /home/user</span><br></pre></td></tr></table></figure></li><li><code>du -h --max-depth=1 /var</code>：显示 <code>/var</code> 下子目录大小。</li><li><code>du -hc *.log</code>：统计当前目录下 <code>.log</code> 文件的总大小。<br><strong>高级用法</strong>：</li><li>排序大文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h /var | sort -hr | head -n 10</span><br></pre></td></tr></table></figure>显示 <code>/var</code> 下占用空间最大的 10 个目录。</li><li>结合 <code>find</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -type d -exec du -sh &#123;&#125; \; | sort -hr</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>递归扫描可能较慢，建议指定路径。</li><li>需 <code>sudo</code> 访问受限目录。</li></ul><h4 id="4.-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7" tabindex="-1">4. 网络监控</h4><p>这些 commands monitor network interfaces and traffic.</p><h5 id="4.1-ifconfig%EF%BC%88%E6%88%96-ip%EF%BC%89" tabindex="-1">4.1 ifconfig（或 ip）</h5><p><strong>功能</strong>：显示和配置网络接口信息（<code>ifconfig</code> 可能需安装 <code>sudo apt install net-tools</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [接口]</span><br><span class="line">ip addr</span><br></pre></td></tr></table></figure><p><strong>常用选项（ifconfig）</strong>：</p><ul><li><code>-a</code>：显示所有接口（包括未激活的）。<br><strong>常用选项（ip）</strong>：</li><li><code>ip addr show</code>：显示网络接口。</li><li><code>ip -s link</code>：显示接口统计。<br><strong>场景</strong>：</li><li>检查网络接口的 IP 地址和状态。</li><li>诊断网络连接问题。<br><strong>示例</strong>：</li><li><code>ifconfig</code>：显示活动接口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">      inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255</span><br></pre></td></tr></table></figure></li><li><code>ip addr</code>：显示所有接口信息。</li><li><code>ip -s link</code>：显示接口流量统计。<br><strong>高级用法</strong>：</li><li>筛选特定接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show eth0</span><br></pre></td></tr></table></figure></li><li>监控流量：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &#x27;ip -s link&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>ip</code> 是现代替代工具，<code>ifconfig</code> 可能在某些系统上不可用。</li><li>需要 <code>sudo</code> 配置接口。</li></ul><h5 id="4.2-netstat%EF%BC%88%E9%9C%80%E5%AE%89%E8%A3%85-sudo-apt-install-net-tools%EF%BC%89" tabindex="-1">4.2 netstat（需安装 <code>sudo apt install net-tools</code>）</h5><p><strong>功能</strong>：显示网络连接、路由表和接口统计。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-a</code>：显示所有连接（包括监听）。</li><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-p</code>：显示关联进程。</li><li><code>-n</code>：显示数字地址（不解析 DNS）。<br><strong>场景</strong>：</li><li>检查开放端口和连接状态。</li><li>识别网络服务进程。<br><strong>示例</strong>：</li><li><code>netstat -tuln</code>：显示监听的 TCP/UDP 端口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure></li><li><code>netstat -ap</code>：显示连接和关联进程。<br><strong>高级用法</strong>：</li><li>筛选特定端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep :80</span><br></pre></td></tr></table></figure></li><li>统计连接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>netstat</code> 被 <code>ss</code> 替代，推荐使用 <code>ss</code>。</li><li>需要 <code>sudo</code> 查看某些连接。</li></ul><h5 id="4.3-ss" tabindex="-1">4.3 ss</h5><p><strong>功能</strong>：现代网络连接查看工具，替代 <code>netstat</code>，更高效。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：显示监听端口。</li><li><code>-p</code>：显示关联进程。</li><li><code>-n</code>：不解析地址/端口。<br><strong>场景</strong>：</li><li>检查服务器开放端口。</li><li>监控网络连接状态。<br><strong>示例</strong>：</li><li><code>ss -tuln</code>：显示监听的 TCP/UDP 端口。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netid  State      Recv-Q Send-Q  Local Address:Port   Peer Address:Port</span><br><span class="line">tcp    LISTEN     0      128     0.0.0.0:22           0.0.0.0:*</span><br></pre></td></tr></table></figure></li><li><code>ss -tp</code>：显示 TCP 连接和进程。<br><strong>高级用法</strong>：</li><li>筛选特定端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln | grep :80</span><br></pre></td></tr></table></figure></li><li>监控活跃连接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &#x27;ss -tn state established&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>比 <code>netstat</code> 更快，适合现代系统。</li><li>需要 <code>sudo</code> 查看详细进程信息。</li></ul><h4 id="5.-%E6%97%A5%E5%BF%97%E4%B8%8E%E7%B3%BB%E7%BB%9F%E4%BA%8B%E4%BB%B6%E7%9B%91%E6%8E%A7" tabindex="-1">5. 日志与系统事件监控</h4><p>这些命令用于查看系统日志和事件，诊断问题。</p><h5 id="5.1-journalctl" tabindex="-1">5.1 journalctl</h5><p><strong>功能</strong>：查看 systemd 日志，包含系统和服务日志。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-u 服务</code>：显示指定服务日志（如 <code>systemd-networkd</code>）。</li><li><code>-b</code>：显示当前启动的日志。</li><li><code>-f</code>：实时监控日志（类似 <code>tail -f</code>）。</li><li><code>-p 优先级</code>：过滤日志级别（如 <code>3</code> 表示错误）。</li><li><code>-n 行数</code>：显示最后指定行数。<br><strong>场景</strong>：</li><li>排查系统启动或服务错误。</li><li>实时监控系统事件。<br><strong>示例</strong>：</li><li><code>journalctl -b</code>：显示当前启动的日志。</li><li><code>journalctl -u sshd</code>：显示 SSH 服务日志。</li><li><code>journalctl -f</code>：实时监控系统日志。</li><li><code>journalctl -p 3</code>：显示错误级别日志。<br><strong>高级用法</strong>：</li><li>筛选时间范围：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since &quot;2025-09-14 14:00&quot; --until &quot;2025-09-14 15:00&quot;</span><br></pre></td></tr></table></figure></li><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u apache2 | grep &quot;error&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 查看某些系统日志。</li><li>日志可能占用大量空间，定期清理（<code>sudo journalctl --vacuum-time=7d</code>）。</li></ul><h5 id="5.2-dmesg" tabindex="-1">5.2 dmesg</h5><p><strong>功能</strong>：显示内核环形缓冲区的日志，包含硬件和驱动信息。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-T</code>：显示人类可读时间。</li><li><code>-L</code>：彩色输出。</li><li><code>-w</code>：实时监控（类似 <code>tail -f</code>）。</li><li><code>-l 级别</code>：过滤日志级别（如 <code>err</code>、<code>warn</code>）。<br><strong>场景</strong>：</li><li>诊断硬件问题（如 USB 设备失败）。</li><li>检查内核启动消息。<br><strong>示例</strong>：</li><li><code>dmesg</code>：显示所有内核日志。</li><li><code>dmesg -T | grep usb</code>：显示 USB 相关日志，带时间戳。</li><li><code>dmesg -w</code>：实时监控内核日志。</li><li><code>dmesg -l err</code>：显示错误级别日志。<br><strong>高级用法</strong>：</li><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg | grep -i &quot;error\|fail&quot;</span><br></pre></td></tr></table></figure></li><li>导出日志：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dmesg &gt; kernel.log</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 查看某些受限日志。</li><li>缓冲区有限，老日志可能被覆盖。</li></ul><h4 id="6.-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B" tabindex="-1">6. 使用场景与示例</h4><p>以下是系统信息和监控命令在实际任务中的应用：</p><ol><li><p><strong>检查系统硬件配置</strong>：</p><ul><li>获取 CPU 和内存信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lscpu &amp;&amp; free -h</span><br></pre></td></tr></table></figure></li><li>收集完整硬件清单：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lshw -short &gt; hardware.txt</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>监控系统性能</strong>：</p><ul><li>实时查看 CPU 和内存：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">htop</span><br><span class="line"># 或</span><br><span class="line">watch -n 1 &#x27;vmstat -t 1 2&#x27;</span><br></pre></td></tr></table></figure></li><li>检查磁盘 I/O 瓶颈：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -x 1</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>诊断磁盘空间问题</strong>：</p><ul><li>检查磁盘使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></li><li>查找大目录：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h /var | sort -hr | head -n 10</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>网络问题排查</strong>：</p><ul><li>检查开放端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure></li><li>监控网络流量：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &#x27;ip -s link&#x27;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>分析系统日志</strong>：</p><ul><li>查看最近错误：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -p 3 -b</span><br></pre></td></tr></table></figure></li><li>实时监控服务：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -u nginx -f</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="7.-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" tabindex="-1">7. 高级用法</h4><ul><li><p><strong>自动化监控脚本</strong>：</p><ul><li>监控内存并报警：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">THRESHOLD=10</span><br><span class="line">AVAIL=$(free -m | grep Mem | awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$AVAIL</span> -lt <span class="variable">$THRESHOLD</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Low memory: <span class="variable">$AVAIL</span> MB&quot;</span> | mail -s <span class="string">&quot;Memory Alert&quot;</span> admin@example.com</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>保存为 <code>monitor_memory.sh</code>，用 <code>crontab</code> 定时运行。</li></ul></li><li><p><strong>实时性能仪表板</strong>：</p><ul><li>使用 <code>glances</code>（需安装 <code>sudo apt install glances</code>）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glances</span><br></pre></td></tr></table></figure>提供 CPU、内存、磁盘、网络的综合监控。</li></ul></li><li><p><strong>日志分析</strong>：</p><ul><li>提取特定时间段的错误：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl --since &quot;2025-09-14 14:00&quot; -p 3 | grep &quot;error&quot;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>硬件故障检测</strong>：</p><ul><li>检查磁盘健康（需安装 <code>smartmontools</code>）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install smartmontools</span><br><span class="line">sudo smartctl -a /dev/sda</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="8.-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%89%A9%E5%B1%95" tabindex="-1">8. 注意事项与扩展</h4><ol><li><strong>安全提示</strong>：<ul><li>查看系统信息（如 <code>lshw</code>、<code>dmidecode</code>）或日志（<code>journalctl</code>）通常需要 <code>sudo</code>。</li><li>定期清理日志（<code>sudo journalctl --vacuum-size=100M</code>）以释放空间。</li></ul></li><li><strong>性能优化</strong>：<ul><li>监控大日志文件时，结合 <code>grep</code> 或 <code>tail</code> 减少输出。</li><li>使用 <code>watch</code> 或 <code>htop</code> 替代频繁运行 <code>top</code>。</li></ul></li><li><strong>相关工具</strong>：<ul><li><strong>glances</strong>：综合系统监控工具。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install glances</span><br><span class="line">glances</span><br></pre></td></tr></table></figure></li><li><strong>nmon</strong>：性能监控工具（需安装）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nmon</span><br><span class="line">nmon</span><br></pre></td></tr></table></figure></li><li><strong>iotop</strong>：监控进程 I/O（需安装）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install iotop</span><br><span class="line">sudo iotop</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="6.-%E5%8C%85%E7%AE%A1%E7%90%86%EF%BC%88package-management%EF%BC%89---ubuntu-%E4%B8%93%E5%B1%9E-apt" tabindex="-1">6. 包管理（Package Management） - Ubuntu 专属 APT</h2><p>以下是对 Ubuntu 中 <strong>包管理（Package Management）</strong> 工具 <strong>APT</strong>（Advanced Package Tool）的详细讲解，涵盖其功能、语法、常用命令、选项、实际使用场景、高级用法和示例。内容基于 Ubuntu 22.04/24.04 环境，参考了 Ubuntu 官方文档、man 页、DigitalOcean 和 ItsFOSS 等权威来源，确保全面、深入且易于理解。讲解采用清晰的列表格式，包含丰富细节，结合实际场景和注意事项，专注于 Ubuntu 的 APT 系统（包括 <code>apt</code>, <code>apt-get</code>, <code>apt-cache</code> 等工具）。当前时间为 2025 年 9 月 14 日下午 3:03（JST）。</p><hr><p><strong>APT</strong> 是 Ubuntu 的默认包管理工具，用于安装、更新、移除和管理软件包及其依赖。它通过与软件源（repositories）交互，从在线存储库或本地缓存获取 <code>.deb</code> 格式的软件包。APT 包括几个核心命令（如 <code>apt</code>, <code>apt-get</code>, <code>apt-cache</code>），其中 <code>apt</code> 是现代用户友好的前端，而 <code>apt-get</code> 和 <code>apt-cache</code> 提供更细粒度的控制。以下详细讲解 APT 的功能、命令和使用方法。</p><h4 id="1.-apt-%E6%A6%82%E8%BF%B0" tabindex="-1">1. APT 概述</h4><ul><li><strong>功能</strong>：<ul><li>安装、更新、移除软件包。</li><li>管理依赖关系，自动解决冲突。</li><li>配置和更新软件源。</li><li>查询包信息和搜索软件。</li></ul></li><li><strong>核心组件</strong>：<ul><li><strong>apt</strong>: 用户友好的前端，结合 <code>apt-get</code> 和 <code>apt-cache</code> 的常用功能，推荐日常使用。</li><li><strong>apt-get</strong>: 功能全面的底层工具，适合脚本和高级操作。</li><li><strong>apt-cache</strong>: 查询包信息和依赖。</li><li><strong>dpkg</strong>: 低级工具，直接操作 <code>.deb</code> 文件（通常由 APT 调用）。</li></ul></li><li><strong>软件源</strong>：<ul><li>配置文件：<code>/etc/apt/sources.list</code> 和 <code>/etc/apt/sources.list.d/*.list</code>。</li><li>源类型：<code>main</code>（官方支持）、<code>universe</code>（社区维护）、<code>restricted</code>（专有驱动）、<code>multiverse</code>（非自由软件）。</li><li>典型源格式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deb http://archive.ubuntu.com/ubuntu jammy main universe</span><br></pre></td></tr></table></figure><ul><li><code>deb</code>: 二进制包。</li><li><code>http://...</code>: 源 URL。</li><li><code>jammy</code>: 发行版代号（如 Ubuntu 22.04）。</li><li><code>main universe</code>: 组件。</li></ul></li></ul></li><li><strong>缓存</strong>：APT 将下载的包和元数据存储在 <code>/var/cache/apt</code> 和 <code>/var/lib/apt</code>。</li></ul><h4 id="2.-%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4%E4%B8%8E%E8%AF%AD%E6%B3%95" tabindex="-1">2. 核心命令与语法</h4><h5 id="2.1-apt" tabindex="-1">2.1 apt</h5><p><strong>功能</strong>：用户友好的命令行工具，整合 <code>apt-get</code> 和 <code>apt-cache</code> 的常用功能，提供进度条和彩色输出。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt [选项] 命令 [包名...]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong>：</p><ul><li><code>update</code>: 更新软件源的包索引。</li><li><code>upgrade</code>: 升级所有已安装的包到最新版本。</li><li><code>full-upgrade</code>: 升级包，允许移除或安装新依赖（更激进）。</li><li><code>install 包名</code>: 安装指定包及其依赖。</li><li><code>remove 包名</code>: 删除包，保留配置文件。</li><li><code>purge 包名</code>: 删除包及其配置文件。</li><li><code>autoremove</code>: 移除不再需要的依赖包。</li><li><code>search 关键字</code>: 搜索包名或描述。</li><li><code>show 包名</code>: 显示包的详细信息。</li><li><code>list</code>: 列出包状态（如已安装、可升级）。<br><strong>常用选项</strong>：</li><li><code>-y</code>: 自动确认（适合脚本）。</li><li><code>-s</code>: 模拟操作，不实际执行。</li><li><code>--no-install-recommends</code>: 仅安装必要依赖。</li><li><code>--allow-downgrades</code>: 允许降级安装。<br><strong>场景</strong>：</li><li>日常软件安装和更新。</li><li>查询可用包或检查系统状态。<br><strong>示例</strong>：</li><li>更新包索引：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>刷新 <code>/var/lib/apt/lists</code> 中的源数据。</li><li>升级所有包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>更新已安装的包到最新版本。</li><li>安装软件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure>安装 Vim 编辑器及其依赖。</li><li>删除软件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt remove nginx</span><br></pre></td></tr></table></figure>删除 Nginx，保留配置文件。</li><li>清理无用依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure></li><li>搜索包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search python3</span><br></pre></td></tr></table></figure>查找包含 “python3” 的包。</li><li>查看包信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt show htop</span><br></pre></td></tr></table></figure>显示 <code>htop</code> 的版本、描述等。</li><li>列出可升级包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt list --upgradable</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>模拟安装：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -s nginx</span><br></pre></td></tr></table></figure>显示安装过程但不执行。</li><li>安装特定版本：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3=3.10.6-1~22.04</span><br></pre></td></tr></table></figure></li><li>批量安装：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim htop curl -y</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>apt</code> 是用户交互工具，脚本中建议用 <code>apt-get</code>。</li><li>运行 <code>update</code> 前需确保网络连接和源配置正确。</li><li>需要 <code>sudo</code> 执行修改操作。</li></ul><h5 id="2.2-apt-get" tabindex="-1">2.2 apt-get</h5><p><strong>功能</strong>：功能全面的包管理工具，适合高级用户和脚本，提供比 <code>apt</code> 更细粒度的控制。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get [选项] 命令 [包名...]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong>（与 <code>apt</code> 重叠的部分略，重点补充独特功能）：</p><ul><li><code>dist-upgrade</code>: 升级系统，可能更改依赖结构（类似 <code>full-upgrade</code>）。</li><li><code>clean</code>: 清除已下载的包缓存（<code>/var/cache/apt/archives</code>）。</li><li><code>autoclean</code>: 清除过期的包缓存。</li><li><code>check</code>: 检查依赖是否完整。</li><li><code>source 包名</code>: 下载包的源代码。</li><li><code>build-dep 包名</code>: 安装包的编译依赖。<br><strong>常用选项</strong>：</li><li><code>-y</code>: 自动确认。</li><li><code>-q</code>: 安静模式，减少输出。</li><li><code>--reinstall</code>: 重新安装包。</li><li><code>--download-only</code>: 仅下载包不安装。<br><strong>场景</strong>：</li><li>系统升级或修复依赖。</li><li>清理缓存以释放磁盘空间。</li><li>开发者编译软件时获取源代码。<br><strong>示例</strong>：</li><li>清理缓存：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get clean</span><br></pre></td></tr></table></figure>删除 <code>/var/cache/apt/archives</code> 中的包。</li><li>检查依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get check</span><br></pre></td></tr></table></figure>验证系统依赖完整性。</li><li>下载源代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get source bash</span><br></pre></td></tr></table></figure>下载 Bash 的源代码。</li><li>安装编译依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get build-dep nginx</span><br></pre></td></tr></table></figure></li><li>重新安装包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --reinstall vim</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>下载但不安装：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --download-only nginx</span><br></pre></td></tr></table></figure>包保存在 <code>/var/cache/apt/archives</code>。</li><li>修复损坏依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure></li><li>系统大版本升级：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>dist-upgrade</code> 可能移除包，需谨慎。</li><li>确保 <code>/etc/apt/sources.list</code> 配置正确以避免错误。</li></ul><h5 id="2.3-apt-cache" tabindex="-1">2.3 apt-cache</h5><p><strong>功能</strong>：查询包信息、依赖和软件源数据，不执行安装或删除操作。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache [选项] 命令 [包名...]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong>：</p><ul><li><code>search 关键字</code>: 搜索包名或描述。</li><li><code>show 包名</code>: 显示包的详细信息。</li><li><code>depends 包名</code>: 显示包的依赖。</li><li><code>rdepends 包名</code>: 显示依赖此包的其他包。</li><li><code>pkgnames</code>: 列出所有可用包名。</li><li><code>policy 包名</code>: 显示包的版本和源优先级。<br><strong>常用选项</strong>：</li><li><code>-i</code>: 显示重要信息（如依赖）。</li><li><code>-p</code>: 显示所有版本的包。<br><strong>场景</strong>：</li><li>查询包的版本、依赖或来源。</li><li>排查依赖冲突。<br><strong>示例</strong>：</li><li>搜索包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache search webserver</span><br></pre></td></tr></table></figure>查找包含 “webserver” 的包。</li><li>查看包信息：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache show nginx</span><br></pre></td></tr></table></figure>显示 Nginx 的版本、描述等。</li><li>检查依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache depends python3</span><br></pre></td></tr></table></figure></li><li>查看反向依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache rdepends apache2</span><br></pre></td></tr></table></figure></li><li>显示源优先级：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy vim</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim:</span><br><span class="line">  Installed: 2:8.2.3995-1ubuntu2</span><br><span class="line">  Candidate: 2:8.2.3995-1ubuntu2</span><br><span class="line">  Version table:</span><br><span class="line"> *** 2:8.2.3995-1ubuntu2 500</span><br><span class="line">      500 http://archive.ubuntu.com/ubuntu jammy/main amd64 Packages</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>查找依赖链：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache depends --recurse python3</span><br></pre></td></tr></table></figure>显示 Python3 的完整依赖树。</li><li>列出所有包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache pkgnames | grep python</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>apt-cache</code> 不修改系统，仅查询。</li><li>需要先运行 <code>apt update</code> 确保索引最新。</li></ul><h5 id="2.4-dpkg" tabindex="-1">2.4 dpkg</h5><p><strong>功能</strong>：低级包管理工具，直接操作 <code>.deb</code> 文件，处理安装、移除和查询。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg [选项] 动作 [包名|.deb 文件]</span><br></pre></td></tr></table></figure><p><strong>常用动作</strong>：</p><ul><li><code>-i 文件</code>: 安装 <code>.deb</code> 文件。</li><li><code>-r 包名</code>: 删除包，保留配置文件。</li><li><code>-P 包名</code>: 删除包及其配置文件。</li><li><code>-l [模式]</code>: 列出已安装包。</li><li><code>-S 文件</code>: 查找包含指定文件的包。</li><li><code>-s 包名</code>: 显示包状态。<br><strong>常用选项</strong>：</li><li><code>--force-all</code>: 强制执行（如忽略依赖错误）。</li><li><code>--configure -a</code>: 配置所有未配置的包。<br><strong>场景</strong>：</li><li>安装本地 <code>.deb</code> 文件。</li><li>修复 APT 无法解决的包问题。</li><li>查询已安装包。<br><strong>示例</strong>：</li><li>安装本地包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br></pre></td></tr></table></figure></li><li>列出已安装包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep nginx</span><br></pre></td></tr></table></figure></li><li>查找文件所属包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -S /usr/bin/vim</span><br></pre></td></tr></table></figure></li><li>删除包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -r nginx</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>修复依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg -i package.deb</span><br><span class="line">sudo apt-get install -f</span><br></pre></td></tr></table></figure>安装 <code>.deb</code> 后修复依赖。</li><li>列出包文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -L nginx</span><br></pre></td></tr></table></figure>显示 Nginx 安装的文件列表。<br><strong>注意</strong>：</li><li><code>dpkg</code> 不自动处理依赖，需配合 <code>apt-get install -f</code>。</li><li>手动安装可能导致冲突，建议优先使用 <code>apt</code>。</li></ul><h4 id="3.-%E8%BD%AF%E4%BB%B6%E6%BA%90%E7%AE%A1%E7%90%86" tabindex="-1">3. 软件源管理</h4><p>软件源决定了 APT 从哪里获取包，配置文件位于 <code>/etc/apt/sources.list</code> 和 <code>/etc/apt/sources.list.d/</code>。</p><h5 id="3.1-add-apt-repository" tabindex="-1">3.1 add-apt-repository</h5><p><strong>功能</strong>：添加或移除 APT 软件源（如 PPA，Personal Package Archive）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add-apt-repository [选项] 源</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-r</code>: 移除指定源。</li><li><code>-y</code>: 自动确认。</li><li><code>-s</code>: 添加源代码源。<br><strong>场景</strong>：</li><li>添加第三方软件源（如最新版软件）。</li><li>启用 Ubuntu 的 universe 或 multiverse 源。<br><strong>示例</strong>：</li><li>添加 PPA：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">sudo apt update</span><br></pre></td></tr></table></figure>添加 Python 最新版本的 PPA。</li><li>启用 universe 源：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository universe</span><br></pre></td></tr></table></figure></li><li>移除源：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -r ppa:deadsnakes/ppa</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>添加源代码：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository -s ppa:deadsnakes/ppa</span><br></pre></td></tr></table></figure></li><li>手动编辑源：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br></pre></td></tr></table></figure>添加如 <code>deb http://archive.ubuntu.com/ubuntu jammy universe</code>.<br><strong>注意</strong>：</li><li>添加第三方 PPA 需谨慎，可能影响系统稳定性。</li><li>每次修改源后需运行 <code>sudo apt update</code>。</li></ul><h5 id="3.2-apt-key%EF%BC%88%E6%88%96-gpg%EF%BC%89" tabindex="-1">3.2 apt-key（或 gpg）</h5><p><strong>功能</strong>：管理 APT 软件源的 GPG 密钥，确保包来源可信（Ubuntu 22.04 后推荐用 <code>/etc/apt/trusted.gpg.d</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key [命令]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong>：</p><ul><li><code>add 文件</code>: 添加 GPG 密钥。</li><li><code>list</code>: 列出已导入的密钥。</li><li><code>del 密钥ID</code>: 删除指定密钥。<br><strong>场景</strong>：</li><li>验证第三方源的安全性。</li><li>修复源签名错误。<br><strong>示例</strong>：</li><li>添加 GPG 密钥：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://example.com/key.asc | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li>列出密钥：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key list</span><br></pre></td></tr></table></figure></li><li>新方式（推荐）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO - https://example.com/key.asc | sudo tee /etc/apt/trusted.gpg.d/example.asc</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>验证签名：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-key verify package.deb</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>apt-key</code> 在 Ubuntu 22.04 后已废弃，推荐使用 <code>gpg</code> 和 <code>/etc/apt/trusted.gpg.d</code>。</li><li>确保密钥来源可靠。</li></ul><h4 id="4.-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B" tabindex="-1">4. 使用场景与示例</h4><p>以下是 APT 在实际任务中的应用：</p><ol><li><p><strong>安装和更新软件</strong>：</p><ul><li>安装 Nginx 并更新：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure></li><li>安装特定版本：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3=3.10.6-1~22.04</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>清理系统</strong>：</p><ul><li>清理缓存和无用依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get clean</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure></li><li>删除孤立包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>添加第三方源</strong>：</p><ul><li>安装最新 Node.js：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:chris-lea/node.js</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install nodejs</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>修复依赖问题</strong>：</p><ul><li>修复损坏依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -f</span><br><span class="line">sudo dpkg --configure -a</span><br></pre></td></tr></table></figure></li><li>重新配置包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dpkg-reconfigure nginx</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>查询和搜索</strong>：</p><ul><li>查找 Python 相关包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search python3 | grep library</span><br></pre></td></tr></table></figure></li><li>检查包状态：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dpkg -l | grep vim</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="5.-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95" tabindex="-1">5. 高级用法</h4><ul><li><strong>自动化脚本</strong>：<ul><li>批量安装软件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">PACKAGES=<span class="string">&quot;vim htop curl&quot;</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install -y <span class="variable">$PACKAGES</span></span><br></pre></td></tr></table></figure>保存为 <code>install_tools.sh</code>，运行 <code>bash install_tools.sh</code>。</li></ul></li><li><strong>PPA 管理</strong>：<ul><li>列出所有 PPA：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /etc/apt/sources.list.d/</span><br></pre></td></tr></table></figure></li><li>禁用 PPA：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mv /etc/apt/sources.list.d/ppa.list /etc/apt/sources.list.d/ppa.list.disabled</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>缓存备份</strong>：<ul><li>备份已下载包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp -r /var/cache/apt/archives /backup/apt_cache</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>离线安装</strong>：<ul><li>下载包及其依赖：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install --download-only nginx</span><br></pre></td></tr></table></figure></li><li>复制到另一台机器：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /var/cache/apt/archives/*.deb /media/usb</span><br><span class="line">sudo dpkg -i /media/usb/*.deb</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="7.-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88networking%EF%BC%89" tabindex="-1">7. 网络命令（Networking）</h2><h4 id="1.-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86" tabindex="-1">1. 网络接口管理</h4><p>这些命令用于查看和配置网络接口（如以太网、Wi-Fi）。</p><h5 id="1.1-ip" tabindex="-1">1.1 ip</h5><p><strong>功能</strong>：现代网络配置工具，用于显示和管理系统网络接口、IP 地址、路由和邻居表，替代过时的 <code>ifconfig</code>。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip [选项] 对象 &#123;命令 | help&#125;</span><br></pre></td></tr></table></figure><p><strong>常用对象</strong>：</p><ul><li><code>link</code>：管理网络接口状态。</li><li><code>addr</code>：管理 IP 地址。</li><li><code>route</code>：管理路由表。</li><li><code>neigh</code>：管理 ARP 表（邻居）。<br><strong>常用选项</strong>：</li><li><code>-s</code>：显示统计信息（如流量）。</li><li><code>-4</code> / <code>-6</code>：仅显示 IPv4/IPv6。</li><li><code>-c</code>：彩色输出。<br><strong>场景</strong>：</li><li>检查网络接口状态和 IP 地址。</li><li>配置临时 IP 或路由。</li><li>监控接口流量。<br><strong>示例</strong>：</li><li>查看所有接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip link</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP</span><br><span class="line">    link/ether 00:16:3e:12:34:56 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></li><li>查看 IP 地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500</span><br><span class="line">    inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0</span><br></pre></td></tr></table></figure></li><li>添加临时 IP：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip addr add 192.168.1.101/24 dev eth0</span><br></pre></td></tr></table></figure></li><li>查看路由表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default via 192.168.1.1 dev eth0</span><br><span class="line">192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100</span><br></pre></td></tr></table></figure></li><li>查看接口统计：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip -s link</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>启用/禁用接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ip link set eth0 down</span><br><span class="line">sudo ip link set eth0 up</span><br></pre></td></tr></table></figure></li><li>添加静态路由：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add 10.0.0.0/24 via 192.168.1.1</span><br></pre></td></tr></table></figure></li><li>清理 ARP 缓存：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip neigh flush dev eth0</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>配置更改是临时的，重启后失效，需修改配置文件（如 <code>/etc/netplan/</code>）。</li><li>需要 <code>sudo</code> 执行修改操作。</li><li>推荐用 <code>ip</code> 替代 <code>ifconfig</code>，因为它是现代标准。</li></ul><h5 id="1.2-ifconfig" tabindex="-1">1.2 ifconfig</h5><p><strong>功能</strong>：传统工具，用于查看和配置网络接口（需安装 <code>sudo apt install net-tools</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [接口] [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-a</code>：显示所有接口（包括未激活的）。</li><li><code>up</code> / <code>down</code>：启用/禁用接口。</li><li><code>地址</code>：设置 IP 地址。<br><strong>场景</strong>：</li><li>快速检查接口 IP 和状态。</li><li>兼容旧脚本或系统。<br><strong>示例</strong>：</li><li>查看所有接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">      inet 192.168.1.100  netmask 255.255.255.0  broadcast 192.168.1.255</span><br></pre></td></tr></table></figure></li><li>设置 IP 地址：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth0 192.168.1.101 netmask 255.255.255.0</span><br></pre></td></tr></table></figure></li><li>禁用接口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ifconfig eth0 down</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 | grep inet</span><br></pre></td></tr></table></figure>提取 IP 地址。<br><strong>注意</strong>：</li><li><code>ifconfig</code> 已逐渐被 <code>ip</code> 取代，某些系统可能未预装 <code>net-tools</code>。</li><li>配置更改临时，需修改配置文件持久化。</li></ul><h5 id="1.3-nmcli%EF%BC%88networkmanager-cli%EF%BC%89" tabindex="-1">1.3 nmcli（NetworkManager CLI）</h5><p><strong>功能</strong>：管理 NetworkManager 配置的网络连接，适用于桌面和服务器环境（需安装 <code>network-manager</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli [选项] 对象 &#123;命令&#125;</span><br></pre></td></tr></table></figure><p><strong>常用对象</strong>：</p><ul><li><code>connection</code>（con）：管理连接配置。</li><li><code>device</code>（dev）：管理网络设备。</li><li><code>general</code>：显示 NetworkManager 状态。<br><strong>常用命令</strong>：</li><li><code>show</code>：显示状态或配置。</li><li><code>up</code> / <code>down</code>：启用/禁用连接。</li><li><code>add</code> / <code>modify</code>：添加/修改连接。<br><strong>场景</strong>：</li><li>配置 Wi-Fi 或有线连接。</li><li>管理 DHCP 或静态 IP。</li><li>自动化网络配置。<br><strong>示例</strong>：</li><li>查看连接状态：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection show</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         UUID                                  TYPE      DEVICE</span><br><span class="line">Wired conn   123e4567-e89b-12d3-a456-426614174000  ethernet  eth0</span><br></pre></td></tr></table></figure></li><li>连接 Wi-Fi：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi connect SSID password PASSWORD</span><br></pre></td></tr></table></figure></li><li>设置静态 IP：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection modify &quot;Wired conn&quot; ipv4.addresses 192.168.1.100/24</span><br><span class="line">nmcli connection modify &quot;Wired conn&quot; ipv4.gateway 192.168.1.1</span><br><span class="line">nmcli connection modify &quot;Wired conn&quot; ipv4.method manual</span><br><span class="line">nmcli connection up &quot;Wired conn&quot;</span><br></pre></td></tr></table></figure></li><li>查看 Wi-Fi 热点：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli device wifi list</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>批量配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmcli connection add type ethernet ifname eth0 con-name eth0-static ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8</span><br></pre></td></tr></table></figure></li><li>监控连接状态：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 nmcli device status</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需确保 NetworkManager 服务运行（<code>systemctl status NetworkManager</code>）。</li><li>配置存储在 <code>/etc/NetworkManager/system-connections/</code>。</li><li>服务器可能使用 <code>netplan</code> 而非 NetworkManager。</li></ul><h5 id="1.4-netplan" tabindex="-1">1.4 netplan</h5><p><strong>功能</strong>：Ubuntu 默认网络配置工具，通过 YAML 文件管理网络设置（<code>/etc/netplan/</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netplan [命令]</span><br></pre></td></tr></table></figure><p><strong>常用命令</strong>：</p><ul><li><code>apply</code>：应用配置文件更改。</li><li><code>generate</code>：生成配置文件缓存。</li><li><code>try</code>：测试配置，超时后回滚。<br><strong>场景</strong>：</li><li>配置持久化网络设置（如静态 IP）。</li><li>管理复杂网络（如桥接、VLAN）。<br><strong>示例</strong>：</li><li>编辑配置文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/netplan/01-netcfg.yaml</span><br></pre></td></tr></table></figure>示例内容：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">ethernets:</span></span><br><span class="line">    <span class="attr">eth0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">no</span></span><br><span class="line">      <span class="attr">addresses:</span> [<span class="number">192.168</span><span class="number">.1</span><span class="number">.100</span><span class="string">/24</span>]</span><br><span class="line">      <span class="attr">gateway4:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">nameservers:</span></span><br><span class="line">        <span class="attr">addresses:</span> [<span class="number">8.8</span><span class="number">.8</span><span class="number">.8</span>, <span class="number">8.8</span><span class="number">.4</span><span class="number">.4</span>]</span><br></pre></td></tr></table></figure></li><li>应用配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></li><li>测试配置（120 秒回滚）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netplan try</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>配置 Wi-Fi：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">network:</span></span><br><span class="line">  <span class="attr">version:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">wifis:</span></span><br><span class="line">    <span class="attr">wlan0:</span></span><br><span class="line">      <span class="attr">dhcp4:</span> <span class="literal">yes</span></span><br><span class="line">      <span class="attr">access-points:</span></span><br><span class="line">        <span class="attr">&quot;MySSID&quot;:</span></span><br><span class="line">          <span class="attr">password:</span> <span class="string">&quot;MyPassword&quot;</span></span><br></pre></td></tr></table></figure></li><li>备份配置：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/netplan/01-netcfg.yaml /etc/netplan/01-netcfg.yaml.bak</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>YAML 格式对缩进敏感（2 空格）。</li><li>需要 <code>sudo</code> 编辑和应用配置。</li><li>检查语法：<code>sudo netplan generate</code>。</li></ul><h4 id="2.-%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E6%B5%8B%E8%AF%95" tabindex="-1">2. 网络连接测试</h4><p>这些命令用于测试网络连通性和延迟。</p><h5 id="2.1-ping" tabindex="-1">2.1 ping</h5><p><strong>功能</strong>：发送 ICMP 数据包测试主机连通性和延迟。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [选项] 目标</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-c 次数</code>：发送指定次数的包。</li><li><code>-i 秒</code>：设置发送间隔。</li><li><code>-s 大小</code>：设置数据包大小（字节）。</li><li><code>-4</code> / <code>-6</code>：强制 IPv4/IPv6。<br><strong>场景</strong>：</li><li>测试服务器是否可达。</li><li>测量网络延迟。<br><strong>示例</strong>：</li><li>测试 Google：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 google.com</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PING google.com (142.250.190.78) 56(84) bytes of data.</span><br><span class="line">64 bytes from 142.250.190.78: icmp_seq=1 ttl=117 time=20.1 ms</span><br><span class="line">...</span><br><span class="line">--- google.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 3004ms</span><br></pre></td></tr></table></figure></li><li>设置间隔：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -i 0.5 192.168.1.1</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>测试本地网络：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 192.168.1.1</span><br></pre></td></tr></table></figure></li><li>检查丢包：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 100 google.com | grep &quot;packet loss&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>某些服务器禁用 ICMP，可能无法 ping。</li><li>需 <code>sudo</code> 使用特殊选项（如 <code>-s</code> 调整包大小）。</li></ul><h5 id="2.2-traceroute" tabindex="-1">2.2 traceroute</h5><p><strong>功能</strong>：跟踪数据包到目标主机的路由路径（需安装 <code>sudo apt install traceroute</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [选项] 目标</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-n</code>：不解析主机名，显示 IP。</li><li><code>-m 跳数</code>：设置最大跳数。</li><li><code>-w 秒</code>：设置每跳超时时间。</li><li><code>-4</code> / <code>-6</code>：强制 IPv4/IPv6。<br><strong>场景</strong>：</li><li>诊断网络路由问题。</li><li>确定数据包路径和延迟。<br><strong>示例</strong>：</li><li>跟踪到 Google：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute google.com</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1  192.168.1.1  0.5 ms</span><br><span class="line">2  10.0.0.1     1.2 ms</span><br><span class="line">3  142.250.190.78  20.3 ms</span><br></pre></td></tr></table></figure></li><li>不解析主机名：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -n google.com</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>限制跳数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -m 10 google.com</span><br></pre></td></tr></table></figure></li><li>结合 <code>grep</code>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute google.com | grep &quot;ms&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需 <code>sudo</code> 在某些系统上运行。</li><li>防火墙可能阻止 traceroute 数据包。</li></ul><h5 id="2.3-mtr" tabindex="-1">2.3 mtr</h5><p><strong>功能</strong>：结合 <code>ping</code> 和 <code>traceroute</code>，实时跟踪路由并显示丢包和延迟（需安装 <code>sudo apt install mtr</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr [选项] 目标</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-r</code>：报告模式（非交互）。</li><li><code>-c 次数</code>：发送指定次数的包。</li><li><code>-n</code>：不解析主机名。</li><li><code>--tcp</code>：使用 TCP 而非 ICMP。<br><strong>场景</strong>：</li><li>实时诊断网络抖动或丢包。</li><li>分析长距离路由性能。<br><strong>示例</strong>：</li><li>实时跟踪：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr google.com</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host                  Loss%   Snt   Last   Avg  Best  Wrst StDev</span><br><span class="line">1. 192.168.1.1       0.0%    10    0.5   0.6   0.4   0.8   0.1</span><br><span class="line">2. 10.0.0.1          0.0%    10    1.2   1.3   1.1   1.5   0.2</span><br></pre></td></tr></table></figure></li><li>报告模式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr -r -c 10 google.com</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>保存报告：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr -r -c 100 google.com &gt; mtr_report.txt</span><br></pre></td></tr></table></figure></li><li>使用 TCP：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr --tcp google.com</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>比 <code>traceroute</code> 更适合动态分析。</li><li>需 <code>sudo</code> 使用某些协议（如 TCP）。</li></ul><h4 id="3.-%E7%BD%91%E7%BB%9C%E6%B5%81%E9%87%8F%E4%B8%8E%E7%AB%AF%E5%8F%A3%E7%9B%91%E6%8E%A7" tabindex="-1">3. 网络流量与端口监控</h4><p>这些命令用于监控网络流量和开放端口。</p><h5 id="3.1-netstat" tabindex="-1">3.1 netstat</h5><p><strong>功能</strong>：显示网络连接、路由表和接口统计（需安装 <code>sudo apt install net-tools</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-a</code>：显示所有连接（包括监听）。</li><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-p</code>：显示关联进程。</li><li><code>-n</code>：显示数字地址/端口（不解析）。</li><li><code>-r</code>：显示路由表。<br><strong>场景</strong>：</li><li>检查开放端口和服务。</li><li>查看当前网络连接。<br><strong>示例</strong>：</li><li>显示监听端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure></li><li>显示进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tulnp</span><br></pre></td></tr></table></figure></li><li>查看路由：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>筛选特定端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -tuln | grep :80</span><br></pre></td></tr></table></figure></li><li>统计连接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an | grep ESTABLISHED | wc -l</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li><code>netstat</code> 被 <code>ss</code> 取代，推荐使用 <code>ss</code>。</li><li>需要 <code>sudo</code> 查看某些连接。</li></ul><h5 id="3.2-ss" tabindex="-1">3.2 ss</h5><p><strong>功能</strong>：现代工具，显示网络连接和端口信息，替代 <code>netstat</code>，更高效。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-t</code>：显示 TCP 连接。</li><li><code>-u</code>：显示 UDP 连接。</li><li><code>-l</code>：显示监听端口。</li><li><code>-p</code>：显示关联进程。</li><li><code>-n</code>：不解析地址/端口。</li><li><code>-a</code>：显示所有连接。<br><strong>场景</strong>：</li><li>检查服务器开放端口。</li><li>监控活跃连接。<br><strong>示例</strong>：</li><li>显示监听端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netid  State      Recv-Q Send-Q  Local Address:Port   Peer Address:Port</span><br><span class="line">tcp    LISTEN     0      128     0.0.0.0:22           0.0.0.0:*</span><br></pre></td></tr></table></figure></li><li>显示 TCP 连接和进程：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tnp</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>筛选活跃连接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tn state established</span><br></pre></td></tr></table></figure></li><li>实时监控：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 &#x27;ss -tuln&#x27;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>比 <code>netstat</code> 更快，适合现代系统。</li><li>需要 <code>sudo</code> 查看详细进程信息。</li></ul><h5 id="3.3-nmap" tabindex="-1">3.3 nmap</h5><p><strong>功能</strong>：网络扫描工具，用于端口扫描、主机发现和服务探测（需安装 <code>sudo apt install nmap</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap [选项] 目标</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-p 端口</code>：扫描指定端口。</li><li><code>-sS</code>：TCP SYN 扫描（快速）。</li><li><code>-sU</code>：UDP 扫描。</li><li><code>-O</code>：探测操作系统。</li><li><code>-sV</code>：探测服务版本。</li><li><code>-A</code>：全面扫描（端口、服务、OS）。<br><strong>场景</strong>：</li><li>检查本地或远程主机的开放端口。</li><li>识别网络服务和版本。<br><strong>示例</strong>：</li><li>扫描本地主机：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap localhost</span><br></pre></td></tr></table></figure>输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting Nmap 7.80 ( https://nmap.org )</span><br><span class="line">Nmap scan report for localhost (127.0.0.1)</span><br><span class="line">PORT   STATE SERVICE</span><br><span class="line">22/tcp open  ssh</span><br></pre></td></tr></table></figure></li><li>扫描特定端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 80,443 192.168.1.100</span><br></pre></td></tr></table></figure></li><li>全面扫描：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A 192.168.1.100</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>扫描子网：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap 192.168.1.0/24</span><br></pre></td></tr></table></figure></li><li>保存结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -oN scan.txt 192.168.1.100</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>扫描外部主机可能触发防火墙或被视为攻击。</li><li>需要 <code>sudo</code> 执行某些扫描（如 <code>-sS</code>、<code>-O</code>）。</li></ul><h5 id="3.4-iftop" tabindex="-1">3.4 iftop</h5><p><strong>功能</strong>：实时监控网络接口的流量（需安装 <code>sudo apt install iftop</code>）。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iftop [选项]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-i 接口</code>：监控指定接口。</li><li><code>-B</code>：以字节显示（默认比特）。</li><li><code>-f 过滤器</code>：应用过滤规则。<br><strong>场景</strong>：</li><li>分析网络带宽使用。</li><li>识别高流量主机或连接。<br><strong>示例</strong>：</li><li>监控 eth0：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iftop -i eth0</span><br></pre></td></tr></table></figure></li><li>显示字节：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iftop -B</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>过滤特定 IP：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iftop -f &quot;host 192.168.1.100&quot;</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需要 <code>sudo</code> 运行。</li><li>适合实时流量分析，长期监控建议用 <code>nload</code>。</li></ul><h4 id="4.-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%8D%8F%E8%AE%AE" tabindex="-1">4. 网络服务与协议</h4><p>这些命令用于管理网络服务和测试协议。</p><h5 id="4.1-curl" tabindex="-1">4.1 curl</h5><p><strong>功能</strong>：传输数据，支持 HTTP、HTTPS、FTP 等协议，常用于测试 API 或下载文件。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl [选项] URL</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-o 文件</code>：保存输出到文件。</li><li><code>-O</code>：以远程文件名保存。</li><li><code>-I</code>：仅获取 HTTP 头。</li><li><code>-X 方法</code>：指定 HTTP 方法（如 <code>POST</code>）。</li><li><code>-d 数据</code>：发送 POST 数据。</li><li><code>-H 头</code>：添加 HTTP 头。<br><strong>场景</strong>：</li><li>测试 Web 服务器响应。</li><li>调用 REST API。</li><li>下载文件。<br><strong>示例</strong>：</li><li>获取网页：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://example.com</span><br></pre></td></tr></table></figure></li><li>下载文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://example.com/file.zip</span><br></pre></td></tr></table></figure></li><li>发送 POST 请求：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST -d &#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27; -H &quot;Content-Type: application/json&quot; http://api.example.com</span><br></pre></td></tr></table></figure></li><li>查看响应头：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I https://example.com</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>批量下载：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://example.com/file[1-3].txt</span><br></pre></td></tr></table></figure></li><li>认证请求：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u user:pass https://example.com</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>支持多种协议，适合脚本和自动化。</li><li>调试时使用 <code>-v</code> 查看详细交互。</li></ul><h5 id="4.2-wget" tabindex="-1">4.2 wget</h5><p><strong>功能</strong>：下载文件，支持 HTTP、HTTPS、FTP，适合非交互式下载。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget [选项] URL</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-O 文件</code>：指定输出文件。</li><li><code>-c</code>：断点续传。</li><li><code>-r</code>：递归下载。</li><li><code>-q</code>：安静模式。</li><li><code>--limit-rate=速率</code>：限制下载速度。<br><strong>场景</strong>：</li><li>下载大文件或镜像。</li><li>爬取网站内容。<br><strong>示例</strong>：</li><li>下载文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://example.com/file.zip</span><br></pre></td></tr></table></figure></li><li>断点续传：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://example.com/large.iso</span><br></pre></td></tr></table></figure></li><li>递归下载：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r -np http://example.com/docs/</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>限制速度：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --limit-rate=500k https://example.com/file.zip</span><br></pre></td></tr></table></figure></li><li>下载列表：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i urls.txt</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>比 <code>curl</code> 更适合简单下载任务。</li><li>递归下载需谨慎，可能消耗大量资源。</li></ul><h5 id="4.3-ssh" tabindex="-1">4.3 ssh</h5><p><strong>功能</strong>：通过 SSH 协议远程登录或执行命令。<br><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [选项] 用户@主机 [命令]</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong>：</p><ul><li><code>-p 端口</code>：指定 SSH 端口。</li><li><code>-i 密钥</code>：使用指定私钥。</li><li><code>-X</code>：启用 X11 转发（图形界面）。</li><li><code>-L</code>：本地端口转发。<br><strong>场景</strong>：</li><li>远程管理服务器。</li><li>安全传输文件（通过 <code>scp</code> 或 <code>sftp</code>）。<br><strong>示例</strong>：</li><li>登录远程主机：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100</span><br></pre></td></tr></table></figure></li><li>执行远程命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100 &#x27;uptime&#x27;</span><br></pre></td></tr></table></figure></li><li>使用非标准端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 user@192.168.1.100</span><br></pre></td></tr></table></figure></li></ul><p><strong>高级用法</strong>：</p><ul><li>端口转发：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -L 8080:localhost:80 user@remote</span><br></pre></td></tr></table></figure>将远程主机的 80 端口映射到本地 8080。</li><li>使用密钥登录：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i ~/.ssh/id_rsa user@remote</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong>：</p><ul><li>需配置 <code>~/.ssh/config</code> 简化连接。</li><li>确保 SSH 服务运行（<code>sudo systemctl status sshd</code>）。</li></ul><h4 id="5.-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E7%A4%BA%E4%BE%8B-1" tabindex="-1">5. 使用场景与示例</h4><p>以下是网络命令在实际任务中的应用：</p><ol><li><p><strong>配置网络接口</strong>：</p><ul><li>设置静态 IP：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nmcli connection modify &quot;Wired conn&quot; ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.method manual</span><br><span class="line">sudo nmcli connection up &quot;Wired conn&quot;</span><br></pre></td></tr></table></figure></li><li>或通过 netplan：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/netplan/01-netcfg.yaml</span><br><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>诊断网络问题</strong>：</p><ul><li>测试连通性：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 4 google.com</span><br></pre></td></tr></table></figure></li><li>跟踪路由：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr -r -c 10 google.com</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>监控网络流量</strong>：</p><ul><li>查看实时流量：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iftop -i eth0</span><br></pre></td></tr></table></figure></li><li>检查开放端口：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -tuln</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>测试 Web 服务</strong>：</p><ul><li>检查 HTTP 响应：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -I http://example.com</span><br></pre></td></tr></table></figure></li><li>下载网站：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r http://example.com</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>远程管理</strong>：</p><ul><li>登录服务器并查看日志：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh user@192.168.1.100 &#x27;tail -f /var/log/syslog&#x27;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="6.-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95-1" tabindex="-1">6. 高级用法</h4><ul><li><strong>自动化网络测试</strong>：<ul><li>脚本检查连接：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">ping -c 4 192.168.1.1 || <span class="built_in">echo</span> <span class="string">&quot;Network down&quot;</span></span><br></pre></td></tr></table></figure>保存为 <code>check_network.sh</code>，用 <code>crontab</code> 定时运行。</li></ul></li><li><strong>端口扫描脚本</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -p 1-1000 192.168.1.0/24 -oN scan_results.txt</span><br></pre></td></tr></table></figure></li><li><strong>流量监控仪表板</strong>：<ul><li>使用 <code>nload</code>（需安装 <code>sudo apt install nload</code>）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nload eth0</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>SSH 隧道</strong>：<ul><li>反向隧道（远程访问本地服务）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -R 8080:localhost:80 user@remote</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="7.-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E6%89%A9%E5%B1%95-1" tabindex="-1">7. 注意事项与扩展</h4><ol><li><strong>安全提示</strong>：<ul><li>使用 <code>nmap</code> 扫描外部主机可能触发防火墙或被视为攻击。</li><li>SSH 默认端口（22）易受攻击，建议修改（<code>/etc/ssh/sshd_config</code>）。</li><li>定期检查开放端口（<code>ss -tuln</code>）。</li></ul></li><li><strong>性能优化</strong>：<ul><li>监控大流量时，使用 <code>iftop</code> 或 <code>nload</code> 而非 <code>netstat</code>。</li><li>批量下载（<code>wget -r</code>）需限制深度（<code>-l</code>）避免过载。</li></ul></li><li><strong>相关工具</strong>：<ul><li><strong>tcpdump</strong>：捕获网络数据包。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tcpdump</span><br><span class="line">sudo tcpdump -i eth0</span><br></pre></td></tr></table></figure></li><li><strong>wireshark</strong>：图形化网络分析工具。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install wireshark</span><br><span class="line">wireshark &amp;</span><br></pre></td></tr></table></figure></li><li><strong>dig</strong> / <strong>nslookup</strong>：DNS 查询工具。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig example.com</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="8.-%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%BD%92%E6%A1%A3%EF%BC%88compression-%26-archiving%EF%BC%89" tabindex="-1">8. 压缩和归档（Compression &amp; Archiving）</h2><ul><li><strong>tar</strong>: 创建/提取 tar 归档。<br>示例: <code>tar -czf archive.tar.gz folder/</code>。</li><li><strong>gzip</strong>: 压缩文件。<br>示例: <code>gzip file.txt</code>。</li><li><strong>gunzip</strong>: 解压 gz 文件。<br>示例: <code>gunzip file.txt.gz</code>。</li><li><strong>zip</strong>: 创建 zip 归档。<br>示例: <code>zip archive.zip file.txt</code>。</li><li><strong>unzip</strong>: 解压 zip 文件。<br>示例: <code>unzip archive.zip</code>。</li></ul><h2 id="9.-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%EF%BC%88search-%26-text-processing%EF%BC%89" tabindex="-1">9. 搜索和文本处理（Search &amp; Text Processing）</h2><ul><li><strong>grep</strong>: 在文件中搜索文本。<br>示例: <code>grep &quot;error&quot; log.txt</code>。</li><li><strong>find</strong>: 搜索文件（见文件管理）。</li><li><strong>locate</strong>: 快速搜索文件位置（需更新数据库）。<br>示例: <code>locate filename</code>。</li><li><strong>which</strong>: 显示命令的可执行路径。<br>示例: <code>which ls</code>。</li><li><strong>whereis</strong>: 查找命令的二进制、源和手册位置。<br>示例: <code>whereis ls</code>。</li><li><strong>whatis</strong>: 显示命令的简短描述。<br>示例: <code>whatis ls</code>。</li><li><strong>man</strong>: 显示命令的手册。<br>示例: <code>man ls</code>。</li><li><strong>apropos</strong>: 根据关键词搜索命令。<br>示例: <code>apropos network</code>。</li></ul><h2 id="10.-%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%EF%BC%88services-%26-system-admin%EF%BC%89" tabindex="-1">10. 服务和系统管理（Services &amp; System Admin）</h2><ul><li><strong>service</strong>: 管理系统服务。<br>示例: <code>sudo service ssh start</code>。</li><li><strong>systemctl</strong>: 管理 systemd 服务（现代版）。<br>示例: <code>sudo systemctl status ssh</code>。</li><li><strong>reboot</strong>: 重启系统。<br>示例: <code>sudo reboot</code>。</li><li><strong>shutdown</strong>: 关机或重启。<br>示例: <code>sudo shutdown -h now</code>。</li><li><strong>history</strong>: 显示命令历史。<br>示例: <code>history</code>。</li><li><strong>clear</strong>: 清空终端屏幕。<br>示例: <code>clear</code>。</li><li><strong>alias</strong>: 创建命令别名。<br>示例: <code>alias ll='ls -la'</code>。</li><li><strong>env</strong>: 显示当前环境变量。<br>示例: <code>env</code>。</li><li><strong>export</strong>: 设置环境变量。<br>示例: <code>export PATH=$PATH:/newpath</code>。</li></ul><h2 id="11.-%E5%85%B6%E4%BB%96%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88miscellaneous%EF%BC%89" tabindex="-1">11. 其他实用命令（Miscellaneous）</h2><ul><li><strong>bc</strong>: 命令行计算器。<br>示例: <code>echo &quot;2+2&quot; | bc</code>。</li><li><strong>sort</strong>: 排序文件行。<br>示例: <code>sort file.txt</code>。</li><li><strong>uniq</strong>: 去除重复行。<br>示例: <code>sort file.txt | uniq</code>。</li><li><strong>wc</strong>: 统计行数/字数。<br>示例: <code>wc -l file.txt</code>。</li><li><strong>diff</strong>: 比较两个文件差异。<br>示例: <code>diff file1.txt file2.txt</code>。</li><li><strong>paste</strong>: 合并文件行。<br>示例: <code>paste file1.txt file2.txt</code>。</li><li><strong>cut</strong>: 提取文件列。<br>示例: <code>cut -d',' -f1 csvfile.csv</code>。</li><li><strong>tr</strong>: 转换/删除字符。<br>示例: <code>tr 'a-z' 'A-Z' &lt; file.txt</code>。</li><li><strong>sed</strong>: 流编辑器，替换文本。<br>示例: <code>sed 's/old/new/g' file.txt</code>。</li><li><strong>awk</strong>: 文本处理工具。<br>示例: <code>awk '&#123;print $1&#125;' file.txt</code> (打印第一列)。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%F0%9F%94%B9-1.-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;🔹 1. 基础操作命令&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;</summary>
      
    
    
    
    
    <category term="service" scheme="https://borrowyourhuaji.github.io/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>数位dp</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/</id>
    <published>2025-09-13T15:00:51.000Z</published>
    <updated>2025-09-13T15:01:40.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dp%EF%BC%89%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-digit-dp%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E-acm-%E7%AB%9E%E8%B5%9B%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E4%B8%AD%E3%80%82%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E6%BB%A1%E8%B6%B3%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AA%E6%95%B0%E3%80%82%E6%95%B0%E4%BD%8D-dp-%E7%89%B9%E5%88%AB%E9%80%82%E5%90%88%E5%A4%84%E7%90%86%E5%A4%A7%E8%8C%83%E5%9B%B4%EF%BC%88%E5%A6%82-(-10%5E%7B18%7D-)%EF%BC%89%E7%9A%84%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E9%80%9A%E8%BF%87%E9%80%90%E4%BD%8D%E6%9E%84%E9%80%A0%E6%95%B0%E5%AD%97%E5%B9%B6%E7%BB%93%E5%90%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%81%BF%E5%85%8D%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E3%80%82" tabindex="-1">数位统计 DP（Digit DP）详细解析<br>数位统计 DP（Digit Dynamic Programming，简称 Digit DP）是一种基于动态规划的算法技术，广泛应用于 <strong>ACM 竞赛</strong>、算法设计和计数问题中。它主要用于解决与数字的位数相关的计数问题，例如统计某个范围内满足特定条件的整数个数。数位 DP 特别适合处理大范围（如 ( 10^{18} )）的计数问题，通过逐位构造数字并结合动态规划避免暴力枚举。</h2><h2 id="1.-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">1. 数位统计 DP 的基本概念</h2><h3 id="1.1-%E5%AE%9A%E4%B9%89" tabindex="-1">1.1 定义</h3><p>数位 DP 是一种用于统计某个范围内整数个数（或满足特定条件的数字）的动态规划方法，通常问题形式如下：</p><ul><li>给定一个范围 ([L, R])（例如 ( L, R \leq 10^{18} )）。</li><li>要求统计 ([L, R]) 内满足特定条件的整数个数，例如：<ul><li>数字的各位之和为某个值（如和为 ( K )）。</li><li>数字中不含某位（如不含 4）。</li><li>数字是某个数的倍数（如是 3 的倍数）。</li><li>数字的各位满足某种模式（如单调递增）。</li></ul></li><li><strong>目标</strong>：<ul><li>计算满足条件的整数个数。</li><li>（可选）输出满足条件的数字。</li></ul></li><li><strong>输出</strong>：<ul><li>满足条件的整数个数（可能需要模 ( 10^9+7 )）。</li><li>（可选）一个或多个满足条件的数字。<br><strong>示例</strong>：</li></ul></li><li>输入：( L = 1, R = 100 )，条件：数字的各位之和是 5。</li><li>满足条件的数字：<ul><li>5（( 5 = 5 )）</li><li>14（( 1 + 4 = 5 )）</li><li>23（( 2 + 3 = 5 )）</li><li>32（( 3 + 2 = 5 )）</li><li>41（( 4 + 1 = 5 )）</li><li>50（( 5 + 0 = 5 )）</li></ul></li><li>输出：6（满足条件的数字个数）。</li><li>答案计算：统计 ([1, 100]) 内各位之和为 5 的数字个数，通常用 ( f® - f(L-1) )，其中 ( f(x) ) 表示 ( [1, x] ) 内满足条件的数字个数。<br><strong>关键特点</strong>：</li><li><strong>逐位构造</strong>：从高位到低位逐位确定数字，动态维护状态。</li><li><strong>范围处理</strong>：通过 ( f® - f(L-1) ) 计算 ([L, R]) 的答案。</li><li><strong>状态压缩</strong>：用 DP 状态记录前缀信息（如当前数字、前缀和、模数等）。</li><li><strong>记忆化</strong>：避免重复计算重叠子问题。</li><li><strong>大范围适用</strong>：适合 ( R \leq 10^{18} )，暴力枚举不可行。</li></ul><h3 id="1.2-%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B" tabindex="-1">1.2 数学模型</h3><ul><li><strong>输入</strong>：<ul><li>范围：( L, R )（整数，( 1 \leq L \leq R \leq 10^{18} )）。</li><li>条件：数字的性质（例如，各位之和、模 ( K )、不含某位）。</li></ul></li><li><strong>目标</strong>：<ul><li>计算 ([L, R]) 内满足条件的整数个数 ( C )。</li><li>通常通过 ( f® - f(L-1) )，其中 ( f(x) ) 是 ( [1, x] ) 内满足条件的个数。</li></ul></li><li><strong>输出</strong>：<ul><li>( C )（整数，可能模 ( 10^9+7 )）。</li><li>（可选）满足条件的数字。</li></ul></li><li><strong>约束</strong>：<ul><li>数字范围大（( 10^{18} )），需高效算法。</li><li>条件基于数字的位（十进制或二进制）。</li></ul></li></ul><h3 id="1.3-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">1.3 与其他问题的对比</h3><table><thead><tr><th><strong>问题</strong></th><th><strong>定义</strong></th><th><strong>Goal</strong></th><th><strong>DP 状态</strong></th><th><strong>Complexity</strong></th></tr></thead><tbody><tr><td>数位 DP</td><td>统计范围内满足位数条件的整数个数</td><td>满足条件的个数</td><td>( dp[pos][state] ): 第 pos 位的状态</td><td>( O(\log R \cdot S) )</td></tr><tr><td>子集和</td><td>集合中找子集和为 T</td><td>判断是否存在子集</td><td>( dp[i][s] ): 前 i 个元素和为 s</td><td>( O(n \times T) )</td></tr><tr><td>布尔括号</td><td>加括号使布尔表达式为 True 的方案数</td><td>True 方案数</td><td>( dp[i][j][b] ): 子表达式 [i:j] 为 b</td><td>( O(n^3) )</td></tr><tr><td>矩阵链乘法</td><td>确定矩阵乘法顺序，最小化乘法次数</td><td>最小乘法次数</td><td>( dp[i][j] ): 子链 [i:j] 最小代价</td><td>( O(n^3) )</td></tr></tbody></table><ul><li><strong>数位 DP vs 子集和</strong>：<ul><li>数位 DP：基于数字位，计数问题。</li><li>子集和：基于集合，存在性问题。</li></ul></li><li><strong>数位 DP vs 布尔括号</strong>：<ul><li>数位 DP：逐位构造，范围计数。</li><li>布尔括号：区间 DP，括号计数。</li></ul></li><li><strong>数位 DP vs 矩阵链乘法</strong>：<ul><li>数位 DP：数字位优化，计数。</li><li>矩阵链乘法：乘法顺序优化，最小代价。</li></ul></li></ul><h3 id="1.4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">1.4 应用场景</h3><ul><li><strong>ACM 竞赛</strong>：<ul><li>计数问题：Codeforces 1036C（Classy Numbers）。</li><li>模运算：AtCoder ABC 162F（Digits）。</li><li>路径恢复：SPOJ NDIGITS（输出数字）。</li><li>变种：HDU 4352（XHXJ’s LIS，数位 DP + 状态压缩）。</li></ul></li><li><strong>实际应用</strong>：<ul><li>密码学：统计满足条件的数字（如模 ( K )）。</li><li>数据库：范围查询优化。</li><li>数据分析：数字模式统计。</li><li>编码：数字编码方案计数。</li></ul></li></ul><hr><h2 id="2.-%E6%95%B0%E4%BD%8D-dp-%E7%9A%84%E8%A7%A3%E6%B3%95" tabindex="-1">2. 数位 DP 的解法</h2><p>数位 DP 通过逐位构造数字并维护状态，结合动态规划解决计数问题。以下详细讲解主要解法：记忆化递归、动态规划、路径恢复。</p><h3 id="2.1-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%88%E6%A0%87%E5%87%86%E6%95%B0%E4%BD%8D-dp%EF%BC%89" tabindex="-1">2.1 记忆化递归（标准数位 DP）</h3><ul><li><strong>思路</strong>：<ul><li>将数字从高位到低位逐位构造，记录当前状态（如当前位、是否贴近上界、前缀和等）。</li><li>使用记忆化递归避免重复计算。</li><li>计算 ( f(x) )，即 ( [1, x] ) 内满足条件的数字个数。</li><li>答案为 ( f® - f(L-1) ).</li></ul></li><li><strong>状态定义</strong>：<ul><li>( dp[pos][state] )：从第 ( pos ) 位开始构造，当前状态为 ( state )，满足条件的数字个数。</li><li>常见状态：<ul><li>( pos ): 当前处理的位（从高到低）。</li><li>( tight ): 是否贴近上界（1: 必须 ≤ 当前位的数字，0: 可取 0-9）。</li><li>( sum ): 前缀数字之和（若条件是和为 ( K )）。</li><li>( mod ): 前缀模 ( K )（若条件是 ( K ) 的倍数）。</li><li>( lead ): 是否允许前导零（1: 允许，0: 不允许）。</li></ul></li></ul></li><li><strong>状态转移</strong>：<ul><li>对于第 ( pos ) 位：<ul><li>若 ( tight = 1 )，可选数字 ( d \in [0, \text{digit[pos]}] ).</li><li>若 ( tight = 0 )，可选数字 ( d \in [0, 9] ).</li><li>新状态：<ul><li>( new_tight = 1 ) 若 ( d = \text{digit[pos]} ) 且 ( tight = 1 )，否则 0。</li><li>更新 ( sum, mod, lead ) 等状态。</li></ul></li><li>递归到下一位：<br>[<br>dp[pos][state] = \sum_{d} dp[pos+1][new_state]<br>]</li></ul></li><li>终止条件：<ul><li>( pos = \text{len(digits)} )，检查是否满足条件（如 ( sum = K )）。</li></ul></li></ul></li><li><strong>初始调用</strong>：<ul><li>( solve(0, 1, 0, 1) )，表示从第 0 位开始，贴近上界，无前缀和，允许前导零。</li></ul></li><li><strong>复杂度</strong>：<ul><li>时间：( O(\log R \cdot S) )，其中 ( S ) 是状态数（如 ( 10 \cdot K )）。</li><li>空间：( O(\log R \cdot S) )，记忆化表格。</li></ul></li><li><strong>适用性</strong>：ACM 竞赛标配，适合 ( R \leq 10^{18} )，时间 ≥ 1 秒。</li></ul><h3 id="2.2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" tabindex="-1">2.2 动态规划</h3><ul><li><strong>思路</strong>：<ul><li>将记忆化递归转为递推形式，填充 DP 表格。</li><li>从低位到高位迭代，状态同记忆化。</li></ul></li><li><strong>实现</strong>：<ul><li>较少使用，因数位 DP 通常递归更直观。</li><li>适用场景：状态简单，需显式 DP 表格。</li></ul></li><li><strong>复杂度</strong>：<ul><li>同记忆化递归。</li></ul></li><li><strong>适用性</strong>：调试复杂问题或需显式表格。</li></ul><h3 id="2.3-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D" tabindex="-1">2.3 路径恢复</h3><ul><li><strong>目标</strong>：<ul><li>输出一个或多个满足条件的数字。</li></ul></li><li><strong>方法</strong>：<ul><li>在 DP 过程中记录每个状态的选择（选的数字 ( d )）。</li><li>从 ( dp[0][初始状态] ) 回溯，构造数字。</li></ul></li><li><strong>实现</strong>：<ul><li>用数组 ( choice[pos][state] ) 记录 ( d ).</li><li>回溯构造数字字符串。</li></ul></li><li><strong>复杂度</strong>：<ul><li>时间：( O(\log R \cdot S) )（DP）+ ( O(\log R) )（回溯）。</li><li>空间：( O(\log R \cdot S) ).</li></ul></li><li><strong>适用性</strong>：ACM 题目要求输出数字。</li></ul><h3 id="2.4-%E5%8F%98%E7%A7%8D%E4%B8%8E%E4%BC%98%E5%8C%96" tabindex="-1">2.4 变种与优化</h3><ul><li><strong>模运算</strong>：<ul><li>答案模 ( 10^9+7 ).</li></ul></li><li><strong>前导零</strong>：<ul><li>控制是否允许前导零（常见于严格递增条件）。</li></ul></li><li><strong>状态压缩</strong>：<ul><li>若条件复杂（如 LIS），用位掩码压缩状态。</li></ul></li><li><strong>多条件</strong>：<ul><li>同时满足多个条件（如和为 ( K )，是 ( M ) 的倍数）。</li></ul></li><li><strong>空间优化</strong>：<ul><li>滚动数组或清空记忆化表格，空间降到 ( O(S) ).</li></ul></li></ul><hr><h2 id="3.-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">3. 复杂度分析</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>记忆化递归</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>标准问题，( R \leq 10^{18} )，时间 ≥ 1s</td></tr><tr><td>动态规划</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>调试复杂状态，显式表格</td></tr><tr><td>路径恢复</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>需输出数字，( R \leq 10^{18} )</td></tr></tbody></table><ul><li><strong>时间</strong>：( O(\log R \cdot S) )，( \log R ) 是位数，( S ) 是状态数（例如 ( 10 \cdot K )）。</li><li><strong>空间</strong>：( O(\log R \cdot S) )，可优化到 ( O(S) ).</li><li><strong>ACM 限制</strong>：<ul><li>( R \leq 10^{18} )，位数 ( \leq 18 )，时间 ≥ 1 秒，Python 适用。</li><li>复杂状态（( S \geq 10^6 )）需 C++.</li></ul></li></ul><hr><h2 id="4.-%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">4. 在 ACM 竞赛中的应用</h2><p>数位 DP 是 ACM 竞赛中的核心计数技术，常见于大范围计数、模运算和变种问题。以下是应用场景和解题思路：</p><ol><li><strong>标准数位 DP</strong>：<ul><li><strong>题目</strong>：Codeforces 1036C（Classy Numbers，非零位 ≤ 3）。</li><li><strong>解法</strong>：记忆化递归。</li><li><strong>方法</strong>：<ul><li>状态：( dp[pos][tight][cnt] )，( cnt ) 为非零位数。</li><li>转移：枚举当前位 ( d )，更新 ( cnt ).</li><li>答案：( f® - f(L-1) ).</li><li>复杂度：时间 ( O(\log R \cdot 10 \cdot 4) ).</li></ul></li><li><strong>Python 优势</strong>：字符串和列表操作简洁。</li></ul></li><li><strong>路径恢复</strong>：<ul><li><strong>题目</strong>：SPOJ NDIGITS（输出满足条件的数字）。</li><li><strong>解法</strong>：DP + 路径恢复。</li><li><strong>方法</strong>：<ul><li>DP 计算满足条件的个数。</li><li>记录选择，回溯构造数字。</li><li>复杂度：时间 ( O(\log R \cdot S) ).</li></ul></li><li><strong>Python 优势</strong>：字符串拼接和回溯直观。</li></ul></li><li><strong>变种问题</strong>：<ul><li><strong>模运算</strong>：HDU 3652（B-number，含 13 且被 13 整除）。</li><li><strong>状态压缩</strong>：HDU 4352（XHXJ’s LIS，数位 DP + LIS）。</li><li><strong>多条件</strong>：AtCoder ABC 162F（Digits，多个约束）。</li><li><strong>示例</strong>：Codeforces 628D（Magic Numbers）。</li><li><strong>方法</strong>：扩展状态（如模、模式匹配）。</li><li><strong>Python 优势</strong>：条件判断和多维数组简洁。<br><strong>ACM 优化技巧</strong>：</li></ul></li></ol><ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>模运算</strong>：防止溢出，模 ( 10^9+7 ).</li><li><strong>状态压缩</strong>：用位掩码或整数压缩复杂状态。</li><li><strong>调试</strong>：打印 DP 表格或构造的数字，验证转移。</li><li><strong>边界处理</strong>：注意 ( L=1 )、前导零、紧界。<br><strong>Python 在 ACM 中的适用性</strong>：</li><li><strong>优点</strong>：<ul><li>代码简洁：DP 约 40-60 行，路径恢复 60-80 行，比赛中 10-15 分钟实现。</li><li>调试方便：打印状态或数字，验证正确性。</li><li>适用：( \log R \leq 18 )，状态 ( S \leq 10^5 )，时间 ≥ 1 秒。</li></ul></li><li><strong>缺点</strong>：<ul><li>效率：Python 比 C++ 慢 5-10 倍，复杂状态可能 TLE。</li><li>内存：Python 数组占用较多，需优化。</li></ul></li><li><strong>优化</strong>：<ul><li>快速 I/O：<code>input = sys.stdin.readline</code>.</li><li>滚动数组：空间降到 ( O(S) ).</li><li>Cython/Numba：加速循环（非比赛场景）。<br><strong>ACM 题目推荐</strong>：</li></ul></li><li>Codeforces 1036C：Classy Numbers（非零位 ≤ 3）。</li><li>HDU 3652：B-number（含 13 且被 13 整除）。</li><li>SPOJ NDIGITS：Number of Digits（路径恢复）。</li><li>AtCoder ABC 162F：Digits（多条件）。</li><li>Codeforces 628D：Magic Numbers（模运算）。</li></ul><hr><h2 id="5.-python-%E5%AE%9E%E7%8E%B0" tabindex="-1">5. Python 实现</h2><p>以下通过数位 DP 的两种典型问题（各位之和为 ( K )、路径恢复）提供 Python 实现，带详细注释，适合 ACM 竞赛。代码格式优化以确保在 OneNote 中清晰显示。</p><h3 id="5.1-%E5%90%84%E4%BD%8D%E4%B9%8B%E5%92%8C%E4%B8%BA-k%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%89" tabindex="-1">5.1 各位之和为 K（记忆化递归）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp_sum_k</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">digits: <span class="built_in">list</span>, pos: <span class="built_in">int</span>, tight: <span class="built_in">int</span>, sum_digits: <span class="built_in">int</span>, lead: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum_digits &gt; K:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dp[pos][tight][sum_digits][lead] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[pos][tight][sum_digits][lead]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        limit = digits[pos] <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">            new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">            new_sum = sum_digits + d</span><br><span class="line">            new_lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            ans = (ans + solve(digits, pos + <span class="number">1</span>, new_tight, new_sum, new_lead)) % MOD</span><br><span class="line">        dp[pos][tight][sum_digits][lead] = ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(x)]</span><br><span class="line">        <span class="keyword">global</span> dp</span><br><span class="line">        dp = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> solve(digits, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (count(R) - count(L - <span class="number">1</span>)) % MOD</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Count of numbers with sum of digits =&quot;</span>, K, <span class="string">&quot;:&quot;</span>, digit_dp_sum_k(L, R, K))</span><br></pre></td></tr></table></figure><h3 id="5.2-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D%EF%BC%88%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%89" tabindex="-1">5.2 路径恢复（输出一个满足条件的数字）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp_path</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数，并返回一个数字&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">digits: <span class="built_in">list</span>, pos: <span class="built_in">int</span>, tight: <span class="built_in">int</span>, sum_digits: <span class="built_in">int</span>, lead: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum_digits &gt; K:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dp[pos][tight][sum_digits][lead] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[pos][tight][sum_digits][lead]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        limit = digits[pos] <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">            new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">            new_sum = sum_digits + d</span><br><span class="line">            new_lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            cnt = solve(digits, pos + <span class="number">1</span>, new_tight, new_sum, new_lead)</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">0</span> <span class="keyword">and</span> choice[pos][tight][sum_digits][lead] == -<span class="number">1</span>:</span><br><span class="line">                choice[pos][tight][sum_digits][lead] = d</span><br><span class="line">            ans = (ans + cnt) % MOD</span><br><span class="line">        dp[pos][tight][sum_digits][lead] = ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(x)]</span><br><span class="line">        <span class="keyword">global</span> dp, choice</span><br><span class="line">        dp = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        choice = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> solve(digits, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯构造数字</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">digits: <span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = []</span><br><span class="line">        pos, tight, sum_digits, lead = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(digits):</span><br><span class="line">            d = choice[pos][tight][sum_digits][lead]</span><br><span class="line">            <span class="keyword">if</span> d == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(d))</span><br><span class="line">            tight = tight <span class="keyword">and</span> d == digits[pos]</span><br><span class="line">            sum_digits += d</span><br><span class="line">            lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(result) <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算答案</span></span><br><span class="line">    ans = (count(R) - count(L - <span class="number">1</span>)) % MOD</span><br><span class="line">    digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(R)]</span><br><span class="line">    number = construct(digits)</span><br><span class="line">    <span class="keyword">return</span> ans, number</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">count, number = digit_dp_path(L, R, K)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Count of numbers with sum of digits =&quot;</span>, K, <span class="string">&quot;:&quot;</span>, count)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One such number:&quot;</span>, number <span class="keyword">if</span> number <span class="keyword">else</span> <span class="string">&quot;None&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="6.-%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B" tabindex="-1">6. 运行过程</h2><h3 id="%E8%BE%93%E5%85%A5" tabindex="-1">输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 100 5</span><br></pre></td></tr></table></figure><ul><li>( L = 1, R = 100, K = 5 )</li><li>条件：各位之和为 5。</li></ul><h3 id="6.1-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92" tabindex="-1">6.1 记忆化递归</h3><ul><li><strong>计算 ( f(100) )</strong>：<ul><li>数字：( [1, 0, 0] )，3 位。</li><li>初始：( solve(0, 1, 0, 1) ).</li><li>( pos=0, tight=1, sum=0, lead=1 ):<ul><li>( d=0 ): ( solve(1, 1, 0, 1) ).</li><li>( d=1 ): ( solve(1, 1, 1, 0) ).</li><li>( d=2 ): ( solve(1, 0, 2, 0) ).</li><li>…</li></ul></li><li>( pos=3 ): 检查 ( sum == 5 ).</li><li>结果：6（14, 23, 32, 41, 50, 5）。</li></ul></li><li><strong>计算 ( f(0) )</strong>：<ul><li>结果：0（无数字）。</li></ul></li><li><strong>答案</strong>：( f(100) - f(0) = 6 - 0 = 6 ).</li><li><strong>Space</strong>：( O(\log R \cdot 10 \cdot K) = O(3 \cdot 2 \cdot 6) ).<br><strong>Output</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count of numbers with sum of digits = 5 : 6</span><br></pre></td></tr></table></figure><h3 id="6.2-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D" tabindex="-1">6.2 路径恢复</h3><ul><li><strong>DP 和 choice 表格</strong>：<ul><li>同记忆化，( f(100) = 6 ).</li><li>( choice[0][1][0][1] = 1 )（选 1）。</li><li>( choice[1][1][1][0] = 4 )（选 4）。</li></ul></li><li><strong>回溯</strong>：<ul><li>( pos=0, tight=1, sum=0, lead=1 ): ( d=1 ).</li><li>( pos=1, tight=1, sum=1, lead=0 ): ( d=4 ).</li><li>( pos=2 ): ( sum=5 )，结束。</li><li>结果：( 14 ).</li></ul></li><li><strong>答案</strong>：个数 6，数字 14（可能不同，如 23）。</li><li><strong>Space</strong>：( O(\log R \cdot 10 \cdot K) ).<br><strong>Output</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Count of numbers with sum of digits = 5 : 6</span><br><span class="line">One such number: 14</span><br></pre></td></tr></table></figure><hr><h2 id="7.-%E6%95%B0%E4%BD%8D-dp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1">7. 数位 DP 的优缺点</h2><h3 id="7.1-%E4%BC%98%E7%82%B9" tabindex="-1">7.1 优点</h3><ul><li><strong>高效计数</strong>：( O(\log R \cdot S) )，适合 ( R \leq 10^{18} ).</li><li><strong>灵活状态</strong>：支持多种条件（如和、模、模式）。</li><li><strong>ACM 友好</strong>：Python 实现约 40-80 行，比赛中 10-15 分钟完成。</li><li><strong>调试方便</strong>：打印状态或构造数字，验证正确性。</li><li><strong>路径恢复</strong>：可输出满足条件的数字。</li></ul><h3 id="7.2-%E7%BC%BA%E7%82%B9" tabindex="-1">7.2 缺点</h3><ul><li><strong>状态设计复杂</strong>：需根据条件设计状态（如模、LIS）。</li><li><strong>空间需求</strong>：( O(\log R \cdot S) )，大状态数超内存。</li><li><strong>ACM 限制</strong>：<ul><li>复杂状态（( S \geq 10^6 )）需 C++.</li><li>路径恢复增加实现难度。</li></ul></li><li><strong>边界处理</strong>：<ul><li>注意 ( L=1 )、前导零、紧界。</li></ul></li></ul><h3 id="7.3-%E6%94%B9%E8%BF%9B%E6%96%B9%E5%90%91" tabindex="-1">7.3 改进方向</h3><ul><li><strong>空间优化</strong>：滚动数组，空间降到 ( O(S) ).</li><li><strong>状态压缩</strong>：用位掩码或整数压缩。</li><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code>.</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）.</li><li><strong>预处理</strong>：常见条件预计算（如模表）。</li></ul><hr><h2 id="8.-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">8. 与其他问题的对比</h2><ul><li><strong>数位 DP vs 子集和</strong>：<ul><li>数位 DP：逐位构造，范围计数。</li><li>子集和：组合优化，存在性.</li></ul></li><li><strong>数位 DP vs 布尔括号</strong>：<ul><li>数位 DP：数字位计数。</li><li>布尔括号：区间 DP，逻辑计数.</li></ul></li><li><strong>数位 DP vs 矩阵链乘法</strong>：<ul><li>数位 DP：计数问题。</li><li>矩阵链乘法：优化代价.</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>数位 DP：大范围计数。</li><li>子集和：背包 DP。</li><li>布尔括号：区间 DP。</li><li>矩阵链乘法：区间 DP。</li></ul></li></ul><hr><h2 id="9.-%E6%80%BB%E7%BB%93" tabindex="-1">9. 总结</h2><p>数位 DP 是解决大范围数字计数问题的强大工具，通过逐位构造和动态规划高效统计：</p><ul><li><strong>核心方法</strong>：<ul><li>记忆化递归：时间 ( O(\log R \cdot S) )，ACM 标配。</li><li>路径恢复：输出满足条件的数字。</li></ul></li><li><strong>ACM 应用</strong>：<ul><li>标准计数（Codeforces 1036C）。</li><li>路径恢复（SPOJ NDIGITS）。</li><li>变种（HDU 4352）。</li></ul></li><li><strong>Python 实现</strong>：约 40-80 行，比赛中 10-15 分钟，适合 ( \log R \leq 18 )，时间 ≥ 1 秒。</li><li><strong>优化</strong>：模运算、快速 I/O、状态压缩。<br>通过记忆化递归和路径恢复的 Python 代码及模拟，展示了数位 DP 的实现和运行过程。在 ACM 竞赛中，数位 DP 是处理大范围计数的核心技术，Python 实现简洁高效。<br><strong>学习建议</strong>：</li></ul><ol><li><strong>手动模拟</strong>：<ul><li>用小数据（如 ( R=20, K=5 )）手动构造数字，验证状态转移。</li></ul></li><li><strong>ACM 练习</strong>：<ul><li>Codeforces 1036C、HDU 3652、SPOJ NDIGITS，用 Python 实现。</li></ul></li><li><strong>深入扩展</strong>：<ul><li>学习状态压缩（HDU 4352）、多条件、模运算。</li></ul></li><li><strong>比赛策略</strong>：<ul><li>优先实现记忆化递归，验证正确性。</li><li>若需数字，添加路径恢复。</li><li>若时间严格，考虑 C++.</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dp%EF%BC%89%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>yolo</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/yolo/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/yolo/</id>
    <published>2025-09-13T13:57:08.000Z</published>
    <updated>2025-09-13T14:01:34.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B" tabindex="-1">使用 Ultralytics YOLO 进行模型预测</h1><h2 id="%E7%AE%80%E4%BB%8B" tabindex="-1">简介</h2><p>在<strong>机器学习</strong>和<strong>计算机视觉</strong>领域，对视觉数据进行理解处理的过程称为“推理”（‘inference’）或“预测”（‘prediction’）。Ultralytics YOLO11 提供了一项强大的功能，即<strong>预测模式</strong>，专为对各种数据源进行高性能、实时推理而量身定制。</p><h2 id="%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" tabindex="-1">实际应用</h2><table><thead><tr><th style="text-align:center">制造业</th><th style="text-align:center">体育</th><th style="text-align:center">安全</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">汽车备件检测</td><td style="text-align:center">足球运动员检测</td><td style="text-align:center">人员跌倒检测</td></tr></tbody></table><h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%EF%BC%9F" tabindex="-1">为什么选择 Ultralytics YOLO 进行推理？</h2><p>以下是你应该考虑将 YOLO11 的预测模式用于各种推理需求的原因：</p><ul><li><strong>多功能性</strong>：能够对图像、视频甚至直播流进行推理。</li><li><strong>性能</strong>：专为实时、高速处理而设计，同时不牺牲<strong>准确性</strong>。</li><li><strong>易用性</strong>：直观的 Python 和 CLI 界面，可实现快速部署和测试。</li><li><strong>高度可定制</strong>：提供各种设置和参数，以根据你的特定要求调整模型的推理行为。</li></ul><h3 id="%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD" tabindex="-1">预测模式的关键功能</h3><p>YOLO11 的预测模式设计得既稳健又通用，具备以下特点：</p><ul><li><strong>多数据源兼容性</strong>：无论你的数据是单个图像、一系列图像、视频文件还是实时视频流，预测模式都能处理。</li><li><strong>流式处理模式</strong>：使用流式处理功能可以生成一个内存高效的 <code>Results</code> 对象生成器。通过在预测器的调用方法中设置 <code>stream=True</code> 来启用此功能。</li><li><strong>批量处理</strong>：能够一次性处理多张图像或视频帧，进一步加快推理时间。</li><li><strong>易于集成</strong>：由于其灵活的 API，可以轻松集成到现有的数据管道和其他软件组件中。</li></ul><p>Ultralytics YOLO 模型在推理时，如果传递了 <code>stream=True</code>，则返回一个内存高效的 <code>Results</code> 对象生成器；否则，返回一个 <code>Results</code> 对象列表。</p><p>!!! example “预测”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">=== &quot;使用 `stream=False` 返回列表&quot;</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)  # 预训练的 YOLO11n 模型</span><br><span class="line"></span><br><span class="line">    # 对图像列表进行批量推理</span><br><span class="line">    results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;])  # 返回一个 Results 对象列表</span><br><span class="line"></span><br><span class="line">    # 处理结果列表</span><br><span class="line">    for result in results:</span><br><span class="line">        boxes = result.boxes  # 用于边界框输出的 Boxes 对象</span><br><span class="line">        masks = result.masks  # 用于分割掩码输出的 Masks 对象</span><br><span class="line">        keypoints = result.keypoints  # 用于姿态输出的 Keypoints 对象</span><br><span class="line">        probs = result.probs  # 用于分类输出的 Probs 对象</span><br><span class="line">        obb = result.obb  # 用于 OBB 输出的定向框对象</span><br><span class="line">        result.show()  # 显示到屏幕</span><br><span class="line">        result.save(filename=&quot;result.jpg&quot;)  # 保存到磁盘</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;使用 `stream=True` 返回生成器&quot;</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)  # 预训练的 YOLO11n 模型</span><br><span class="line"></span><br><span class="line">    # 对图像列表进行批量推理</span><br><span class="line">    results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;], stream=True)  # 返回一个 Results 对象生成器</span><br><span class="line"></span><br><span class="line">    # 处理结果生成器</span><br><span class="line">    for result in results:</span><br><span class="line">        boxes = result.boxes  # 用于边界框输出的 Boxes 对象</span><br><span class="line">        masks = result.masks  # 用于分割掩码输出的 Masks 对象</span><br><span class="line">        keypoints = result.keypoints  # 用于姿态输出的 Keypoints 对象</span><br><span class="line">        probs = result.probs  # 用于分类输出的 Probs 对象</span><br><span class="line">        obb = result.obb  # 用于 OBB 输出的定向框对象</span><br><span class="line">        result.show()  # 显示到屏幕</span><br><span class="line">        result.save(filename=&quot;result.jpg&quot;)  # 保存到磁盘</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure><h2 id="%E6%8E%A8%E7%90%86%E6%BA%90" tabindex="-1">推理源</h2><p>YOLO11 可以处理不同类型的输入源进行推理，如下表所示。来源包括静态图像、视频流和各种数据格式。该表还指出每个源是否可以使用参数 <code>stream=True</code> 在流式处理模式下使用 ✅。流式处理模式对于处理视频或直播流很有用，因为它会创建一个结果生成器，而不是将所有帧都加载到内存中。</p><p>!!! tip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 `stream=True` 来处理长视频或大型数据集，以高效地管理内存。当 `stream=False` 时，所有帧或数据点的结果都存储在内存中，这可能很快累积并导致大型输入出现内存不足错误。相比之下，`stream=True` 使用生成器，它只将当前帧或数据点的结果保存在内存中，从而显著减少内存消耗并防止内存不足问题。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">源</th><th style="text-align:left">示例</th><th style="text-align:left">类型</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">图像</td><td style="text-align:left"><code>'image.jpg'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">单个图像文件。</td></tr><tr><td style="text-align:left">URL</td><td style="text-align:left"><code>'https://ultralytics.com/images/bus.jpg'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">图像的 URL。</td></tr><tr><td style="text-align:left">截图</td><td style="text-align:left"><code>'screen'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">捕获屏幕截图。</td></tr><tr><td style="text-align:left">PIL</td><td style="text-align:left"><code>Image.open('image.jpg')</code></td><td style="text-align:left"><code>PIL.Image</code></td><td style="text-align:left">HWC 格式，带有 RGB 通道。</td></tr><tr><td style="text-align:left"><strong>OpenCV</strong></td><td style="text-align:left"><code>cv2.imread('image.jpg')</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">HWC 格式，带有 BGR 通道 <code>uint8 (0-255)</code>。</td></tr><tr><td style="text-align:left">numpy</td><td style="text-align:left"><code>np.zeros((640,1280,3))</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">HWC 格式，带有 BGR 通道 <code>uint8 (0-255)</code>。</td></tr><tr><td style="text-align:left">torch</td><td style="text-align:left"><code>torch.zeros(16,3,320,640)</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">BCHW 格式，带有 RGB 通道 <code>float32 (0.0-1.0)</code>。</td></tr><tr><td style="text-align:left">CSV</td><td style="text-align:left"><code>'sources.csv'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">包含图像、视频或目录路径的 CSV 文件。</td></tr><tr><td style="text-align:left">视频 ✅</td><td style="text-align:left"><code>'video.mp4'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">格式为 MP4、AVI 等的视频文件。</td></tr><tr><td style="text-align:left">目录 ✅</td><td style="text-align:left"><code>'path/'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">包含图像或视频的目录路径。</td></tr><tr><td style="text-align:left">glob ✅</td><td style="text-align:left"><code>'path/*.jpg'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">用于匹配多个文件的 glob 模式。使用 <code>*</code> 字符作为通配符。</td></tr><tr><td style="text-align:left">YouTube ✅</td><td style="text-align:left"><code>'https://youtu.be/LNwODJXcvt4'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">YouTube 视频的 URL。</td></tr><tr><td style="text-align:left">流 ✅</td><td style="text-align:left"><code>'rtsp://example.com/media.mp4'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">用于 RTSP、RTMP、TCP 等流媒体协议或 IP 地址的 URL。</td></tr><tr><td style="text-align:left">多流 ✅</td><td style="text-align:left"><code>'list.streams'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left"><code>.streams</code> 文本文件，每行一个流 URL，即 8 个流将以批量大小 8 运行。</td></tr><tr><td style="text-align:left">摄像头 ✅</td><td style="text-align:left"><code>0</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">连接的摄像头设备的索引，用于运行推理。</td></tr></tbody></table><p>以下是使用每种源类型的代码示例：</p><p>!!! example “预测源”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">=== &quot;图像&quot;</span><br><span class="line"></span><br><span class="line">    对图像文件运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义图像文件路径</span><br><span class="line">    source = &quot;path/to/image.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;截图&quot;</span><br><span class="line"></span><br><span class="line">    将当前屏幕内容作为截图运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义当前截图为源</span><br><span class="line">    source = &quot;screen&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;URL&quot;</span><br><span class="line"></span><br><span class="line">    对通过 URL 远程托管的图像或视频运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义远程图像或视频 URL</span><br><span class="line">    source = &quot;https://ultralytics.com/images/bus.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;PIL&quot;</span><br><span class="line"></span><br><span class="line">    对使用 Python Imaging Library (PIL) 打开的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from PIL import Image</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用 PIL 打开图像</span><br><span class="line">    source = Image.open(&quot;path/to/image.jpg&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;OpenCV&quot;</span><br><span class="line"></span><br><span class="line">    对使用 OpenCV 读取的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import cv2</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用 OpenCV 读取图像</span><br><span class="line">    source = cv2.imread(&quot;path/to/image.jpg&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;numpy&quot;</span><br><span class="line"></span><br><span class="line">    对表示为 numpy 数组的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import numpy as np</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建一个 HWC 形状 (640, 640, 3)，值范围 [0, 255]，类型为 uint8 的随机 numpy 数组</span><br><span class="line">    source = np.random.randint(low=0, high=255, size=(640, 640, 3), dtype=&quot;uint8&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;torch&quot;</span><br><span class="line"></span><br><span class="line">    对表示为 **PyTorch** 张量的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import torch</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建一个 BCHW 形状 (1, 3, 640, 640)，值范围 [0, 1]，类型为 float32 的随机 torch 张量</span><br><span class="line">    source = torch.rand(1, 3, 640, 640, dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;CSV&quot;</span><br><span class="line"></span><br><span class="line">    对 CSV 文件中列出的图像、URL、视频和目录集合运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义一个包含图像、URL、视频和目录的 CSV 文件的路径</span><br><span class="line">    source = &quot;path/to/file.csv&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;视频&quot;</span><br><span class="line"></span><br><span class="line">    对视频文件运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少内存使用。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义视频文件路径</span><br><span class="line">    source = &quot;path/to/video.mp4&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;目录&quot;</span><br><span class="line"></span><br><span class="line">    对目录中的所有图像和视频运行推理。若要同时捕获子目录中的图像和视频，请使用 glob 模式，例如 `path/to/dir/**/*`。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义包含用于推理的图像和视频的目录路径</span><br><span class="line">    source = &quot;path/to/dir&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;glob&quot;</span><br><span class="line"></span><br><span class="line">    对所有与带有 `*` 字符的 glob 表达式匹配的图像和视频运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义一个 glob 搜索，以查找目录中的所有 JPG 文件</span><br><span class="line">    source = &quot;path/to/dir/*.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 或者定义一个递归 glob 搜索，以查找包括子目录在内的所有 JPG 文件</span><br><span class="line">    source = &quot;path/to/dir/**/*.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;YouTube&quot;</span><br><span class="line"></span><br><span class="line">    对 YouTube 视频运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少长视频的内存使用。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义源为 YouTube 视频 URL</span><br><span class="line">    source = &quot;https://youtu.be/LNwODJXcvt4&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;流&quot;</span><br><span class="line"></span><br><span class="line">    使用流模式通过 RTSP、RTMP、TCP 或 IP 地址协议对直播流进行推理。如果提供单个流，模型将以**批量大小**为 1 运行推理。对于多个流，可以使用 `.streams` 文本文件执行批量推理，其中批量大小由提供的流数量决定（例如，8 个流的批量大小为 8）。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 批量大小为 1 的单个流推理</span><br><span class="line">    source = &quot;rtsp://example.com/media.mp4&quot;  # RTSP、RTMP、TCP 或 IP 流地址</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    对于单个流使用，批量大小默认为 1，从而实现对视频流的高效实时处理。</span><br><span class="line"></span><br><span class="line">=== &quot;多流&quot;</span><br><span class="line"></span><br><span class="line">    要同时处理多个视频流，请使用包含流源的 `.streams` 文本文件。模型将运行批量推理，其中批量大小等于流的数量。此设置可实现对多个视频流的并发高效处理。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 多个流进行批量推理（例如，8 个流的批量大小为 8）</span><br><span class="line">    source = &quot;path/to/list.streams&quot;  # *.streams 文本文件，每行一个流地址</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    `.streams` 文本文件示例：</span><br><span class="line"></span><br><span class="line">    ```text</span><br><span class="line">    rtsp://example.com/media1.mp4</span><br><span class="line">    rtsp://example.com/media2.mp4</span><br><span class="line">    rtmp://example2.com/live</span><br><span class="line">    tcp://192.168.1.100:554</span><br><span class="line">    ...</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    文件中的每一行都代表一个流源，让你能够同时监控和对多个视频流进行推理。</span><br><span class="line"></span><br><span class="line">=== &quot;摄像头&quot;</span><br><span class="line"></span><br><span class="line">    你可以通过传递特定摄像头的索引来对连接的摄像头设备运行推理。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source=0, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure><h2 id="%E6%8E%A8%E7%90%86%E5%8F%82%E6%95%B0" tabindex="-1">推理参数</h2><p><code>model.predict()</code> 接受多个参数，这些参数可以在推理时传递以覆盖默认值：</p><p>!!! example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对 &#x27;bus.jpg&#x27; 运行推理，并带有参数</span><br><span class="line">model.predict(&quot;https://ultralytics.com/images/bus.jpg&quot;, save=True, imgsz=320, conf=0.5)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>推理参数：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>source</code></td><td style="text-align:left"><code>str, int, Path</code></td><td style="text-align:left"><code>'ultralytics.com/images/bus.jpg'</code></td><td style="text-align:left">输入源的路径。可以是文件、目录、URL、视频或 RTMP 流。</td></tr><tr><td style="text-align:left"><code>model</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left"><code>'yolov11n.pt'</code></td><td style="text-align:left">要运行推理的模型文件的路径。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>0.25</code></td><td style="text-align:left">对象置信度阈值。</td></tr><tr><td style="text-align:left"><code>iou</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>0.7</code></td><td style="text-align:left">边界框交并比 (IoU) 阈值，用于非最大抑制 (NMS)。</td></tr><tr><td style="text-align:left"><code>imgsz</code></td><td style="text-align:left"><code>int</code> 或 <code>tuple</code></td><td style="text-align:left"><code>640</code></td><td style="text-align:left">输入图像的大小，可以是单个整数（正方形）或 (高度, 宽度) 元组。</td></tr><tr><td style="text-align:left"><code>half</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">如果 GPU 可用，则使用 FP16 半精度推理。</td></tr><tr><td style="text-align:left"><code>device</code></td><td style="text-align:left"><code>int</code> 或 <code>str</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">要使用的设备（例如 <code>cuda:0</code> 或 <code>0,1,2,3</code> 或 <code>cpu</code>）。</td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否在屏幕上显示结果。</td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否将预测结果保存到文件中。</td></tr><tr><td style="text-align:left"><code>save_txt</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否将预测结果以 <code>.txt</code> 格式保存。</td></tr><tr><td style="text-align:left"><code>save_conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否在保存的标签中包含置信度分数。</td></tr><tr><td style="text-align:left"><code>save_crop</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否保存裁剪后的预测结果。</td></tr><tr><td style="text-align:left"><code>hide_labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否隐藏预测标签。</td></tr><tr><td style="text-align:left"><code>hide_conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否隐藏预测置信度分数。</td></tr><tr><td style="text-align:left"><code>max_det</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>300</code></td><td style="text-align:left">每张图像的最大检测数量。</td></tr><tr><td style="text-align:left"><code>vid_stride</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>1</code></td><td style="text-align:left">视频帧步长。</td></tr><tr><td style="text-align:left"><code>stream_buffer</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否缓冲流帧。</td></tr><tr><td style="text-align:left"><code>line_thickness</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>2</code></td><td style="text-align:left">边界框的线条粗细（以像素为单位）。</td></tr><tr><td style="text-align:left"><code>visualize</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">在模型推理期间可视化模型特征。</td></tr><tr><td style="text-align:left"><code>augment</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">在推理时应用图像增强（测试时增强）。</td></tr><tr><td style="text-align:left"><code>agnostic_nms</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">执行类别无关的非最大抑制（NMS）。</td></tr><tr><td style="text-align:left"><code>retina_masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">使用高分辨率分割掩码。</td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>True</code></td><td style="text-align:left">是否在结果中显示边界框。</td></tr></tbody></table><p>可视化参数：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含检测置信度分数。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>line_width</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">边界框的线条宽度。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font_size</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">文本字体大小。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">文本注释的字体名称。</td><td style="text-align:left"><code>'Arial.ttf'</code></td></tr><tr><td style="text-align:left"><code>pil</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将图像作为 PIL Image 对象返回。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">用于绘图的替代图像。如果为 <code>None</code>，则使用原始图像。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>im_gpu</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>kpt_radius</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">绘制的关键点的半径。</td><td style="text-align:left"><code>5</code></td></tr><tr><td style="text-align:left"><code>kpt_line</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">用线条连接关键点。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在注释中包含类别标签。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加边界框。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加掩码。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含分类概率。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">使用默认图像查看器直接显示带注释的图像。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将带注释的图像保存到由 <code>filename</code> 指定的文件。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>filename</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">如果 <code>save</code> 为 <code>True</code>，则为保存带注释的图像的文件路径和名称。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>color_mode</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">指定颜色模式，例如 ‘instance’ 或 ‘class’。</td><td style="text-align:left"><code>'class'</code></td></tr><tr><td style="text-align:left"><code>txt_color</code></td><td style="text-align:left"><code>tuple[int, int, int]</code></td><td style="text-align:left">边界框和图像分类标签的 RGB 文本颜色。</td><td style="text-align:left"><code>(255, 255, 255)</code></td></tr></tbody></table><h2 id="%E5%9B%BE%E5%83%8F%E5%92%8C%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F" tabindex="-1">图像和视频格式</h2><p>YOLO11 支持多种图像和视频格式，具体请参见 <a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/utils.py">ultralytics/data/utils.py</a>。下表列出了有效的后缀和预测命令示例。</p><h3 id="%E5%9B%BE%E5%83%8F" tabindex="-1">图像</h3><p>下表包含有效的 Ultralytics 图像格式。</p><p>!!! note</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEIC 图像仅支持推理，不支持训练。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">图像后缀</th><th style="text-align:left">预测命令示例</th><th style="text-align:left">参考</th></tr></thead><tbody><tr><td style="text-align:left"><code>.bmp</code></td><td style="text-align:left"><code>yolo predict source=image.bmp</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/BMP_file_format">Microsoft BMP 文件格式</a></td></tr><tr><td style="text-align:left"><code>.dng</code></td><td style="text-align:left"><code>yolo predict source=image.dng</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Digital_Negative">Adobe DNG</a></td></tr><tr><td style="text-align:left"><code>.jpeg</code></td><td style="text-align:left"><code>yolo predict source=image.jpeg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a></td></tr><tr><td style="text-align:left"><code>.jpg</code></td><td style="text-align:left"><code>yolo predict source=image.jpg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a></td></tr><tr><td style="text-align:left"><code>.mpo</code></td><td style="text-align:left"><code>yolo predict source=image.mpo</code></td><td style="text-align:left"><a href="https://fileinfo.com/extension/mpo">多图片对象</a></td></tr><tr><td style="text-align:left"><code>.png</code></td><td style="text-align:left"><code>yolo predict source=image.png</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/PNG">便携式网络图形</a></td></tr><tr><td style="text-align:left"><code>.tif</code></td><td style="text-align:left"><code>yolo predict source=image.tif</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/TIFF">标签图像文件格式</a></td></tr><tr><td style="text-align:left"><code>.tiff</code></td><td style="text-align:left"><code>yolo predict source=image.tiff</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/TIFF">标签图像文件格式</a></td></tr><tr><td style="text-align:left"><code>.webp</code></td><td style="text-align:left"><code>yolo predict source=image.webp</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/WebP">WebP</a></td></tr><tr><td style="text-align:left"><code>.pfm</code></td><td style="text-align:left"><code>yolo predict source=image.pfm</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Netpbm#File_formats">便携式浮点地图</a></td></tr><tr><td style="text-align:left"><code>.HEIC</code></td><td style="text-align:left"><code>yolo predict source=image.HEIC</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/HEIF">高效图像文件格式</a></td></tr></tbody></table><h3 id="%E8%A7%86%E9%A2%91" tabindex="-1">视频</h3><p>下表包含有效的 Ultralytics 视频格式。</p><table><thead><tr><th style="text-align:left">视频后缀</th><th style="text-align:left">预测命令示例</th><th style="text-align:left">参考</th></tr></thead><tbody><tr><td style="text-align:left"><code>.asf</code></td><td style="text-align:left"><code>yolo predict source=video.asf</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Advanced_Systems_Format">高级系统格式</a></td></tr><tr><td style="text-align:left"><code>.avi</code></td><td style="text-align:left"><code>yolo predict source=video.avi</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">音频视频交错</a></td></tr><tr><td style="text-align:left"><code>.gif</code></td><td style="text-align:left"><code>yolo predict source=video.gif</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/GIF">图形交换格式</a></td></tr><tr><td style="text-align:left"><code>.m4v</code></td><td style="text-align:left"><code>yolo predict source=video.m4v</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/M4V">MPEG-4 Part 14</a></td></tr><tr><td style="text-align:left"><code>.mkv</code></td><td style="text-align:left"><code>yolo predict source=video.mkv</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Matroska">Matroska</a></td></tr><tr><td style="text-align:left"><code>.mov</code></td><td style="text-align:left"><code>yolo predict source=video.mov</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/QuickTime_File_Format">QuickTime 文件格式</a></td></tr><tr><td style="text-align:left"><code>.mp4</code></td><td style="text-align:left"><code>yolo predict source=video.mp4</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MPEG-4 Part 14 - Wikipedia</a></td></tr><tr><td style="text-align:left"><code>.mpeg</code></td><td style="text-align:left"><code>yolo predict source=video.mpeg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-1">MPEG-1 Part 2</a></td></tr><tr><td style="text-align:left"><code>.mpg</code></td><td style="text-align:left"><code>yolo predict source=video.mpg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-1">MPEG-1 Part 2</a></td></tr><tr><td style="text-align:left"><code>.ts</code></td><td style="text-align:left"><code>yolo predict source=video.ts</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG_transport_stream">MPEG 传输流</a></td></tr><tr><td style="text-align:left"><code>.wmv</code></td><td style="text-align:left"><code>yolo predict source=video.wmv</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Windows_Media_Video">Windows Media Video</a></td></tr><tr><td style="text-align:left"><code>.webm</code></td><td style="text-align:left"><code>yolo predict source=video.webm</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/WebM">WebM 项目</a></td></tr></tbody></table><h2 id="%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C" tabindex="-1">处理结果</h2><p>所有 Ultralytics 的 <code>predict()</code> 调用都将返回一个 <code>Results</code> 对象列表：</p><p>!!! example “结果”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)</span><br><span class="line">results = model(</span><br><span class="line">    [</span><br><span class="line">        &quot;https://ultralytics.com/images/bus.jpg&quot;,</span><br><span class="line">        &quot;https://ultralytics.com/images/zidane.jpg&quot;,</span><br><span class="line">    ]</span><br><span class="line">)  # 批量推理</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><code>Results</code> 对象具有以下属性：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>orig_img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">作为 numpy 数组的原始图像。</td></tr><tr><td style="text-align:left"><code>orig_shape</code></td><td style="text-align:left"><code>tuple</code></td><td style="text-align:left">原始图像形状，格式为 (高度, 宽度)。</td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>Boxes, optional</code></td><td style="text-align:left">包含检测边界框的 Boxes 对象。</td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>Masks, optional</code></td><td style="text-align:left">包含检测掩码的 Masks 对象。</td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>Probs, optional</code></td><td style="text-align:left">包含用于分类任务的每个类别的概率的 Probs 对象。</td></tr><tr><td style="text-align:left"><code>keypoints</code></td><td style="text-align:left"><code>Keypoints, optional</code></td><td style="text-align:left">包含每个对象检测到的关键点的 Keypoints 对象。</td></tr><tr><td style="text-align:left"><code>obb</code></td><td style="text-align:left"><code>OBB, optional</code></td><td style="text-align:left">包含定向边界框的 OBB 对象。</td></tr><tr><td style="text-align:left"><code>speed</code></td><td style="text-align:left"><code>dict</code></td><td style="text-align:left">字典，包含每个图像的预处理、推理和后处理速度（以毫秒为单位）。</td></tr><tr><td style="text-align:left"><code>names</code></td><td style="text-align:left"><code>dict</code></td><td style="text-align:left">将类别索引映射到类别名称的字典。</td></tr><tr><td style="text-align:left"><code>path</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">图像文件路径。</td></tr><tr><td style="text-align:left"><code>save_dir</code></td><td style="text-align:left"><code>str, optional</code></td><td style="text-align:left">保存结果的目录。</td></tr></tbody></table><p><code>Results</code> 对象具有以下方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">返回类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>update()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">使用新的检测数据（框、掩码、概率、OBB、关键点）更新 <code>Results</code> 对象。</td></tr><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已移动到 GPU 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，其中张量已移动到指定的设备和数据类型。</td></tr><tr><td style="text-align:left"><code>new()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">创建一个具有相同图像、路径、名称和速度属性的新 <code>Results</code> 对象。</td></tr><tr><td style="text-align:left"><code>plot()</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">在输入的 RGB 图像上绘制检测结果并返回带注释的图像。</td></tr><tr><td style="text-align:left"><code>show()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">显示带有注释的推理结果图像。</td></tr><tr><td style="text-align:left"><code>save()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将带有注释的推理结果图像保存到文件并返回文件名。</td></tr><tr><td style="text-align:left"><code>verbose()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">返回每个任务的日志字符串，详细说明检测和分类结果。</td></tr><tr><td style="text-align:left"><code>save_txt()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果保存到文本文件并返回保存文件的路径。</td></tr><tr><td style="text-align:left"><code>save_crop()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">将裁剪后的检测图像保存到指定的目录。</td></tr><tr><td style="text-align:left"><code>summary()</code></td><td style="text-align:left"><code>List[Dict[str, Any]]</code></td><td style="text-align:left">将推理结果转换为摘要字典，并可选择进行归一化。</td></tr><tr><td style="text-align:left"><code>to_df()</code></td><td style="text-align:left"><code>DataFrame</code></td><td style="text-align:left">将检测结果转换为 Polars DataFrame。</td></tr><tr><td style="text-align:left"><code>to_csv()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果转换为 CSV 格式。</td></tr><tr><td style="text-align:left"><code>to_json()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果转换为 JSON 格式。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md"><code>Results</code> 类文档</a>。</p><h3 id="boxes" tabindex="-1">Boxes</h3><p><code>Boxes</code> 对象可用于索引、操作和将边界框转换为不同格式。</p><p>!!! example “Boxes”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.boxes)  # 打印包含检测边界框的 Boxes 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Boxes</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CUDA 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到指定的设备。</td></tr><tr><td style="text-align:left"><code>xyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回框。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的置信度值。</td></tr><tr><td style="text-align:left"><code>cls</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的类别值。</td></tr><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的跟踪 ID（如果可用）。</td></tr><tr><td style="text-align:left"><code>xywh</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywh 格式返回框。</td></tr><tr><td style="text-align:left"><code>xyxyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回归一化后的框（通过原始图像大小）。</td></tr><tr><td style="text-align:left"><code>xywhn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywh 格式返回归一化后的框（通过原始图像大小）。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Boxes"><code>Boxes</code> 类文档</a>。</p><h3 id="masks" tabindex="-1">Masks</h3><p><code>Masks</code> 对象可用于索引、操作和将掩码转换为段。</p><p>!!! example “Masks”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-seg 分割模型</span><br><span class="line">model = YOLO(&quot;yolo11n-seg.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.masks)  # 打印包含检测到的实例掩码的 Masks 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Masks</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回掩码张量。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将掩码张量作为 numpy 数组返回。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回掩码张量。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的掩码张量。</td></tr><tr><td style="text-align:left"><code>xyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的归一化段列表。</td></tr><tr><td style="text-align:left"><code>xy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的像素坐标中的段列表。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Masks"><code>Masks</code> 类文档</a>。</p><h3 id="keypoints" tabindex="-1">Keypoints</h3><p><code>Keypoints</code> 对象可用于索引、操作和归一化坐标。</p><p>!!! example “Keypoints”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-pose 姿态模型</span><br><span class="line">model = YOLO(&quot;yolo11n-pose.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.keypoints)  # 打印包含检测到的关键点的 Keypoints 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Keypoints</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回关键点张量。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将关键点张量作为 numpy 数组返回。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回关键点张量。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的关键点张量。</td></tr><tr><td style="text-align:left"><code>xyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的归一化关键点列表。</td></tr><tr><td style="text-align:left"><code>xy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的像素坐标中的关键点列表。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">如果可用，返回关键点的置信度值，否则为 <code>None</code>。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Keypoints"><code>Keypoints</code> 类文档</a>。</p><h3 id="probs" tabindex="-1">Probs</h3><p><code>Probs</code> 对象可用于索引，获取分类的 <code>top1</code> 和 <code>top5</code> 索引和分数。</p><p>!!! example “Probs”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-cls 分类模型</span><br><span class="line">model = YOLO(&quot;yolo11n-cls.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.probs)  # 打印包含检测到的类别概率的 Probs 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表总结了 <code>Probs</code> 类的方法和属性：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回概率张量的副本。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将概率张量作为 numpy 数组返回副本。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回概率张量的副本。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的概率张量的副本。</td></tr><tr><td style="text-align:left"><code>top1</code></td><td style="text-align:left">属性 (<code>int</code>)</td><td style="text-align:left">top 1 类别的索引。</td></tr><tr><td style="text-align:left"><code>top5</code></td><td style="text-align:left">属性 (<code>list[int]</code>)</td><td style="text-align:left">top 5 类别的索引。</td></tr><tr><td style="text-align:left"><code>top1conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">top 1 类别的置信度。</td></tr><tr><td style="text-align:left"><code>top5conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">top 5 类别的置信度。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Probs"><code>Probs</code> 类文档</a>。</p><h3 id="obb" tabindex="-1">OBB</h3><p><code>OBB</code> 对象可用于索引、操作和将定向边界框转换为不同格式。</p><p>!!! example “OBB”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n-obb.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/boats.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.obb)  # 打印包含定向检测边界框的 OBB 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>OBB</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CUDA 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到指定的设备。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的置信度值。</td></tr><tr><td style="text-align:left"><code>cls</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的类别值。</td></tr><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的跟踪 ID（如果可用）。</td></tr><tr><td style="text-align:left"><code>xyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回水平框。</td></tr><tr><td style="text-align:left"><code>xywhr</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywhr 格式返回旋转框。</td></tr><tr><td style="text-align:left"><code>xyxyxyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxyxyxy 格式返回旋转框。</td></tr><tr><td style="text-align:left"><code>xyxyxyxyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxyxyxy 格式返回归一化后的旋转框（通过图像大小）。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.OBB"><code>OBB</code> 类文档</a>。</p><h2 id="%E7%BB%98%E5%88%B6%E7%BB%93%E6%9E%9C" tabindex="-1">绘制结果</h2><p><code>Results</code> 对象中的 <code>plot()</code> 方法通过在原始图像上叠加检测到的对象（如边界框、掩码、关键点和概率）来方便可视化预测。此方法将带注释的图像作为 NumPy 数组返回，便于显示或保存。</p><p>!!! example “绘图”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对 &#x27;bus.jpg&#x27; 运行推理</span><br><span class="line">results = model([&quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;])  # 结果列表</span><br><span class="line"></span><br><span class="line"># 可视化结果</span><br><span class="line">for i, r in enumerate(results):</span><br><span class="line">    # 绘制结果图像</span><br><span class="line">    im_bgr = r.plot()  # BGR 顺序的 numpy 数组</span><br><span class="line">    im_rgb = Image.fromarray(im_bgr[..., ::-1])  # RGB 顺序的 PIL 图像</span><br><span class="line"></span><br><span class="line">    # 将结果显示到屏幕（在支持的环境中）</span><br><span class="line">    r.show()</span><br><span class="line"></span><br><span class="line">    # 将结果保存到磁盘</span><br><span class="line">    r.save(filename=f&quot;results&#123;i&#125;.jpg&quot;)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h3 id="plot()-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" tabindex="-1"><code>plot()</code> 方法参数</h3><p><code>plot()</code> 方法支持各种参数来自定义输出：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含检测置信度分数。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>line_width</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">边界框的线条宽度。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font_size</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">文本字体大小。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">文本注释的字体名称。</td><td style="text-align:left"><code>'Arial.ttf'</code></td></tr><tr><td style="text-align:left"><code>pil</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将图像作为 PIL Image 对象返回。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">用于绘图的替代图像。如果为 <code>None</code>，则使用原始图像。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>im_gpu</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>kpt_radius</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">绘制的关键点的半径。</td><td style="text-align:left"><code>5</code></td></tr><tr><td style="text-align:left"><code>kpt_line</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">用线条连接关键点。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在注释中包含类别标签。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加边界框。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加掩码。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含分类概率。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">使用默认图像查看器直接显示带注释的图像。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将带注释的图像保存到由 <code>filename</code> 指定的文件。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>filename</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">如果 <code>save</code> 为 <code>True</code>，则为保存带注释的图像的文件路径和名称。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>color_mode</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">指定颜色模式，例如 ‘instance’ 或 ‘class’。</td><td style="text-align:left"><code>'class'</code></td></tr><tr><td style="text-align:left"><code>txt_color</code></td><td style="text-align:left"><code>tuple[int, int, int]</code></td><td style="text-align:left">边界框和图像分类标签的 RGB 文本颜色。</td><td style="text-align:left"><code>(255, 255, 255)</code></td></tr></tbody></table><h2 id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%8E%A8%E7%90%86" tabindex="-1">线程安全推理</h2><p>当你在不同线程中并行运行多个 YOLO 模型时，确保推理的线程安全至关重要。线程安全推理可确保每个线程的预测是隔离的，并且不会相互干扰，从而避免竞态条件并确保一致且可靠的输出。</p><p>在多线程应用程序中使用 YOLO 模型时，为每个线程实例化单独的模型对象或采用线程本地存储以防止冲突非常重要：</p><p>!!! example “线程安全推理”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在每个线程内实例化一个模型，以实现线程安全推理：</span><br><span class="line">```python</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def thread_safe_predict(model, image_path):</span><br><span class="line">    &quot;&quot;&quot;使用本地实例化的 YOLO 模型对图像执行线程安全预测。&quot;&quot;&quot;</span><br><span class="line">    model = YOLO(model)</span><br><span class="line">    results = model.predict(image_path)</span><br><span class="line">    # 处理结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动每个线程都有自己模型实例的线程</span><br><span class="line">Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image1.jpg&quot;)).start()</span><br><span class="line">Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image2.jpg&quot;)).start()</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>要深入了解 YOLO 模型的线程安全推理和分步说明，请参阅我们的 <a href="https://www.google.com/search?q=../guides/yolo-thread-safe-inference.md">YOLO 线程安全推理指南</a>。本指南将为你提供所有必要的信息，以避免常见陷阱并确保你的多线程推理顺利运行。</p><h2 id="%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E6%BA%90-for-%E5%BE%AA%E7%8E%AF" tabindex="-1">流式处理源 <code>for</code> 循环</h2><p>这是一个使用 OpenCV (<code>cv2</code>) 和 YOLO 对视频帧运行推理的 Python 脚本。该脚本假设你已安装所需的包（<code>opencv-python</code> 和 <code>ultralytics</code>）。</p><p>!!! example “流式处理 for 循环”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载 YOLO 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 打开视频文件</span><br><span class="line">video_path = &quot;path/to/your/video/file.mp4&quot;</span><br><span class="line">cap = cv2.VideoCapture(video_path)</span><br><span class="line"></span><br><span class="line"># 循环遍历视频帧</span><br><span class="line">while cap.isOpened():</span><br><span class="line">    # 从视频中读取一帧</span><br><span class="line">    success, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    if success:</span><br><span class="line">        # 在帧上运行 YOLO 推理</span><br><span class="line">        results = model(frame)</span><br><span class="line"></span><br><span class="line">        # 在帧上可视化结果</span><br><span class="line">        annotated_frame = results[0].plot()</span><br><span class="line"></span><br><span class="line">        # 显示带注释的帧</span><br><span class="line">        cv2.imshow(&quot;YOLO Inference&quot;, annotated_frame)</span><br><span class="line"></span><br><span class="line">        # 如果按下 &#x27;q&#x27; 键，则中断循环</span><br><span class="line">        if cv2.waitKey(1) &amp; 0xFF == ord(&quot;q&quot;):</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        # 如果到达视频末尾，则中断循环</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># 释放视频捕获对象并关闭显示窗口</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>该脚本将在视频的每一帧上运行预测，可视化结果，并在窗口中显示它们。可以通过按 ‘q’ 键退出循环。</p><h2 id="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-(faq)" tabindex="-1">常见问题 (FAQ)</h2><h3 id="%E4%BB%80%E4%B9%88%E6%98%AF-ultralytics-yolo-%E5%8F%8A%E5%85%B6%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E6%8E%A8%E7%90%86%E7%9A%84%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F" tabindex="-1">什么是 Ultralytics YOLO 及其用于实时推理的预测模式？</h3><p>Ultralytics YOLO 是一种用于实时<strong>目标检测</strong>、分割和分类的最新模型。其<strong>预测模式</strong>允许用户对各种数据源（如图像、视频和直播流）执行高速推理。它专为性能和多功能性而设计，还提供批量处理和流式处理模式。有关其功能的更多详细信息，请查看 <a href="https://www.google.com/search?q=%23%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD">Ultralytics YOLO 预测模式</a>。</p><h3 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%90%E8%A1%8C%E6%8E%A8%E7%90%86%EF%BC%9F" tabindex="-1">如何使用 Ultralytics YOLO 对不同的数据源运行推理？</h3><p>Ultralytics YOLO 可以处理各种数据源，包括单个图像、视频、目录、URL 和流。你可以在 <code>model.predict()</code> 调用中指定数据源。例如，对于本地图像，使用 <code>'image.jpg'</code>；对于 URL，使用 <code>'https://ultralytics.com/images/bus.jpg'</code>。请查看文档中关于各种<strong>推理源</strong>的详细示例。</p><h3 id="%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-yolo-%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F" tabindex="-1">如何优化 YOLO 推理速度和内存使用？</h3><p>要优化推理速度并高效管理内存，你可以通过在预测器的调用方法中设置 <code>stream=True</code> 来使用流式处理模式。流式处理模式会生成一个内存高效的 <code>Results</code> 对象生成器，而不是将所有帧加载到内存中。对于处理长视频或大型数据集，流式处理模式特别有用。了解有关<strong>流式处理模式</strong>的更多信息。</p><h3 id="ultralytics-yolo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%8E%A8%E7%90%86%E5%8F%82%E6%95%B0%EF%BC%9F" tabindex="-1">Ultralytics YOLO 支持哪些推理参数？</h3><p>YOLO 中的 <code>model.predict()</code> 方法支持各种参数，例如 <code>conf</code>、<code>iou</code>、<code>imgsz</code>、<code>device</code> 等。这些参数允许你自定义推理过程，设置置信度阈值、图像大小和用于计算的设备等参数。这些参数的详细说明可以在<strong>推理参数</strong>部分找到。</p><h3 id="%E5%A6%82%E4%BD%95%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E4%BF%9D%E5%AD%98-yolo-%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C%EF%BC%9F" tabindex="-1">如何可视化和保存 YOLO 预测结果？</h3><p>使用 YOLO 运行推理后，<code>Results</code> 对象包含用于显示和保存带注释图像的方法。你可以使用 <code>result.show()</code> 和 <code>result.save(filename=&quot;result.jpg&quot;)</code> 等方法来可视化和保存结果。有关这些方法的完整列表，请参阅<strong>处理结果</strong>部分。</p><p>[]: #<br>[]: #<br>[]: #</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B&quot; tabindex=&quot;-1&quot;&gt;使用 Ultralytics YOLO 进行模型预测</summary>
      
    
    
    
    
    <category term="文档、库" scheme="https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2025-09-13T12:57:08.000Z</published>
    <updated>2025-09-13T13:37:52.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1.-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%9F" tabindex="-1">1. 什么是线段树？</h3><p>线段树是一种<strong>二叉树</strong>数据结构，用于存储区间（或称为“线段”）的信息，并支持快速的查询和更新操作。它特别适合解决与区间相关的动态问题，例如：</p><ul><li>求某个区间的和。</li><li>查找某个区间的最大值或最小值。</li><li>对某个区间进行批量更新。<br>线段树的核心思想是将一个大区间递归地划分成多个小子区间，并通过树形结构高效地维护和查询这些区间的聚合信息。</li></ul><hr><h3 id="2.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84" tabindex="-1">2. 线段树的结构</h3><p>线段树的结构可以用以下方式描述：</p><ul><li><strong>节点</strong>：每个节点代表一个区间。</li><li><strong>根节点</strong>：代表整个区间（例如数组的范围[1, n]）。</li><li><strong>叶子节点</strong>：代表单个元素（例如数组中的某个值）。</li><li><strong>中间节点</strong>：代表某个子区间（介于根节点和叶子节点之间）。<br>例如，对于一个数组<code>[1, 3, 5, 7, 9, 11]</code>，线段树的结构如下：</li><li>根节点表示区间<code>[1, 6]</code>。</li><li>根的左子节点表示<code>[1, 3]</code>，右子节点表示<code>[4, 6]</code>。</li><li>进一步划分后，叶子节点分别表示<code>[1, 1]</code>、<code>[2, 2]</code>、<code>[3, 3]</code>、<code>[4, 4]</code>、<code>[5, 5]</code>和<code>[6, 6]</code>。<br>这种递归划分的方式使得线段树能够高效地处理区间问题。</li></ul><hr><h3 id="3.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" tabindex="-1">3. 线段树的基本操作</h3><p>线段树主要支持以下两种核心操作：</p><h4 id="%E6%9F%A5%E8%AF%A2%EF%BC%88query%EF%BC%89" tabindex="-1"><strong>查询（Query）</strong></h4><p>查询操作用于获取某个区间的聚合信息，例如：</p><ul><li>区间的和。</li><li>区间的最大值或最小值。</li></ul><h4 id="%E6%9B%B4%E6%96%B0%EF%BC%88update%EF%BC%89" tabindex="-1"><strong>更新（Update）</strong></h4><p>更新操作用于修改数据，例如：</p><ul><li>修改单个元素的值（单点更新）。</li><li>对某个区间的元素进行批量修改（区间更新）。<br>这两种操作的时间复杂度均为<strong>O(log n)</strong>，其中<code>n</code>是数组的大小。这是对数级别的高效性使得线段树非常适合动态查询问题。</li></ul><hr><h3 id="4.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA" tabindex="-1">4. 线段树的构建</h3><p>线段树的构建是一个递归过程，通常自底向上完成。以下是构建线段树的基本步骤：</p><ol><li><strong>从根节点开始</strong>：根节点表示整个区间，例如<code>[1, n]</code>。</li><li><strong>划分区间</strong>：将当前区间划分为两个子区间，例如<code>[1, mid]</code>和<code>[mid+1, n]</code>，其中<code>mid = (left + right) / 2</code>。</li><li><strong>递归构建子树</strong>：对左子区间和右子区间分别递归构建子树，直到达到叶子节点。</li><li><strong>合并信息</strong>：在回溯时，根据具体问题将子节点的信息合并到当前节点。例如，对于区间求和问题，当前节点的值是左子节点和右子节点值的和。<br><strong>示例</strong>：<br>对于数组<code>[1, 3, 5, 7, 9, 11]</code>：</li></ol><ul><li>根节点存储<code>[1, 6]</code>的和：<code>1 + 3 + 5 + 7 + 9 + 11 = 36</code>。</li><li>左子节点存储<code>[1, 3]</code>的和：<code>1 + 3 + 5 = 9</code>。</li><li>右子节点存储<code>[4, 6]</code>的和：<code>7 + 9 + 11 = 27</code>。</li><li>递归继续，直到叶子节点存储单个元素。</li></ul><hr><h3 id="5.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9F%A5%E8%AF%A2" tabindex="-1">5. 线段树的查询</h3><p>查询操作同样是递归进行的，用于在O(log n)时间内获取某个区间的聚合信息。查询步骤如下：</p><ol><li><strong>判断当前区间与查询区间的关系</strong>：<ul><li><strong>完全包含</strong>：如果当前区间完全在查询区间内，直接返回当前节点的值。</li><li><strong>无交集</strong>：如果当前区间与查询区间无重叠，返回一个不影响结果的值（例如求和时返回0，求最大值时返回负无穷）。</li><li><strong>部分重叠</strong>：递归查询左子树和右子树，并合并结果。</li></ul></li><li><strong>合并结果</strong>：根据具体问题合并子查询的结果。例如，求和时将左右子树的结果相加。<br><strong>示例</strong>：<br>查询数组<code>[1, 3, 5, 7, 9, 11]</code>中区间<code>[2, 5]</code>的和：</li></ol><ul><li>根节点<code>[1, 6]</code>与<code>[2, 5]</code>部分重叠，递归查询子节点。</li><li>左子节点<code>[1, 3]</code>与<code>[2, 5]</code>部分重叠，继续递归，最终得到<code>[2, 3]</code>的和<code>3 + 5 = 8</code>。</li><li>右子节点<code>[4, 6]</code>与<code>[2, 5]</code>部分重叠，最终得到<code>[4, 5]</code>的和<code>7 + 9 = 16</code>。</li><li>合并结果：<code>8 + 16 = 24</code>。</li></ul><hr><h3 id="6.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9B%B4%E6%96%B0" tabindex="-1">6. 线段树的更新</h3><p>更新操作分为两种类型：</p><h4 id="%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0" tabindex="-1"><strong>单点更新</strong></h4><p>修改数组中某个元素的值，并更新线段树中所有相关节点：</p><ol><li>递归找到对应的叶子节点。</li><li>更新叶子节点的值。</li><li>回溯时，更新所有包含该叶子节点的父节点。<br><strong>示例</strong>：<br>将数组<code>[1, 3, 5, 7, 9, 11]</code>中的第2个元素从3改为10：</li></ol><ul><li>找到叶子节点<code>[2, 2]</code>，更新值为10。</li><li>向上更新：<code>[1, 3]</code>的和从9变为<code>1 + 10 + 5 = 16</code>，根节点<code>[1, 6]</code>的和从36变为<code>43</code>。</li></ul><h4 id="%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0" tabindex="-1"><strong>区间更新</strong></h4><p>对某个区间的元素进行批量修改，例如将区间<code>[2, 4]</code>的所有值增加5。通常使用**延迟标记（Lazy Propagation）**优化，避免直接更新所有叶子节点：</p><ul><li>在需要更新的节点上记录延迟标记。</li><li>在下次查询或更新时，将标记传播到子节点。</li></ul><hr><h3 id="7.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" tabindex="-1">7. 线段树的空间复杂度</h3><h2 id="%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%91%E4%BC%BC%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%8A%82%E7%82%B9%E6%80%BB%E6%95%B0%E7%BA%A6%E4%B8%BA2n-1%EF%BC%8C%E5%9B%A0%E6%AD%A4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAo(n)%EF%BC%8C%E5%85%B6%E4%B8%ADn%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82" tabindex="-1">线段树是一个近似满二叉树，节点总数约为<code>2n-1</code>，因此空间复杂度为<strong>O(n)</strong>，其中<code>n</code>是数组的大小。</h2><h3 id="8.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">8. 线段树的应用</h3><p>线段树在算法问题中有广泛应用，包括但不限于：</p><ul><li><strong>区间求和</strong>：计算任意区间的和。</li><li><strong>区间最值</strong>：查找任意区间的最大值或最小值。</li><li><strong>区间更新</strong>：对某个区间批量加减一个值。</li><li><strong>动态规划优化</strong>：加速某些状态转移。</li></ul><hr><h3 id="9.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9" tabindex="-1">9. 线段树的优点与缺点</h3><h4 id="%E4%BC%98%E7%82%B9" tabindex="-1"><strong>优点</strong></h4><ul><li>查询和更新时间复杂度均为<strong>O(log n)</strong>，高效处理动态问题。</li><li>灵活性强，可根据问题定制功能。</li></ul><h4 id="%E7%BC%BA%E7%82%B9" tabindex="-1"><strong>缺点</strong></h4><ul><li>实现相对复杂，代码量较大。</li><li>空间消耗较高，需要额外的O(n)存储。</li></ul><hr><h3 id="9.-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91" tabindex="-1">9. 手动实现线段树</h3><p>由于 Python 标准库和主流第三方库中没有直接提供线段树，开发者通常会根据问题需求手动实现。以下是一个简单的 Python 线段树实现，用于支持<strong>区间求和</strong>和<strong>单点更新</strong>，并包含详细注释以便理解。</p><h4 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91" tabindex="-1">代码实现：区间求和线段树</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化线段树，arr 是输入数组&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(arr)  <span class="comment"># 数组长度</span></span><br><span class="line">        <span class="variable language_">self</span>.tree = [<span class="number">0</span>] * (<span class="number">4</span> * <span class="variable language_">self</span>.n)  <span class="comment"># 线段树数组，4n 足以容纳所有节点</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = arr  <span class="comment"># 保存原始数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>._build(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>)  <span class="comment"># 递归构建线段树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归构建线段树，node 是当前节点，[start, end] 是当前区间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="comment"># 叶子节点，直接存储数组元素</span></span><br><span class="line">            <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.arr[start]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        <span class="variable language_">self</span>._build(left_node, start, mid)</span><br><span class="line">        <span class="variable language_">self</span>._build(right_node, mid + <span class="number">1</span>, end)</span><br><span class="line">        <span class="comment"># 合并子节点信息：当前节点存储左右子节点的和</span></span><br><span class="line">        <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.tree[left_node] + <span class="variable language_">self</span>.tree[right_node]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;单点更新：将 arr[index] 更新为 value&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.arr[index] = value</span><br><span class="line">        <span class="variable language_">self</span>._update(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>, index, value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span>, index: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归更新线段树，index 是要更新的位置，value 是新值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="comment"># 叶子节点，直接更新</span></span><br><span class="line">            <span class="variable language_">self</span>.tree[node] = value</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span></span><br><span class="line">        <span class="comment"># 递归更新左子树或右子树</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= mid:</span><br><span class="line">            <span class="variable language_">self</span>._update(left_node, start, mid, index, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>._update(right_node, mid + <span class="number">1</span>, end, index, value)</span><br><span class="line">        <span class="comment"># 合并更新后的子节点信息</span></span><br><span class="line">        <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.tree[left_node] + <span class="variable language_">self</span>.tree[right_node]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询区间 [left, right] 的和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._query(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>, left, right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_query</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归查询 [left, right] 的和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= start <span class="keyword">and</span> end &lt;= right:</span><br><span class="line">            <span class="comment"># 当前区间完全包含在查询区间内，直接返回节点值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.tree[node]</span><br><span class="line">        <span class="keyword">if</span> right &lt; start <span class="keyword">or</span> left &gt; end:</span><br><span class="line">            <span class="comment"># 当前区间与查询区间无交集，返回 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span></span><br><span class="line">        <span class="comment"># 递归查询左右子树，并合并结果</span></span><br><span class="line">        left_sum = <span class="variable language_">self</span>._query(left_node, start, mid, left, right)</span><br><span class="line">        right_sum = <span class="variable language_">self</span>._query(right_node, mid + <span class="number">1</span>, end, left, right)</span><br><span class="line">        <span class="keyword">return</span> left_sum + right_sum</span><br><span class="line"><span class="comment"># 测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始数组</span></span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">    seg_tree = SegmentTree(arr)</span><br><span class="line">    <span class="comment"># 测试查询</span></span><br><span class="line">    <span class="built_in">print</span>(seg_tree.query(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 查询 [1, 3] 的和：3 + 5 + 7 = 15</span></span><br><span class="line">    <span class="comment"># 测试更新</span></span><br><span class="line">    seg_tree.update(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># 将 arr[1] 从 3 更新为 10</span></span><br><span class="line">    <span class="built_in">print</span>(seg_tree.query(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 查询 [1, 3] 的和：10 + 5 + 7 = 22</span></span><br></pre></td></tr></table></figure><hr><h4 id="%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E" tabindex="-1">代码说明</h4><ol><li><strong>初始化 (<code>__init__</code>)</strong>：<ul><li>创建线段树数组 <code>tree</code>，大小为 <code>4n</code>（足以容纳所有节点）。</li><li>调用 <code>_build</code> 递归构建线段树，存储每个区间的和。</li></ul></li><li><strong>构建 (<code>_build</code>)</strong>：<ul><li>递归划分区间，直到叶子节点。</li><li>叶子节点存储原始数组元素，中间节点存储子节点和。</li></ul></li><li><strong>更新 (<code>update</code> 和 <code>_update</code>)</strong>：<ul><li>单点更新：递归找到对应的叶子节点，更新值。</li><li>回溯时更新所有相关父节点的和。</li></ul></li><li><strong>查询 (<code>query</code> 和 <code>_query</code>)</strong>：<ul><li>查询区间 <code>[left, right]</code> 的和。</li><li>递归处理三种情况：完全包含、无交集、部分重叠。</li></ul></li><li><strong>时间复杂度</strong>：<ul><li>构建：( O(n) )</li><li>查询：( O(\log n) )</li><li>更新：( O(\log n) )</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>( O(n) )，线段树需要 ( 4n ) 的空间。</li></ul></li></ol><hr><h3 id="10.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%EF%BC%88%E9%9C%80%E8%A6%81%E6%97%B6%E5%8F%AF%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%EF%BC%89" tabindex="-1">10. 线段树的高级功能（需要时可扩展实现）</h3><p>手动实现的线段树可以根据问题需求扩展，以下是常见的高级功能：</p><ol><li><strong>区间更新（Lazy Propagation）</strong>：<ul><li>支持对整个区间批量修改（如将 <code>[l, r]</code> 的值增加一个常数）。</li><li>使用延迟标记（lazy tag）记录未传播的更新，减少时间开销。</li><li>适用场景：动态修改大范围数据。</li></ul></li><li><strong>区间最值</strong>：<ul><li>修改线段树存储最大值或最小值，而不是和。</li><li>例如，查询 <code>[l, r]</code> 的最大值，只需将合并操作从 <code>+</code> 改为 <code>max</code>。</li></ul></li><li><strong>动态线段树</strong>：<ul><li>支持动态添加或删除节点，适用于数据范围不确定的场景。</li><li>实现较复杂，通常结合指针或动态分配。</li></ul></li><li><strong>持久化线段树</strong>：<ul><li>保留线段树的历史版本，支持查询历史状态。</li><li>常用于函数式编程或需要回溯的问题。</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1.-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;1. 什么是线段树？&lt;/h3&gt;
&lt;p&gt;线段树是一种&lt;strong&gt;二叉树&lt;/strong&gt;数据结构，</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2025-09-13T11:16:41.000Z</published>
    <updated>2025-09-14T04:36:12.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-dp%EF%BC%89%E6%98%AF%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E5%85%B7%E6%9C%89-%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98-%E5%92%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84-%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E3%80%82%E5%AE%83%E9%80%9A%E8%BF%87%E5%B0%86%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3%E4%B8%BA%E8%BE%83%E5%B0%8F%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AD%98%E5%82%A8%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E4%BB%A5%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%AB%98%E6%95%88%E6%B1%82%E8%A7%A3%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B-%E4%B8%AD%EF%BC%8Cdp-%E6%98%AF%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7%EF%BC%8C%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97%E3%80%81%E5%9B%BE%E3%80%81%E6%A0%91%E3%80%81%E8%83%8C%E5%8C%85%E3%80%81%E5%8C%BA%E9%97%B4%E7%AD%89%E9%97%AE%E9%A2%98%E3%80%82" tabindex="-1">动态规划（Dynamic Programming，简称 DP）是算法设计中的一种重要方法，用于解决具有 <strong>重叠子问题</strong> 和 <strong>最优子结构</strong> 的优化问题。它通过将问题分解为较小的子问题，存储子问题的解以避免重复计算，从而高效求解复杂问题。在 <strong>ACM 竞赛</strong> 中，DP 是核心技巧，广泛应用于序列、图、树、背包、区间等问题。</h2><h2 id="1.-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">1. 动态规划的基本概念</h2><h3 id="1.1-%E5%AE%9A%E4%B9%89" tabindex="-1">1.1 定义</h3><p>动态规划是一种通过 <strong>分阶段</strong> 解决问题的方法，每个阶段的决策依赖于前几个阶段的解。DP 的核心思想是：</p><ul><li><strong>分解问题</strong>：将原问题分解为若干子问题。</li><li><strong>存储中间结果</strong>：用表格（数组或哈希表）保存子问题的解，避免重复计算。</li><li><strong>递归求解</strong>：通过子问题的解递归构建原问题的解。<br>DP 通常用于求解 <strong>最优化问题</strong>（如最大值、最小值、最短路径）或 <strong>计数问题</strong>（如方案数），其适用条件包括：</li><li><strong>最优子结构</strong>：原问题的最优解可由子问题的最优解构成。</li><li><strong>重叠子问题</strong>：子问题在递归分解中被多次求解，适合存储优化。</li><li><strong>无后效性</strong>：当前阶段的决策只依赖于之前阶段的状态，不受后续决策影响。<br><strong>示例</strong>：</li><li><strong>斐波那契数列</strong>：第 ( n ) 项 ( F(n) = F(n-1) + F(n-2) )，子问题重叠，直接递归效率低，DP 存储中间结果优化。</li><li><strong>最长公共子序列（LCS）</strong>：字符串 ( A ) 和 ( B ) 的 LCS 依赖于前缀的 LCS，具有最优子结构。</li></ul><h3 id="1.2-%E5%85%B3%E9%94%AE%E6%80%A7%E8%B4%A8" tabindex="-1">1.2 关键性质</h3><ul><li><strong>状态（State）</strong>：用变量表示子问题的解，通常是数组或多维表格，如 ( dp[i] ) 表示前 ( i ) 项的最优解。</li><li><strong>状态转移方程（Transition）</strong>：描述如何从已知状态推导新状态，如 ( dp[i] = \max(dp[i-1], dp[i-2]) )。</li><li><strong>初始条件（Base Case）</strong>：DP 表格的起点，如 ( dp[0] = 0 )。</li><li><strong>目标</strong>：最终求解的状态，如 ( dp[n] )。</li><li><strong>时间复杂度</strong>：通常为 ( O(\text{状态数} \times \text{转移复杂度}) ).</li><li><strong>空间复杂度</strong>：取决于状态存储，通常为 ( O(\text{状态数}) )，可通过滚动数组优化。</li></ul><h3 id="1.3-dp-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB" tabindex="-1">1.3 DP 与其他方法的区别</h3><ul><li><strong>与递归（Recursion）</strong>：<ul><li>递归直接分解问题，可能重复计算子问题（指数复杂度）。</li><li>DP 存储子问题解（通常多项式复杂度）。</li></ul></li><li><strong>与分治（Divide and Conquer）</strong>：<ul><li>分治将问题分为独立子问题（如归并排序）。</li><li>DP 处理重叠子问题，子问题间有依赖。</li></ul></li><li><strong>与贪心（Greedy）</strong>：<ul><li>贪心基于局部最优，适用于特定问题（如活动选择）。</li><li>DP 考虑全局最优，适用范围更广（如 0-1 背包）。</li></ul></li></ul><h3 id="1.4-dp-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4" tabindex="-1">1.4 DP 的设计步骤</h3><ol><li><strong>定义状态</strong>：确定 ( dp[i][j]… ) 表示什么，通常与子问题相关。</li><li><strong>推导状态转移方程</strong>：分析当前状态如何由前几个状态得出。</li><li><strong>确定初始条件</strong>：初始化边界状态（如 ( dp[0][0] )。</li><li><strong>计算顺序</strong>：确保状态按依赖顺序计算（自底向上或记忆化递归）。</li><li><strong>求解目标</strong>：输出最终状态（如 ( dp[n][m] \）。</li><li><strong>优化空间</strong>：若状态只依赖前几行/列，用滚动数组减少空间。</li></ol><h3 id="1.5-%E5%B8%B8%E8%A7%81-dp-%E7%B1%BB%E5%9E%8B" tabindex="-1">1.5 常见 DP 类型</h3><ol><li><strong>线性 DP</strong>：状态沿一维序列转移，如斐波那契、LIS（最长递增子序列）。</li><li><strong>背包 DP</strong>：处理资源分配，如 0-1 背包、完全背包。</li><li><strong>区间 DP</strong>：处理区间合并或分割，如石子合并、括号匹配。</li><li><strong>树形 DP</strong>：在树上进行状态转移，如树的最小支配集。</li><li><strong>状态压缩 DP</strong>：用二进制表示状态，适合小规模集合问题。</li><li><strong>数位 DP</strong>：处理数字范围内的计数问题，如数字和。</li><li><strong>概率/期望 DP</strong>：计算概率或期望值，如博弈问题。</li><li><strong>多维 DP</strong>：处理多变量状态，如 LCS、编辑距离。</li></ol><h3 id="1.6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">1.6 应用场景</h3><ul><li><strong>ACM 竞赛</strong>：<ul><li>序列问题：LIS、LCS、编辑距离。</li><li>背包问题：0-1 背包、完全背包、多重背包。</li><li>区间问题：石子合并、区间调度。</li><li>树上问题：树形 DP、最小点覆盖。</li><li>图上问题：最短路径、DAG 上的 DP。</li></ul></li><li><strong>实际应用</strong>：<ul><li>机器学习：隐马尔可夫模型（HMM）、Viterbi 算法。</li><li>运筹学：资源分配、调度优化。</li><li>生物信息学：序列比对。</li></ul></li></ul><h3 id="1.7-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">1.7 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：( O(\text{状态数} \times \text{转移复杂度}) )。<ul><li>例：LCS 为 ( O(n \times m) )，状态数 ( n \times m )，转移 ( O(1) )。</li></ul></li><li><strong>空间复杂度</strong>：( O(\text{状态数}) )，可通过滚动数组优化到 ( O(\text{较小维度}) )。</li><li><strong>记忆化递归</strong>：与递推等价，适合状态空间稀疏或难以确定计算顺序。</li></ul><hr><h2 id="2.-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95" tabindex="-1">2. 动态规划的编程方法</h2><p>DP 的实现方式主要分为 <strong>递推（Bottom-Up）</strong> 和 <strong>记忆化递归（Top-Down）</strong>，以下详细讲解两种方法的特点和实现步骤。</p><h3 id="2.1-%E9%80%92%E6%8E%A8%EF%BC%88bottom-up%EF%BC%89" tabindex="-1">2.1 递推（Bottom-Up）</h3><ul><li><strong>特点</strong>：<ul><li>自底向上计算，从初始状态递推到目标状态。</li><li>使用循环填充 DP 表格，适合状态空间连续。</li><li>空间效率高，易于优化（如滚动数组）。</li></ul></li><li><strong>步骤</strong>：<ol><li>定义 DP 数组（如 ( dp[i][j] )）。</li><li>初始化边界条件。</li><li>按状态依赖顺序循环，计算状态转移。</li><li>返回目标状态。</li></ol></li><li><strong>适用场景</strong>：状态空间明确，计算顺序简单（如线性 DP、背包 DP）。</li><li><strong>优点</strong>：<ul><li>避免递归开销，运行效率高。</li><li>易于调试，状态计算顺序清晰。</li></ul></li><li><strong>缺点</strong>：<ul><li>状态空间稀疏时可能浪费计算。</li><li>复杂状态转移可能难以推导。<br><strong>示例</strong>：0-1 背包问题</li></ul></li><li>问题：给定 ( n ) 个物品，重量 ( w[i] )，价值 ( v[i] )，背包容量 ( W )，求最大价值。</li><li>状态：( dp[i][j] ) 表示前 ( i ) 个物品，容量 ( j ) 时的最大价值。</li><li>转移：( dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) )（若 ( j \geq w[i] )）。</li><li>初始：( dp[0][j] = 0 )，( dp[i][0] = 0 )。</li><li>目标：( dp[n][W] ).</li></ul><h3 id="2.2-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%88top-down%EF%BC%89" tabindex="-1">2.2 记忆化递归（Top-Down）</h3><ul><li><strong>特点</strong>：<ul><li>自顶向下递归，从目标状态分解到子问题。</li><li>使用记忆化（Memoization）存储已计算的子问题解。</li><li>适合状态空间稀疏或状态转移复杂。</li></ul></li><li><strong>步骤</strong>：<ol><li>定义递归函数，参数表示状态。</li><li>创建记忆化表格（如字典或数组）。</li><li>在递归中检查是否已计算，若是返回缓存结果。</li><li>计算状态转移，存储结果。</li></ol></li><li><strong>适用场景</strong>：状态空间不规则、递归关系复杂（如树形 DP、数位 DP）。</li><li><strong>优点</strong>：<ul><li>代码直观，递归逻辑易于理解。</li><li>仅计算用到的状态，适合稀疏问题。</li></ul></li><li><strong>缺点</strong>：<ul><li>递归栈开销大，可能导致栈溢出。</li><li>Python 递归深度有限，需调整或转为递推。<br><strong>示例</strong>：最长公共子序列（LCS）</li></ul></li><li>问题：给定字符串 ( A ) 和 ( B )，求最长公共子序列长度。</li><li>状态：( dp[i][j] ) 表示 ( A[0:i] ) 和 ( B[0:j] ) 的 LCS 长度。</li><li>转移：<ul><li>若 ( A[i-1] == B[j-1] )，则 ( dp[i][j] = dp[i-1][j-1] + 1 )。</li><li>否则，( dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) )。</li></ul></li><li>初始：( dp[0][j] = 0 )，( dp[i][0] = 0 ).</li><li>目标：( dp[|A|][|B|] ).</li></ul><h3 id="2.3-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96" tabindex="-1">2.3 空间优化</h3><ul><li><strong>滚动数组</strong>：<ul><li>若状态只依赖前几行/列，用小数组覆盖大数组。</li><li>例：0-1 背包从 ( dp[n][W] ) 优化到 ( dp[W] )，空间 ( O(W) ).</li></ul></li><li><strong>状态压缩</strong>：<ul><li>用位运算表示状态，适合状态压缩 DP。</li><li>例：TSP（旅行商问题），状态从 ( O(n \times 2^n) ) 压缩到 ( O(2^n) ).</li></ul></li><li><strong>稀疏存储</strong>：<ul><li>用字典或哈希表存储非零状态，适合记忆化递归。</li></ul></li></ul><h3 id="2.4-%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96" tabindex="-1">2.4 调试与优化</h3><ul><li><strong>调试</strong>：<ul><li>打印 DP 表格，验证状态转移。</li><li>检查边界条件和初始值。</li><li>用小数据手动模拟，确保逻辑正确。</li></ul></li><li><strong>优化</strong>：<ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>常数优化</strong>：减少循环内操作，如提前计算常量。</li><li><strong>并行化</strong>：复杂 DP 可分块并行（非比赛场景）。</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）。</li></ul></li></ul><hr><h2 id="3.-%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">3. 在 ACM 竞赛中的应用</h2><p>DP 在 ACM 竞赛中是解决优化和计数问题的核心工具，因其 <strong>通用性</strong> 和 <strong>高效性</strong> 广泛应用于各种题型。以下是常见类型和解题思路：</p><ol><li><strong>线性 DP</strong>：<ul><li><strong>题目</strong>：求序列的最优解，如最长递增子序列（LIS）。</li><li><strong>解法</strong>：定义 ( dp[i] ) 为以 ( i ) 结尾的最优解，转移考虑前序状态。</li><li><strong>示例</strong>：Luogu P1020（导弹拦截，LIS）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i] ) 表示以 ( a[i] ) 结尾的 LIS 长度。</li><li>转移：( dp[i] = \max(dp[j]) + 1 )，其中 ( j &lt; i )，( a[j] &lt; a[i] ).</li><li>复杂度：( O(n^2) )，可优化到 ( O(n \log n) )（二分）。</li></ul></li><li><strong>Python 优势</strong>：列表操作简洁，调试方便。</li></ul></li><li><strong>背包 DP</strong>：<ul><li><strong>题目</strong>：资源分配，如 0-1 背包、完全背包。</li><li><strong>解法</strong>：定义 ( dp[i][j] ) 为前 ( i ) 项容量 ( j ) 的最优解，转移考虑是否选择当前项。</li><li><strong>示例</strong>：Luogu P1048（采药，0-1 背包）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i][j] ) 表示前 ( i ) 种草药，容量 ( j ) 的最大价值。</li><li>转移：( dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) ).</li><li>滚动数组：优化到 ( dp[j] )，空间 ( O(W) ).</li></ul></li><li><strong>Python 优势</strong>：数组操作直观，滚动数组实现简单。</li></ul></li><li><strong>区间 DP</strong>：<ul><li><strong>题目</strong>：处理区间合并或分割，如石子合并。</li><li><strong>解法</strong>：定义 ( dp[l][r] ) 为区间 ( [l, r] ) 的最优解，转移枚举分割点。</li><li><strong>示例</strong>：Luogu P1880（石子合并）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[l][r] ) 表示合并 ( [l, r] ) 石子的最小代价。</li><li>转移：( dp[l][r] = \min(dp[l][k] + dp[k+1][r] + \text{sum}[l,r]) )，( k \in [l, r-1] ).</li><li>复杂度：( O(n^3) ).</li></ul></li><li><strong>Python 优势</strong>：二维数组操作简洁，调试区间状态方便。</li></ul></li><li><strong>树形 DP</strong>：<ul><li><strong>题目</strong>：树上优化，如最小支配集。</li><li><strong>解法</strong>：定义 ( dp[u][s] ) 为节点 ( u ) 在状态 ( s ) 下的最优解，递归转移。</li><li><strong>示例</strong>：Luogu P1352（没有上司的舞会）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[u][0/1] ) 表示节点 ( u ) 不选/选的最大快乐值。</li><li>转移：( dp[u][0] = \sum \max(dp[v][0], dp[v][1]) )，( dp[u][1] = r[u] + \sum dp[v][0] ).</li><li>复杂度：( O(n) ).</li></ul></li><li><strong>Python 优势</strong>：递归实现直观，邻接表管理树结构。</li></ul></li><li><strong>状态压缩 DP</strong>：<ul><li><strong>题目</strong>：小规模集合优化，如 TSP、棋盘覆盖。</li><li><strong>解法</strong>：用二进制表示状态，转移枚举子集。</li><li><strong>示例</strong>：POJ 1185（炮兵阵地）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i][s][t] ) 表示第 ( i ) 行，当前状态 ( s )，前一行状态 ( t )。</li><li>转移：枚举合法状态，检查兼容性。</li><li>复杂度：( O(n \times 2^m \times 2^m) )，( m ) 为列数。</li></ul></li><li><strong>Python 优势</strong>：位运算简洁，调试状态转换方便。</li></ul></li><li><strong>数位 DP</strong>：<ul><li><strong>题目</strong>：数字范围计数，如满足条件的数字个数。</li><li><strong>解法</strong>：定义 ( dp[pos][state] ) 为前 ( pos ) 位在某状态下的方案数，递归转移。</li><li><strong>示例</strong>：Luogu P2657（Scenic Number）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[pos][prev][lead] ) 表示第 ( pos ) 位，前一位数字，是否前导零。</li><li>转移：枚举当前位数字，检查条件。</li><li>复杂度：( O(\log n \times \text{状态数}) ).</li></ul></li><li><strong>Python 优势</strong>：记忆化递归简洁，调试状态直观。<br><strong>ACM 优化技巧</strong>：</li></ul></li></ol><ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>滚动数组</strong>：背包、区间 DP 优化空间到 ( O(\min(n, m)) ).</li><li><strong>状态压缩</strong>：用位运算减少状态空间。</li><li><strong>边界处理</strong>：注意空状态、负索引、越界。</li><li><strong>调试</strong>：打印 DP 表格或递归路径，验证转移。<br><strong>Python 在 ACM 中的适用性</strong>：</li><li><strong>优点</strong>：<ul><li>简洁：Python 实现 DP 约 50-100 行，比赛中 10-20 分钟完成。</li><li>调试：<code>print</code> DP 表格或状态，验证正确性。</li><li>适用：( n \leq 10^5 )，时间限制 ≥ 1 秒，Python 通常通过。</li></ul></li><li><strong>缺点</strong>：<ul><li>效率：Python 比 C++ 慢 5-10 倍，复杂 DP 可能 TLE。</li><li>内存：Python 数组和递归占用较多内存。</li><li>严格限制：( n \geq 10^6 ) 或时间 &lt; 1 秒，可能 TLE。</li></ul></li><li><strong>优化</strong>：<ul><li>用 <code>array</code> 存储 DP 表格，减少内存。</li><li>迭代实现，降低递归开销。</li><li>预处理输入，减少 I/O 瓶颈。<br><strong>ACM 题目推荐</strong>：</li></ul></li><li>Luogu P1020：导弹拦截（LIS）。</li><li>Luogu P1048：采药（0-1 背包）。</li><li>Luogu P1880：石子合并（区间 DP）。</li><li>Luogu P1352：没有上司的舞会（树形 DP）。</li><li>POJ 1185：炮兵阵地（状态压缩 DP）。</li><li>Luogu P2657：Scenic Number（数位 DP）。</li></ul><hr><h2 id="4.-python-%E5%AE%9E%E7%8E%B0" tabindex="-1">4. Python 实现</h2><p>以下是几种典型 DP 问题的 Python 实现，包含递推和记忆化递归，带详细注释，适合 ACM 竞赛快速部署。</p><h3 id="4.1-0-1-%E8%83%8C%E5%8C%85%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%89" tabindex="-1">4.1 0-1 背包（递推）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">n: <span class="built_in">int</span>, W: <span class="built_in">int</span>, w: <span class="built_in">list</span>, v: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;0-1 背包：n 物品，容量 W，重量 w[i]，价值 v[i]，求最大价值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># dp[j] 表示容量 j 的最大价值</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (W + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 枚举物品</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 逆序枚举容量（滚动数组）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W, w[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">n, W = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">w, v = [], []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    wi, vi = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    w.append(wi)</span><br><span class="line">    v.append(vi)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0-1 Knapsack:&quot;</span>, knapsack(n, W, w, v))</span><br></pre></td></tr></table></figure><h3 id="4.2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%89" tabindex="-1">4.2 最长公共子序列（记忆化递归）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A: <span class="built_in">str</span>, B: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;最长公共子序列：字符串 A 和 B 的 LCS 长度&quot;&quot;&quot;</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">        <span class="keyword">if</span> A[i-<span class="number">1</span>] == B[j-<span class="number">1</span>]:</span><br><span class="line">            memo[(i, j)] = dp(i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            memo[(i, j)] = <span class="built_in">max</span>(dp(i-<span class="number">1</span>, j), dp(i, j-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(m, n)</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">A = <span class="built_in">input</span>().strip()</span><br><span class="line">B = <span class="built_in">input</span>().strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LCS Length:&quot;</span>, lcs(A, B))</span><br></pre></td></tr></table></figure><h3 id="4.3-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%EF%BC%88%E5%8C%BA%E9%97%B4-dp%EF%BC%8C%E9%80%92%E6%8E%A8%EF%BC%89" tabindex="-1">4.3 石子合并（区间 DP，递推）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stone_merge</span>(<span class="params">n: <span class="built_in">int</span>, a: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;石子合并：n 堆石子，合并成一堆的最小代价&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 前缀和</span></span><br><span class="line">    s = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s[i + <span class="number">1</span>] = s[i] + a[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dp[l][r] 表示合并 [l, r] 的最小代价</span></span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="number">0</span>  <span class="comment"># 单堆无需合并</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 枚举区间长度</span></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 枚举左端点</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n - length + <span class="number">1</span>):</span><br><span class="line">            r = l + length - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 枚举分割点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                dp[l][r] = <span class="built_in">min</span>(dp[l][r], dp[l][k] + dp[k+<span class="number">1</span>][r] + s[r+<span class="number">1</span>] - s[l])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stone Merge Cost:&quot;</span>, stone_merge(n, a))</span><br></pre></td></tr></table></figure><hr><h2 id="5.-%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B" tabindex="-1">5. 运行过程</h2><h3 id="5.1-0-1-%E8%83%8C%E5%8C%85" tabindex="-1">5.1 0-1 背包</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><ul><li>( n=4 )，( W=5 )，物品：( (w_1=2, v_1=3) ), ( (w_2=1, v_2=2) ), ( (w_3=3, v_3=4) ), ( (w_4=2, v_4=2) ).<br><strong>步骤</strong>：</li><li>初始化：( dp = [0, 0, 0, 0, 0, 0] ).</li><li>物品 1 (( w_1=2, v_1=3 ))：<ul><li>( j=5 \to 2 ): ( dp[5] = \max(0, dp[3]+3)=3 ), …, ( dp[2] = 3 ).</li><li>( dp = [0, 0, 3, 0, 0, 3] ).</li></ul></li><li>物品 2 (( w_2=1, v_2=2 ))：<ul><li>( j=5 \to 1 ): ( dp[5] = \max(3, dp[4]+2)=3 ), …, ( dp[1] = 2 ).</li><li>( dp = [0, 2, 3, 5, 2, 3] ).</li></ul></li><li>物品 3 (( w_3=3, v_3=4 ))：<ul><li>( j=5 \to 3 ): ( dp[5] = \max(3, dp[2]+4)=7 ), …, ( dp[3] = 5 ).</li><li>( dp = [0, 2, 3, 5, 6, 7] ).</li></ul></li><li>物品 4 (( w_4=2, v_4=2 ))：<ul><li>( j=5 \to 2 ): ( dp[5] = \max(7, dp[3]+2)=7 ), …, ( dp[2] = 3 ).</li><li>( dp = [0, 2, 3, 5, 6, 7] ).</li></ul></li><li>结果：( dp[5] = 7 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-1 Knapsack: 7</span><br></pre></td></tr></table></figure><h3 id="5.2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" tabindex="-1">5.2 最长公共子序列</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCD</span><br><span class="line">BECAD</span><br></pre></td></tr></table></figure><ul><li>字符串 ( A = “ABCD” )，( B = “BECAD” ).<br><strong>步骤</strong>：</li><li>记忆化递归：<ul><li>( dp(4, 5) ): ( A[3]=D ), ( B[4]=D ), 相等，( dp(4, 5) = dp(3, 4) + 1 ).</li><li>( dp(3, 4) ): ( A[2]=C ), ( B[3]=A ), 不等，( dp(3, 4) = \max(dp(2, 4), dp(3, 3)) ).</li><li>( dp(2, 4) ): ( A[1]=B ), ( B[3]=A ), 不等，( dp(2, 4) = \max(dp(1, 4), dp(2, 3)) ).</li><li>递归继续，计算所有状态。</li></ul></li><li>最终：( dp(4, 5) = 3 )（LCS 为 “BCD”）。</li><li>记忆化表格（部分）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   B E C A D</span><br><span class="line">A 0 0 0 0 0</span><br><span class="line">B 1 1 1 1 1</span><br><span class="line">C 1 1 2 2 2</span><br><span class="line">D 1 1 2 2 3</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCS Length: 3</span><br></pre></td></tr></table></figure><h3 id="5.3-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6" tabindex="-1">5.3 石子合并</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure><ul><li>( n=4 )，石子：( a = [1, 3, 5, 2] ).<br><strong>步骤</strong>：</li><li>前缀和：( s = [0, 1, 4, 9, 11] ).</li><li>初始化：( dp[i][i] = 0 ).</li><li>长度 2：<ul><li>( dp[0][1] = s[2]-s[0] = 4 ).</li><li>( dp[1][2] = s[3]-s[1] = 8 ).</li><li>( dp[2][3] = s[4]-s[2] = 7 ).</li></ul></li><li>长度 3：<ul><li>( dp[0][2] = \min(dp[0][0]+dp[1][2], dp[0][1]+dp[2][2]) + s[3]-s[0] = \min(0+8, 4+0)+9 = 12 ).</li><li>( dp[1][3] = \min(dp[1][1]+dp[2][3], dp[1][2]+dp[3][3]) + s[4]-s[1] = \min(0+7, 8+0)+10 = 17 ).</li></ul></li><li>长度 4：<ul><li>( dp[0][3] = \min(dp[0][k]+dp[k+1][3]+s[4]-s[0]) = \min(0+17, 4+7, 12+0)+11 = 18 ).</li></ul></li><li>结果：( dp[0][3] = 18 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stone Merge Cost: 18</span><br></pre></td></tr></table></figure><hr><h2 id="6.-dp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1">6. DP 的优缺点</h2><h3 id="6.1-%E4%BC%98%E7%82%B9" tabindex="-1">6.1 优点</h3><ul><li><strong>高效性</strong>：将指数复杂度降为多项式（如斐波那契从 ( O(2^n) ) 到 ( O(n) )）。</li><li><strong>通用性</strong>：适用于优化、计数、概率等多种问题。</li><li><strong>ACM 友好</strong>：Python 实现简洁，约 50-100 行，比赛中 10-20 分钟完成。</li><li><strong>可优化</strong>：滚动数组、状态压缩显著降低空间复杂度。</li><li><strong>调试方便</strong>：DP 表格直观，易于验证。</li></ul><h3 id="6.2-%E7%BC%BA%E7%82%B9" tabindex="-1">6.2 缺点</h3><ul><li><strong>状态设计复杂</strong>：需要准确定义状态和转移，初学者易出错。</li><li><strong>空间限制</strong>：多维 DP 可能占用大量内存。</li><li><strong>ACM 限制</strong>：<ul><li>大输入（( n \geq 10^6 )）或时间 &lt; 1 秒，Python 可能 TLE。</li><li>复杂状态压缩或数位 DP 实现难度高。</li></ul></li><li><strong>依赖经验</strong>：状态转移方程推导需熟练，比赛中时间紧迫。</li></ul><h3 id="6.3-%E6%94%B9%E8%BF%9B%E6%96%B9%E5%90%91" tabindex="-1">6.3 改进方向</h3><ul><li><strong>滚动数组</strong>：优化空间到 ( O(\min(n, m)) ).</li><li><strong>状态压缩</strong>：用位运算减少状态数。</li><li><strong>迭代实现</strong>：将记忆化递归转为递推，降低递归开销。</li><li><strong>快速 I/O</strong>：优化 Python 输入输出。</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）。</li></ul><hr><h2 id="7.-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">7. 与其他方法的对比</h2><h3 id="7.1-%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" tabindex="-1">7.1 与贪心算法</h3><ul><li><strong>目标</strong>：<ul><li>贪心：局部最优，快速决策。</li><li>DP：全局最优，考虑所有可能。</li></ul></li><li><strong>适用性</strong>：<ul><li>贪心：活动选择、Huffman 编码。</li><li>DP：0-1 背包、LCS。</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>贪心：简单问题，Python 实现快。</li><li>DP：复杂优化问题，Python 通用。</li></ul></li><li><strong>Python 实现</strong>：<ul><li>贪心：代码短，逻辑简单。</li><li>DP：代码稍长，状态设计复杂。</li></ul></li></ul><h3 id="7.2-%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95" tabindex="-1">7.2 与分治算法</h3><ul><li><strong>目标</strong>：<ul><li>分治：分解为独立子问题。</li><li>DP：分解为重叠子问题。</li></ul></li><li><strong>适用性</strong>：<ul><li>分治：归并排序、快速排序。</li><li>DP：LIS、背包问题。</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>分治：分治 + 递归，适合无重叠问题。</li><li>DP：优化重叠子问题，适合序列、图。</li></ul></li><li><strong>Python 实现</strong>：<ul><li>分治：递归简洁，但可能重复计算。</li><li>DP：存储优化，效率更高。</li></ul></li></ul><h3 id="7.3-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%93%E5%90%88" tabindex="-1">7.3 与数据结构结合</h3><ul><li><strong>DP + 线段树</strong>：<ul><li>题目：动态区间优化。</li><li>解法：DP 定义状态，线段树维护区间最优值。</li><li>示例：Codeforces 474E（Pillars，LIS + 线段树）。</li></ul></li><li><strong>DP + 单调队列/栈</strong>：<ul><li>题目：序列优化。</li><li>解法：单调队列维护 DP 转移的最优候选。</li><li>示例：Luogu P1725（琪露诺，单调队列 DP）。</li></ul></li><li><strong>DP + 树</strong>：<ul><li>题目：树上优化。</li><li>解法：树形 DP 递归转移。</li><li>示例：Luogu P1352（没有上司的舞会）。</li></ul></li></ul><hr><h2 id="8.-%E6%A8%A1%E6%8B%9F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E8%A1%A5%E5%85%85%E6%95%B0%E4%BD%8D-dp%EF%BC%89" tabindex="-1">8. 模拟运行过程（补充数位 DP）</h2><h3 id="8.1-%E6%95%B0%E4%BD%8D-dp" tabindex="-1">8.1 数位 DP</h3><p><strong>问题</strong>：统计区间 ([L, R]) 内，数字各位之和为 ( K ) 的数的个数。<br><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位和为 K 的数的个数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">num: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">pos: <span class="built_in">int</span>, <span class="built_in">sum</span>: <span class="built_in">int</span>, tight: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">sum</span> == K <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; K:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (pos, <span class="built_in">sum</span>, tight) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[(pos, <span class="built_in">sum</span>, tight)]</span><br><span class="line">            </span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            limit = <span class="built_in">int</span>(num[pos]) <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">                new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">                ans += dp(pos + <span class="number">1</span>, <span class="built_in">sum</span> + d, new_tight)</span><br><span class="line">            </span><br><span class="line">            memo[(pos, <span class="built_in">sum</span>, tight)] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count(<span class="built_in">str</span>(R), K) - count(<span class="built_in">str</span>(L-<span class="number">1</span>), K)</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Digit DP Count:&quot;</span>, digit_dp(L, R, K))</span><br></pre></td></tr></table></figure><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 20 5</span><br></pre></td></tr></table></figure><ul><li>区间 ([1, 20])，各位和为 5.<br><strong>步骤</strong>：</li><li>计算 ( \text{count}(20, 5) )：<ul><li>( dp(0, 0, \text{True}) ):<ul><li>枚举第一位 ( d=0 \to 2 )：<ul><li>( d=1 ): ( dp(1, 1, \text{True}) ).</li><li>( d=2 ): ( dp(1, 2, \text{True}) ).</li></ul></li><li>( dp(1, 1, \text{True}) ): 第二位 ( d=0 \to 0 )，( dp(2, 1+0, \text{True}) = 0 )（sum=1 &lt; 5）。</li><li>( dp(1, 2, \text{True}) ): ( d=0 )，( dp(2, 2+0, \text{True}) = 0 )（sum=2 &lt; 5）。</li></ul></li><li>结果：0（20 各位和 ≠ 5）。</li></ul></li><li>计算 ( \text{count}(0, 5) )：类似，0（无数字和 5）。</li><li>枚举 ([1, 20])：和为 5 的数为 5, 14。</li><li>结果：( 2 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Digit DP Count: 2</span><br></pre></td></tr></table></figure><hr><h2 id="9.-%E6%80%BB%E7%BB%93" tabindex="-1">9. 总结</h2><p>动态规划是解决优化和计数问题的核心方法，通过状态设计和转移高效分解问题：</p><ul><li><strong>核心性质</strong>：最优子结构、重叠子问题、无后效性。</li><li><strong>编程方法</strong>：递推（自底向上）、记忆化递归（自顶向下）、空间优化。</li><li><strong>ACM 应用</strong>：线性 DP、背包、区间 DP、树形 DP、状态压缩、数位 DP。</li><li><strong>Python 实现</strong>：约 50-100 行，调试方便，适合 ( n \leq 10^5 )，时间 ≥ 1 秒。</li><li><strong>优化</strong>：滚动数组、状态压缩、快速 I/O。<br>通过 Python 代码和样例模拟，展示了 DP 的常见类型和运行过程。在 ACM 竞赛中，DP 是不可或缺的工具，Python 实现适合快速原型和中小规模问题。<br><strong>学习建议</strong>：</li></ul><ol><li><strong>手动模拟</strong>：用小数据（如 ( n=4 )）画 DP 表格，推导转移。</li><li><strong>ACM 练习</strong>：尝试 Luogu P1020、P1048、P1880，用 Python 实现 DP。</li><li><strong>深入扩展</strong>：学习单调队列 DP、斜率优化、凸包优化。</li><li><strong>比赛策略</strong>：<ul><li>优先 Python 快速实现，验证正确性。</li><li>若 TLE，优化 I/O 或切换 C++.<br>如果你有其他问题、需要优化 Python 代码、或想探讨 ACM 题目（如复杂 DP 优化、数据结构结合），请随时告诉我！</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-dp%EF%BC%89%E6%98%AF%E7%AE%97%E6%B3%95%E</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
