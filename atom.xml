<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://borrowyourhuaji.github.io/atom.xml" rel="self"/>
  
  <link href="https://borrowyourhuaji.github.io/"/>
  <updated>2025-09-14T04:36:32.931Z</updated>
  <id>https://borrowyourhuaji.github.io/</id>
  
  <author>
    <name>borrowyourhuaji</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ubuntu services cmommand</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/ubuntu-services-cmommand/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/ubuntu-services-cmommand/</id>
    <published>2025-09-13T15:42:12.000Z</published>
    <updated>2025-09-14T04:36:32.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%F0%9F%94%B9-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%86%85%E7%BD%AE%2F%E9%80%9A%E7%94%A8%EF%BC%89" tabindex="-1">🔹 一、基础网络命令（内置/通用）</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ping</code></td><td>测试连通性</td><td><code>ping baidu.com</code></td></tr><tr><td><code>curl</code></td><td>HTTP/HTTPS 请求</td><td><code>curl -I https://example.com</code></td></tr><tr><td><code>wget</code></td><td>下载文件</td><td><code>wget https://example.com/file.zip</code></td></tr><tr><td><code>traceroute</code></td><td>路由跟踪</td><td><code>traceroute 8.8.8.8</code></td></tr><tr><td><code>mtr</code></td><td>动态路由跟踪（集成 ping+traceroute）</td><td><code>mtr google.com</code></td></tr><tr><td><code>telnet</code></td><td>测试 TCP 端口连通</td><td><code>telnet example.com 80</code></td></tr><tr><td><code>nc</code> / <code>netcat</code></td><td>网络测试、端口扫描、socket调试</td><td><code>nc -zv 192.168.1.1 22-80</code></td></tr><tr><td><code>dig</code></td><td>DNS 查询（来自 <code>dnsutils</code> 包）</td><td><code>dig google.com</code></td></tr><tr><td><code>nslookup</code></td><td>DNS 查询（老工具）</td><td><code>nslookup baidu.com</code></td></tr><tr><td><code>host</code></td><td>简单 DNS 查询</td><td><code>host github.com</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%BA%8C%E3%80%81%E6%97%A7%E5%B7%A5%E5%85%B7-net-tools%EF%BC%88%E9%80%90%E6%B8%90%E8%A2%AB%E6%9B%BF%E4%BB%A3%EF%BC%8C%E4%BD%86%E4%BB%8D%E5%B8%B8%E7%94%A8%EF%BC%89" tabindex="-1">🔹 二、旧工具 Net-tools（逐渐被替代，但仍常用）</h1><p>需安装：<code>sudo apt install net-tools</code></p><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>查看/配置网络接口</td><td><code>ifconfig eth0 up</code></td></tr><tr><td><code>route</code></td><td>查看/配置路由表</td><td><code>route -n</code></td></tr><tr><td><code>arp</code></td><td>查看/管理 ARP 缓存</td><td><code>arp -a</code></td></tr><tr><td><code>netstat</code></td><td>查看端口、连接、路由</td><td><code>netstat -tulnp</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B8%89%E3%80%81%E6%96%B0%E5%B7%A5%E5%85%B7-iproute2%EF%BC%88%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%8C%E6%8E%A8%E8%8D%90%EF%BC%89" tabindex="-1">🔹 三、新工具 iproute2（现代替代方案，推荐）</h1><p>自带在 Ubuntu，无需安装。</p><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ip addr</code></td><td>查看/管理 IP 地址</td><td><code>ip addr show</code></td></tr><tr><td><code>ip link</code></td><td>查看/配置网卡</td><td><code>ip link set eth0 up</code></td></tr><tr><td><code>ip route</code></td><td>查看/管理路由表</td><td><code>ip route add default via 192.168.1.1</code></td></tr><tr><td><code>ip neigh</code></td><td>查看/管理 ARP 表</td><td><code>ip neigh show</code></td></tr><tr><td><code>ss</code></td><td>替代 <code>netstat</code>，查看 socket</td><td><code>ss -tulnp</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%9B%9B%E3%80%81%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%B5%8B%E8%AF%95" tabindex="-1">🔹 四、网络诊断与测试</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ethtool</code></td><td>网卡信息、速率</td><td><code>ethtool eth0</code></td></tr><tr><td><code>iwconfig</code></td><td>无线网卡配置（Wi-Fi）</td><td><code>iwconfig wlan0</code></td></tr><tr><td><code>iwlist</code></td><td>扫描无线网络</td><td><code>iwlist wlan0 scan</code></td></tr><tr><td><code>nmcli</code></td><td>NetworkManager CLI，配置网络</td><td><code>nmcli device status</code></td></tr><tr><td><code>systemd-resolve</code></td><td>DNS 解析调试（systemd-resolved）</td><td><code>systemd-resolve google.com</code></td></tr><tr><td><code>curl ifconfig.me</code></td><td>查看公网 IP</td><td><code>curl ifconfig.me</code></td></tr><tr><td><code>whois</code></td><td>域名/IP 查询</td><td><code>whois example.com</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%BA%94%E3%80%81%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3" tabindex="-1">🔹 五、服务管理相关</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>service networking restart</code></td><td>重启网络服务</td><td></td></tr><tr><td><code>systemctl restart NetworkManager</code></td><td>重启 NetworkManager</td><td></td></tr><tr><td><code>nmcli</code></td><td>全面网络管理工具</td><td><code>nmcli con up id mywifi</code></td></tr><tr><td><code>wpa_cli</code> / <code>wpa_supplicant</code></td><td>Wi-Fi 配置工具</td><td><code>wpa_cli status</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%85%AD%E3%80%81%E6%8A%93%E5%8C%85%E4%B8%8E%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90" tabindex="-1">🔹 六、抓包与流量分析</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>tcpdump</code></td><td>抓包分析</td><td><code>tcpdump -i eth0 port 80</code></td></tr><tr><td><code>wireshark</code> / <code>tshark</code></td><td>高级抓包工具</td><td><code>tshark -i wlan0</code></td></tr><tr><td><code>iftop</code></td><td>实时流量监控</td><td><code>iftop -i eth0</code></td></tr><tr><td><code>nload</code></td><td>网络流量实时曲线</td><td><code>nload</code></td></tr><tr><td><code>iptraf-ng</code></td><td>网络统计工具</td><td><code>iptraf-ng</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B8%83%E3%80%81%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E5%AE%89%E5%85%A8" tabindex="-1">🔹 七、防火墙与安全</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>ufw</code></td><td>简易防火墙管理（Ubuntu 默认推荐）</td><td><code>ufw allow 22/tcp</code></td></tr><tr><td><code>iptables</code></td><td>底层防火墙配置</td><td><code>iptables -L -n -v</code></td></tr><tr><td><code>firewalld</code></td><td>另一套防火墙（部分系统用）</td><td><code>firewall-cmd --list-all</code></td></tr><tr><td><code>fail2ban-client</code></td><td>SSH 防暴力破解工具</td><td><code>fail2ban-client status</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E5%85%AB%E3%80%81%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4" tabindex="-1">🔹 八、其他常见网络命令</h1><table><thead><tr><th>命令</th><th>功能</th><th>示例</th></tr></thead><tbody><tr><td><code>scp</code></td><td>远程拷贝文件（基于 SSH）</td><td><code>scp file user@host:/path/</code></td></tr><tr><td><code>rsync</code></td><td>高效同步文件</td><td><code>rsync -avz dir user@host:/path/</code></td></tr><tr><td><code>ftp</code> / <code>sftp</code></td><td>文件传输</td><td><code>sftp user@host</code></td></tr><tr><td><code>ssh</code></td><td>远程登录</td><td><code>ssh user@host</code></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-%E4%B9%9D%E3%80%81%E7%BB%83%E4%B9%A0%E8%B7%AF%E7%BA%BF%EF%BC%88%E7%BB%99%E4%BD%A0%E7%BB%83%E6%89%8B%E7%9A%84%E5%BB%BA%E8%AE%AE%EF%BC%89" tabindex="-1">🔹 九、练习路线（给你练手的建议）</h1><ol><li><p><strong>入门</strong>：</p><ul><li>用 <code>ping</code>、<code>curl</code>、<code>wget</code> 测试网络</li><li>用 <code>ip addr</code>、<code>ifconfig</code> 查看网卡</li></ul></li><li><p><strong>进阶</strong>：</p><ul><li>用 <code>ss -tulnp</code> 找出占用端口的服务</li><li>用 <code>ip route</code> 修改默认路由</li><li>用 <code>ufw</code> 添加规则限制端口</li></ul></li><li><p><strong>高级</strong>：</p><ul><li>用 <code>tcpdump</code> 抓包，配合 <code>wireshark</code> 分析 HTTP/HTTPS</li><li>用 <code>iptables</code> 手写 NAT 转发规则</li><li>用 <code>nload</code> 或 <code>iftop</code> 看实时流量</li></ul></li></ol><h1 id="ubuntu-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8" tabindex="-1">Ubuntu 网络相关命令列表</h1><h2 id="1.-%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E7%AE%A1%E7%90%86" tabindex="-1">1. 网络接口管理</h2><ul><li><strong>ifconfig</strong>: 显示或配置网络接口（传统工具，需安装 <code>net-tools</code>）。<br>示例: <code>ifconfig eth0</code> (显示 eth0 接口信息)。</li><li><strong>ip</strong>: 现代网络接口管理工具，显示或配置 IP 地址、路由等。<br>示例: <code>ip addr show</code> (显示所有接口信息)。</li><li><strong>nmcli</strong>: NetworkManager 命令行工具，管理网络连接。<br>示例: <code>nmcli con show</code> (列出网络连接)。</li><li><strong>ethtool</strong>: 显示或配置网络接口状态（如速度、双工模式）。<br>示例: <code>ethtool eth0</code> (显示 eth0 状态)。</li><li><strong>iwconfig</strong>: 配置无线网络接口（需安装 <code>wireless-tools</code>）。<br>示例: <code>iwconfig wlan0</code> (显示无线接口信息)。</li><li><strong>iw</strong>: 现代无线网络接口管理工具。<br>示例: <code>iw dev wlan0 scan</code> (扫描无线网络)。</li><li><strong>ifup</strong>: 启用网络接口（需配置 /etc/network/interfaces）。<br>示例: <code>sudo ifup eth0</code>。</li><li><strong>ifdown</strong>: 禁用网络接口。<br>示例: <code>sudo ifdown eth0</code>。</li><li><strong>route</strong>: 显示或配置路由表（需安装 <code>net-tools</code>）。<br>示例: <code>route -n</code> (显示数字格式路由表)。</li><li><strong>ip route</strong>: 现代路由表管理工具。<br>示例: <code>ip route show</code> (显示路由表)。</li></ul><h2 id="2.-%E7%BD%91%E7%BB%9C%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%B5%8B%E8%AF%95" tabindex="-1">2. 网络诊断与测试</h2><ul><li><strong>ping</strong>: 测试与目标主机的网络连通性。<br>示例: <code>ping -c 4 google.com</code> (发送 4 个数据包)。</li><li><strong>traceroute</strong>: 显示数据包到目标主机的路由路径（需安装）。<br>示例: <code>traceroute google.com</code>。</li><li><strong>mtr</strong>: 结合 ping 和 traceroute 的实时网络诊断工具（需安装）。<br>示例: <code>mtr google.com</code>。</li><li><strong>dig</strong>: 查询 DNS 记录（需安装 <code>dnsutils</code>）。<br>示例: <code>dig example.com</code>。</li><li><strong>nslookup</strong>: 查询 DNS 名称解析。<br>示例: <code>nslookup example.com</code>。</li><li><strong>host</strong>: 简单 DNS 查询工具。<br>示例: <code>host example.com</code>。</li><li><strong>netstat</strong>: 显示网络连接、路由表、接口统计（需安装 <code>net-tools</code>）。<br>示例: <code>netstat -tuln</code> (显示监听的 TCP/UDP 端口)。</li><li><strong>ss</strong>: 现代网络套接字统计工具，替代 netstat。<br>示例: <code>ss -tuln</code> (显示监听端口)。</li><li><strong>nmap</strong>: 网络扫描和端口探测工具（需安装）。<br>示例: <code>nmap localhost</code> (扫描本地主机端口)。</li><li><strong>telnet</strong>: 测试远程主机端口连通性。<br>示例: <code>telnet example.com 80</code> (测试 80 端口)。</li><li><strong>nc</strong> (netcat): 多功能网络工具，用于端口测试、数据传输等。<br>示例: <code>nc -zv localhost 22</code> (测试端口连接)。</li><li><strong>arp</strong>: 显示或管理 ARP 缓存（地址解析协议）。<br>示例: <code>arp -n</code> (显示 ARP 表)。</li><li><strong>ip neighbor</strong>: 现代 ARP 表管理工具。<br>示例: <code>ip neighbor show</code> (显示邻居表)。</li></ul><h2 id="3.-%E7%BD%91%E7%BB%9C%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93" tabindex="-1">3. 网络文件传输</h2><ul><li><strong>curl</strong>: 从 URL 下载或发送数据，支持 HTTP/HTTPS/FTP 等。<br>示例: <code>curl -O https://example.com/file.txt</code> (下载文件)。</li><li><strong>wget</strong>: 非交互式文件下载工具。<br>示例: <code>wget https://example.com/file.zip</code>。</li><li><strong>scp</strong>: 通过 SSH 安全复制文件到远程主机。<br>示例: <code>scp file.txt user@host:/path</code>。</li><li><strong>rsync</strong>: 高效的文件同步和传输工具。<br>示例: <code>rsync -avz file.txt user@host:/path</code> (同步文件)。</li><li><strong>ftp</strong>: 交互式 FTP 文件传输（需安装 FTP 客户端）。<br>示例: <code>ftp ftp.example.com</code>。</li><li><strong>sftp</strong>: 通过 SSH 进行安全的 FTP 文件传输。<br>示例: <code>sftp user@host</code>。</li></ul><h2 id="4.-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%AE%A1%E7%90%86" tabindex="-1">4. 远程连接与管理</h2><ul><li><strong>ssh</strong>: 安全远程登录到另一台主机。<br>示例: <code>ssh user@host</code>。</li><li><strong>ssh-keygen</strong>: 生成 SSH 密钥对。<br>示例: <code>ssh-keygen -t rsa</code>。</li><li><strong>ssh-copy-id</strong>: 将公钥复制到远程主机以实现免密码登录。<br>示例: <code>ssh-copy-id user@host</code>。</li><li><strong>telnet</strong>: 非安全远程连接（不推荐，测试用）。<br>示例: <code>telnet host 23</code>。</li></ul><h2 id="5.-%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86" tabindex="-1">5. 网络服务管理</h2><ul><li><strong>systemctl</strong>: 管理网络相关服务（如 NetworkManager、sshd）。<br>示例: <code>sudo systemctl restart ssh</code>。</li><li><strong>service</strong>: 传统方式管理系统服务。<br>示例: <code>sudo service networking restart</code>。</li><li><strong>ufw</strong>: 简易防火墙配置工具。<br>示例: <code>sudo ufw allow 22</code> (允许 SSH 端口)。</li><li><strong>iptables</strong>: 配置内核防火墙规则（高级用户）。<br>示例: <code>sudo iptables -L</code> (列出规则)。</li><li><strong>firewalld</strong>: 动态防火墙管理工具（需安装）。<br>示例: <code>sudo firewall-cmd --list-all</code>。</li></ul><h2 id="6.-%E7%BD%91%E7%BB%9C%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%88%86%E6%9E%90" tabindex="-1">6. 网络监控与分析</h2><ul><li><strong>tcpdump</strong>: 捕获和分析网络数据包（需安装）。<br>示例: <code>sudo tcpdump -i eth0</code> (捕获 eth0 接口数据包)。</li><li><strong>wireshark</strong>: 图形化网络协议分析工具（需安装）。<br>示例: <code>wireshark &amp;</code> (启动 GUI 界面)。</li><li><strong>iftop</strong>: 实时显示网络接口带宽使用情况（需安装）。<br>示例: <code>sudo iftop -i eth0</code>。</li><li><strong>nload</strong>: 监控网络带宽使用情况（需安装）。<br>示例: <code>nload eth0</code>。</li><li><strong>vnstat</strong>: 统计网络流量（需安装）。<br>示例: <code>vnstat -i eth0</code> (显示 eth0 流量统计)。</li></ul><h2 id="7.-%E5%85%B6%E4%BB%96%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E5%B7%A5%E5%85%B7" tabindex="-1">7. 其他网络相关工具</h2><ul><li><strong>hostname</strong>: 显示或设置系统主机名。<br>示例: <code>hostname</code>。</li><li><strong>hostnamectl</strong>: 管理主机名（现代 systemd 工具）。<br>示例: <code>hostnamectl set-hostname newname</code>。</li><li><strong>whois</strong>: 查询域名注册信息（需安装）。<br>示例: <code>whois example.com</code>。</li><li><strong>curlftpfs</strong>: 将 FTP 服务器挂载为本地文件系统（需安装）。<br>示例: <code>curlftpfs ftp://user:pass@host /mnt/ftp</code>。</li><li><strong>avahi-discover</strong>: 发现局域网内 mDNS/DNS-SD 服务（需安装）。<br>示例: <code>avahi-discover</code>。</li><li><strong>ipcalc</strong>: 计算 IP 地址和子网信息（需安装）。<br>示例: <code>ipcalc 192.168.1.0/24</code>。</li><li><strong>dhclient</strong>: 获取或释放 DHCP 租约。<br>示例: <code>sudo dhclient eth0</code>。</li><li><strong>dnsmasq</strong>: 轻量级 DNS 和 DHCP 服务器（需安装）。<br>示例: <code>sudo dnsmasq</code>。</li></ul><h2 id="%E8%AF%B4%E6%98%8E" tabindex="-1">说明</h2><ul><li><strong>安装说明</strong>: 部分命令（如 <code>net-tools</code>、<code>nmap</code>、<code>wireshark</code> 等）可能需要安装，运行 <code>sudo apt install &lt;包名&gt;</code>。</li><li><strong>权限</strong>: 网络配置或监控命令通常需要 <code>sudo</code> 权限。</li><li><strong>文档查询</strong>: 使用 <code>man &lt;命令&gt;</code> 或 <code>tldr &lt;命令&gt;</code> 获取详细用法（<code>tldr</code> 需安装）。</li><li><strong>扩展</strong>: 更多高级工具可通过 <code>apt search network</code> 或 <code>compgen -c | grep network</code> 发现。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%F0%9F%94%B9-%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88%E5%86%85%E7%BD%AE%2F%E9%80%9A%E7%94%A</summary>
      
    
    
    
    
    <category term="service" scheme="https://borrowyourhuaji.github.io/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu common cmommand</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/ubuntu-common-cmommand/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/ubuntu-common-cmommand/</id>
    <published>2025-09-13T15:37:46.000Z</published>
    <updated>2025-09-13T15:41:56.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%F0%9F%94%B9-1.-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4" tabindex="-1">🔹 1. 基础操作命令</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看当前目录</td><td><code>pwd</code></td><td>print working directory</td></tr><tr><td>列出文件</td><td><code>ls</code>、<code>ls -l</code>、<code>ls -a</code></td><td>加 <code>-l</code> 显示详细，加 <code>-a</code> 显示隐藏文件</td></tr><tr><td>切换目录</td><td><code>cd 目录名</code></td><td><code>cd ..</code> 返回上一级，<code>cd ~</code> 回家目录</td></tr><tr><td>创建目录</td><td><code>mkdir test</code></td><td>递归创建：<code>mkdir -p a/b/c</code></td></tr><tr><td>创建文件</td><td><code>touch file.txt</code></td><td>更新文件时间，若不存在就新建</td></tr><tr><td>删除文件</td><td><code>rm file.txt</code></td><td>删除目录：<code>rm -r dirname</code></td></tr><tr><td>拷贝</td><td><code>cp a b</code></td><td>拷贝文件；<code>cp -r dir1 dir2</code> 复制目录</td></tr><tr><td>移动/重命名</td><td><code>mv a b</code></td><td>文件移动/改名</td></tr><tr><td>查看文件内容</td><td><code>cat file</code>、<code>less file</code>、<code>head file</code>、<code>tail file</code></td><td><code>tail -f log.txt</code> 实时看日志</td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-2.-%E7%94%A8%E6%88%B7%E5%92%8C%E6%9D%83%E9%99%90" tabindex="-1">🔹 2. 用户和权限</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>当前用户</td><td><code>whoami</code></td><td></td></tr><tr><td>切换用户</td><td><code>su 用户名</code></td><td></td></tr><tr><td>临时管理员</td><td><code>sudo 命令</code></td><td></td></tr><tr><td>修改权限</td><td><code>chmod 755 file</code></td><td>读/写/执行权限</td></tr><tr><td>修改属主</td><td><code>chown user:group file</code></td><td></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-3.-%E8%BD%AF%E4%BB%B6%E7%AE%A1%E7%90%86-(ubuntu-apt)" tabindex="-1">🔹 3. 软件管理 (Ubuntu apt)</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>更新源</td><td><code>sudo apt update</code></td><td>更新索引，不升级</td></tr><tr><td>升级系统</td><td><code>sudo apt upgrade</code></td><td>升级已安装包</td></tr><tr><td>安装软件</td><td><code>sudo apt install 包名</code></td><td></td></tr><tr><td>卸载软件</td><td><code>sudo apt remove 包名</code></td><td></td></tr><tr><td>搜索软件</td><td><code>apt search 关键词</code></td><td></td></tr><tr><td>查看已安装</td><td>`dpkg -l</td><td>grep 包名`</td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-4.-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%B3%BB%E7%BB%9F" tabindex="-1">🔹 4. 进程和系统</h1><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>查看进程</td><td><code>ps aux</code>、<code>top</code>、<code>htop</code></td><td></td></tr><tr><td>杀进程</td><td><code>kill -9 pid</code></td><td></td></tr><tr><td>系统状态</td><td><code>uptime</code>（负载）、<code>free -h</code>（内存）、<code>df -h</code>（磁盘）、<code>du -sh</code>（目录大小）</td><td></td></tr><tr><td>网络</td><td><code>ping baidu.com</code>、<code>curl ifconfig.me</code>（查看公网 IP）、<code>ss -tulpn</code>（监听端口）</td><td></td></tr></tbody></table><hr><h1 id="%F0%9F%94%B9-5.-wsl-%E4%B8%93%E5%B1%9E%E5%91%BD%E4%BB%A4%EF%BC%88%E5%9C%A8-windows-powershell-%2F-cmd-%E7%94%A8%EF%BC%89" tabindex="-1">🔹 5. WSL 专属命令（在 Windows PowerShell / CMD 用）</h1><p>这些是 <strong>WSL 特有的</strong>，在 Windows 的命令行运行，而不是 Ubuntu 内：</p><table><thead><tr><th>功能</th><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>进入 WSL</td><td><code>wsl</code></td><td>默认发行版</td></tr><tr><td>指定发行版</td><td><code>wsl -d Ubuntu-22.04</code></td><td></td></tr><tr><td>查看已安装发行版</td><td><code>wsl -l -v</code></td><td></td></tr><tr><td>运行 Linux 命令</td><td><code>wsl ls -la</code></td><td>在 Windows 下直接执行</td></tr><tr><td>导入导出</td><td><code>wsl --export</code> / <code>wsl --import</code></td><td></td></tr><tr><td>关闭</td><td><code>wsl --shutdown</code></td><td></td></tr></tbody></table><hr><h3 id="ubuntu-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%88%97%E8%A1%A8" tabindex="-1">Ubuntu 常用命令列表</h3><h4 id="1.-%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%EF%BC%88file-%26-directory-management%EF%BC%89" tabindex="-1">1. 文件和目录管理（File &amp; Directory Management）</h4><ul><li><strong>ls</strong>: 显示当前目录的文件和文件夹列表。<br>示例: <code>ls -la</code> (显示隐藏文件和详细信息)。</li><li><strong>cd</strong>: 切换当前工作目录。<br>示例: <code>cd /home</code> (进入 home 目录)。</li><li><strong>pwd</strong>: 显示当前工作目录的绝对路径。<br>示例: <code>pwd</code>。</li><li><strong>mkdir</strong>: 创建新目录。<br>示例: <code>mkdir newfolder</code>。</li><li><strong>rmdir</strong>: 删除空目录。<br>示例: <code>rmdir emptyfolder</code>。</li><li><strong>touch</strong>: 创建空文件或更新文件时间戳。<br>示例: <code>touch file.txt</code>。</li><li><strong>cp</strong>: 复制文件或目录。<br>示例: <code>cp file.txt /backup/</code>。</li><li><strong>mv</strong>: 移动或重命名文件/目录。<br>示例: <code>mv oldname newname</code>。</li><li><strong>rm</strong>: 删除文件或目录。<br>示例: <code>rm -r folder</code> (递归删除目录)。</li><li><strong>find</strong>: 在目录中搜索文件。<br>示例: <code>find /home -name &quot;*.txt&quot;</code>。</li></ul><h4 id="2.-%E6%96%87%E4%BB%B6%E6%9F%A5%E7%9C%8B%E5%92%8C%E7%BC%96%E8%BE%91%EF%BC%88file-viewing-%26-editing%EF%BC%89" tabindex="-1">2. 文件查看和编辑（File Viewing &amp; Editing）</h4><ul><li><strong>cat</strong>: 连接并显示文件内容。<br>示例: <code>cat file.txt</code>。</li><li><strong>less</strong>: 分页查看文件内容（支持滚动）。<br>示例: <code>less largefile.log</code>。</li><li><strong>more</strong>: 分页查看文件内容。<br>示例: <code>more file.txt</code>。</li><li><strong>head</strong>: 显示文件前几行。<br>示例: <code>head -5 file.txt</code>。</li><li><strong>tail</strong>: 显示文件后几行。<br>示例: <code>tail -f log.txt</code> (实时监控)。</li><li><strong>nano</strong>: 简单文本编辑器。<br>示例: <code>nano file.txt</code>。</li><li><strong>vim/vi</strong>: 高级文本编辑器。<br>示例: <code>vim file.txt</code>。</li><li><strong>echo</strong>: 输出文本到终端或文件。<br>示例: <code>echo &quot;Hello&quot; &gt; file.txt</code>。</li></ul><h4 id="3.-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%EF%BC%88permissions%EF%BC%89" tabindex="-1">3. 权限管理（Permissions）</h4><ul><li><strong>chmod</strong>: 修改文件/目录权限。<br>示例: <code>chmod 755 script.sh</code>。</li><li><strong>chown</strong>: 更改文件所有者。<br>示例: <code>sudo chown user:group file.txt</code>。</li><li><strong>su</strong>: 切换到超级用户（root）。<br>示例: <code>su -</code>。</li><li><strong>sudo</strong>: 以管理员权限执行命令。<br>示例: <code>sudo apt update</code>。</li></ul><h4 id="4.-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%88process-management%EF%BC%89" tabindex="-1">4. 进程管理（Process Management）</h4><ul><li><strong>ps</strong>: 显示当前进程列表。<br>示例: <code>ps aux</code> (所有进程详细信息)。</li><li><strong>top</strong>: 实时监控进程和系统资源。<br>示例: <code>top</code>。</li><li><strong>htop</strong>: 交互式进程查看器（需安装）。<br>示例: <code>htop</code>。</li><li><strong>kill</strong>: 终止指定进程。<br>示例: <code>kill 1234</code> (进程 ID 为 1234)。</li><li><strong>pkill</strong>: 根据进程名终止进程。<br>示例: <code>pkill firefox</code>。</li></ul><h4 id="5.-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E5%92%8C%E7%9B%91%E6%8E%A7%EF%BC%88system-information%EF%BC%89" tabindex="-1">5. 系统信息和监控（System Information）</h4><ul><li><strong>uname</strong>: 显示系统信息。<br>示例: <code>uname -a</code> (所有细节)。</li><li><strong>df</strong>: 显示磁盘使用情况。<br>示例: <code>df -h</code> (人类可读格式)。</li><li><strong>du</strong>: 计算目录/文件占用空间。<br>示例: <code>du -sh /home</code>。</li><li><strong>free</strong>: 显示内存使用情况。<br>示例: <code>free -h</code>。</li><li><strong>uptime</strong>: 显示系统运行时间。<br>示例: <code>uptime</code>。</li><li><strong>whoami</strong>: 显示当前用户名。<br>示例: <code>whoami</code>。</li><li><strong>date</strong>: 显示或设置系统日期/时间。<br>示例: <code>date</code>。</li><li><strong>cal</strong>: 显示日历。<br>示例: <code>cal</code>。</li></ul><h4 id="6.-%E5%8C%85%E7%AE%A1%E7%90%86%EF%BC%88package-management%EF%BC%89---ubuntu-%E4%B8%93%E5%B1%9E-apt" tabindex="-1">6. 包管理（Package Management） - Ubuntu 专属 APT</h4><ul><li><strong>apt update</strong>: 更新软件包列表。<br>示例: <code>sudo apt update</code>。</li><li><strong>apt upgrade</strong>: 升级已安装软件包。<br>示例: <code>sudo apt upgrade</code>。</li><li><strong>apt install</strong>: 安装软件包。<br>示例: <code>sudo apt install vim</code>。</li><li><strong>apt remove</strong>: 卸载软件包。<br>示例: <code>sudo apt remove vim</code>。</li><li><strong>apt search</strong>: 搜索软件包。<br>示例: <code>apt search nginx</code>。</li><li><strong>apt autoremove</strong>: 移除无用依赖包。<br>示例: <code>sudo apt autoremove</code>。</li><li><strong>snap install</strong>: 安装 Snap 包。<br>示例: <code>sudo snap install spotify</code>。</li><li><strong>dpkg -l</strong>: 列出已安装的 deb 包。<br>示例: <code>dpkg -l | grep vim</code>。</li></ul><h4 id="7.-%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4%EF%BC%88networking%EF%BC%89" tabindex="-1">7. 网络命令（Networking）</h4><ul><li><strong>ping</strong>: 测试网络连通性。<br>示例: <code>ping google.com</code>。</li><li><strong>ifconfig</strong>: 显示/配置网络接口（旧版）。<br>示例: <code>ifconfig</code>。</li><li><strong>ip</strong>: 显示/配置网络接口（新版）。<br>示例: <code>ip addr show</code>。</li><li><strong>curl</strong>: 从 URL 下载或发送数据。<br>示例: <code>curl https://example.com</code>。</li><li><strong>wget</strong>: 下载文件。<br>示例: <code>wget https://file.zip</code>。</li><li><strong>ssh</strong>: 安全远程登录。<br>示例: <code>ssh user@host</code>。</li><li><strong>scp</strong>: 安全复制文件到远程主机。<br>示例: <code>scp file.txt user@host:/path</code>。</li><li><strong>netstat</strong>: 显示网络连接（需安装 net-tools）。<br>示例: <code>netstat -tuln</code>。</li><li><strong>ss</strong>: 显示套接字统计（现代版 netstat）。<br>示例: <code>ss -tuln</code>。</li><li><strong>dig</strong>: DNS 查询工具。<br>示例: <code>dig example.com</code>。</li></ul><h4 id="8.-%E5%8E%8B%E7%BC%A9%E5%92%8C%E5%BD%92%E6%A1%A3%EF%BC%88compression-%26-archiving%EF%BC%89" tabindex="-1">8. 压缩和归档（Compression &amp; Archiving）</h4><ul><li><strong>tar</strong>: 创建/提取 tar 归档。<br>示例: <code>tar -czf archive.tar.gz folder/</code>。</li><li><strong>gzip</strong>: 压缩文件。<br>示例: <code>gzip file.txt</code>。</li><li><strong>gunzip</strong>: 解压 gz 文件。<br>示例: <code>gunzip file.txt.gz</code>。</li><li><strong>zip</strong>: 创建 zip 归档。<br>示例: <code>zip archive.zip file.txt</code>。</li><li><strong>unzip</strong>: 解压 zip 文件。<br>示例: <code>unzip archive.zip</code>。</li></ul><h4 id="9.-%E6%90%9C%E7%B4%A2%E5%92%8C%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%EF%BC%88search-%26-text-processing%EF%BC%89" tabindex="-1">9. 搜索和文本处理（Search &amp; Text Processing）</h4><ul><li><strong>grep</strong>: 在文件中搜索文本。<br>示例: <code>grep &quot;error&quot; log.txt</code>。</li><li><strong>find</strong>: 搜索文件（见文件管理）。</li><li><strong>locate</strong>: 快速搜索文件位置（需更新数据库）。<br>示例: <code>locate filename</code>。</li><li><strong>which</strong>: 显示命令的可执行路径。<br>示例: <code>which ls</code>。</li><li><strong>whereis</strong>: 查找命令的二进制、源和手册位置。<br>示例: <code>whereis ls</code>。</li><li><strong>whatis</strong>: 显示命令的简短描述。<br>示例: <code>whatis ls</code>。</li><li><strong>man</strong>: 显示命令的手册。<br>示例: <code>man ls</code>。</li><li><strong>apropos</strong>: 根据关键词搜索命令。<br>示例: <code>apropos network</code>。</li></ul><h4 id="10.-%E6%9C%8D%E5%8A%A1%E5%92%8C%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%EF%BC%88services-%26-system-admin%EF%BC%89" tabindex="-1">10. 服务和系统管理（Services &amp; System Admin）</h4><ul><li><strong>service</strong>: 管理系统服务。<br>示例: <code>sudo service ssh start</code>。</li><li><strong>systemctl</strong>: 管理 systemd 服务（现代版）。<br>示例: <code>sudo systemctl status ssh</code>。</li><li><strong>reboot</strong>: 重启系统。<br>示例: <code>sudo reboot</code>。</li><li><strong>shutdown</strong>: 关机或重启。<br>示例: <code>sudo shutdown -h now</code>。</li><li><strong>history</strong>: 显示命令历史。<br>示例: <code>history</code>。</li><li><strong>clear</strong>: 清空终端屏幕。<br>示例: <code>clear</code>。</li><li><strong>alias</strong>: 创建命令别名。<br>示例: <code>alias ll='ls -la'</code>。</li><li><strong>env</strong>: 显示当前环境变量。<br>示例: <code>env</code>。</li><li><strong>export</strong>: 设置环境变量。<br>示例: <code>export PATH=$PATH:/newpath</code>。</li></ul><h4 id="11.-%E5%85%B6%E4%BB%96%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%88miscellaneous%EF%BC%89" tabindex="-1">11. 其他实用命令（Miscellaneous）</h4><ul><li><strong>bc</strong>: 命令行计算器。<br>示例: <code>echo &quot;2+2&quot; | bc</code>。</li><li><strong>sort</strong>: 排序文件行。<br>示例: <code>sort file.txt</code>。</li><li><strong>uniq</strong>: 去除重复行。<br>示例: <code>sort file.txt | uniq</code>。</li><li><strong>wc</strong>: 统计行数/字数。<br>示例: <code>wc -l file.txt</code>。</li><li><strong>diff</strong>: 比较两个文件差异。<br>示例: <code>diff file1.txt file2.txt</code>。</li><li><strong>paste</strong>: 合并文件行。<br>示例: <code>paste file1.txt file2.txt</code>。</li><li><strong>cut</strong>: 提取文件列。<br>示例: <code>cut -d',' -f1 csvfile.csv</code>。</li><li><strong>tr</strong>: 转换/删除字符。<br>示例: <code>tr 'a-z' 'A-Z' &lt; file.txt</code>。</li><li><strong>sed</strong>: 流编辑器，替换文本。<br>示例: <code>sed 's/old/new/g' file.txt</code>。</li><li><strong>awk</strong>: 文本处理工具。<br>示例: <code>awk '&#123;print $1&#125;' file.txt</code> (打印第一列)。</li></ul><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%F0%9F%94%B9-1.-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4&quot; tabindex=&quot;-1&quot;&gt;🔹 1. 基础操作命令&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;功能&lt;</summary>
      
    
    
    
    
    <category term="service" scheme="https://borrowyourhuaji.github.io/tags/service/"/>
    
  </entry>
  
  <entry>
    <title>数位dp</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/</id>
    <published>2025-09-13T15:00:51.000Z</published>
    <updated>2025-09-13T15:01:40.205Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dp%EF%BC%89%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-digit-dp%EF%BC%89%E6%98%AF%E4%B8%80%E7%A7%8D%E5%9F%BA%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%AE%97%E6%B3%95%E6%8A%80%E6%9C%AF%EF%BC%8C%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E-acm-%E7%AB%9E%E8%B5%9B%E3%80%81%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%E4%B8%AD%E3%80%82%E5%AE%83%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9A%84%E4%BD%8D%E6%95%B0%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E4%BE%8B%E5%A6%82%E7%BB%9F%E8%AE%A1%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4%E5%86%85%E6%BB%A1%E8%B6%B3%E7%89%B9%E5%AE%9A%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B4%E6%95%B0%E4%B8%AA%E6%95%B0%E3%80%82%E6%95%B0%E4%BD%8D-dp-%E7%89%B9%E5%88%AB%E9%80%82%E5%90%88%E5%A4%84%E7%90%86%E5%A4%A7%E8%8C%83%E5%9B%B4%EF%BC%88%E5%A6%82-(-10%5E%7B18%7D-)%EF%BC%89%E7%9A%84%E8%AE%A1%E6%95%B0%E9%97%AE%E9%A2%98%EF%BC%8C%E9%80%9A%E8%BF%87%E9%80%90%E4%BD%8D%E6%9E%84%E9%80%A0%E6%95%B0%E5%AD%97%E5%B9%B6%E7%BB%93%E5%90%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%81%BF%E5%85%8D%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE%E3%80%82" tabindex="-1">数位统计 DP（Digit DP）详细解析<br>数位统计 DP（Digit Dynamic Programming，简称 Digit DP）是一种基于动态规划的算法技术，广泛应用于 <strong>ACM 竞赛</strong>、算法设计和计数问题中。它主要用于解决与数字的位数相关的计数问题，例如统计某个范围内满足特定条件的整数个数。数位 DP 特别适合处理大范围（如 ( 10^{18} )）的计数问题，通过逐位构造数字并结合动态规划避免暴力枚举。</h2><h2 id="1.-%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">1. 数位统计 DP 的基本概念</h2><h3 id="1.1-%E5%AE%9A%E4%B9%89" tabindex="-1">1.1 定义</h3><p>数位 DP 是一种用于统计某个范围内整数个数（或满足特定条件的数字）的动态规划方法，通常问题形式如下：</p><ul><li>给定一个范围 ([L, R])（例如 ( L, R \leq 10^{18} )）。</li><li>要求统计 ([L, R]) 内满足特定条件的整数个数，例如：<ul><li>数字的各位之和为某个值（如和为 ( K )）。</li><li>数字中不含某位（如不含 4）。</li><li>数字是某个数的倍数（如是 3 的倍数）。</li><li>数字的各位满足某种模式（如单调递增）。</li></ul></li><li><strong>目标</strong>：<ul><li>计算满足条件的整数个数。</li><li>（可选）输出满足条件的数字。</li></ul></li><li><strong>输出</strong>：<ul><li>满足条件的整数个数（可能需要模 ( 10^9+7 )）。</li><li>（可选）一个或多个满足条件的数字。<br><strong>示例</strong>：</li></ul></li><li>输入：( L = 1, R = 100 )，条件：数字的各位之和是 5。</li><li>满足条件的数字：<ul><li>5（( 5 = 5 )）</li><li>14（( 1 + 4 = 5 )）</li><li>23（( 2 + 3 = 5 )）</li><li>32（( 3 + 2 = 5 )）</li><li>41（( 4 + 1 = 5 )）</li><li>50（( 5 + 0 = 5 )）</li></ul></li><li>输出：6（满足条件的数字个数）。</li><li>答案计算：统计 ([1, 100]) 内各位之和为 5 的数字个数，通常用 ( f® - f(L-1) )，其中 ( f(x) ) 表示 ( [1, x] ) 内满足条件的数字个数。<br><strong>关键特点</strong>：</li><li><strong>逐位构造</strong>：从高位到低位逐位确定数字，动态维护状态。</li><li><strong>范围处理</strong>：通过 ( f® - f(L-1) ) 计算 ([L, R]) 的答案。</li><li><strong>状态压缩</strong>：用 DP 状态记录前缀信息（如当前数字、前缀和、模数等）。</li><li><strong>记忆化</strong>：避免重复计算重叠子问题。</li><li><strong>大范围适用</strong>：适合 ( R \leq 10^{18} )，暴力枚举不可行。</li></ul><h3 id="1.2-%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B" tabindex="-1">1.2 数学模型</h3><ul><li><strong>输入</strong>：<ul><li>范围：( L, R )（整数，( 1 \leq L \leq R \leq 10^{18} )）。</li><li>条件：数字的性质（例如，各位之和、模 ( K )、不含某位）。</li></ul></li><li><strong>目标</strong>：<ul><li>计算 ([L, R]) 内满足条件的整数个数 ( C )。</li><li>通常通过 ( f® - f(L-1) )，其中 ( f(x) ) 是 ( [1, x] ) 内满足条件的个数。</li></ul></li><li><strong>输出</strong>：<ul><li>( C )（整数，可能模 ( 10^9+7 )）。</li><li>（可选）满足条件的数字。</li></ul></li><li><strong>约束</strong>：<ul><li>数字范围大（( 10^{18} )），需高效算法。</li><li>条件基于数字的位（十进制或二进制）。</li></ul></li></ul><h3 id="1.3-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">1.3 与其他问题的对比</h3><table><thead><tr><th><strong>问题</strong></th><th><strong>定义</strong></th><th><strong>Goal</strong></th><th><strong>DP 状态</strong></th><th><strong>Complexity</strong></th></tr></thead><tbody><tr><td>数位 DP</td><td>统计范围内满足位数条件的整数个数</td><td>满足条件的个数</td><td>( dp[pos][state] ): 第 pos 位的状态</td><td>( O(\log R \cdot S) )</td></tr><tr><td>子集和</td><td>集合中找子集和为 T</td><td>判断是否存在子集</td><td>( dp[i][s] ): 前 i 个元素和为 s</td><td>( O(n \times T) )</td></tr><tr><td>布尔括号</td><td>加括号使布尔表达式为 True 的方案数</td><td>True 方案数</td><td>( dp[i][j][b] ): 子表达式 [i:j] 为 b</td><td>( O(n^3) )</td></tr><tr><td>矩阵链乘法</td><td>确定矩阵乘法顺序，最小化乘法次数</td><td>最小乘法次数</td><td>( dp[i][j] ): 子链 [i:j] 最小代价</td><td>( O(n^3) )</td></tr></tbody></table><ul><li><strong>数位 DP vs 子集和</strong>：<ul><li>数位 DP：基于数字位，计数问题。</li><li>子集和：基于集合，存在性问题。</li></ul></li><li><strong>数位 DP vs 布尔括号</strong>：<ul><li>数位 DP：逐位构造，范围计数。</li><li>布尔括号：区间 DP，括号计数。</li></ul></li><li><strong>数位 DP vs 矩阵链乘法</strong>：<ul><li>数位 DP：数字位优化，计数。</li><li>矩阵链乘法：乘法顺序优化，最小代价。</li></ul></li></ul><h3 id="1.4-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">1.4 应用场景</h3><ul><li><strong>ACM 竞赛</strong>：<ul><li>计数问题：Codeforces 1036C（Classy Numbers）。</li><li>模运算：AtCoder ABC 162F（Digits）。</li><li>路径恢复：SPOJ NDIGITS（输出数字）。</li><li>变种：HDU 4352（XHXJ’s LIS，数位 DP + 状态压缩）。</li></ul></li><li><strong>实际应用</strong>：<ul><li>密码学：统计满足条件的数字（如模 ( K )）。</li><li>数据库：范围查询优化。</li><li>数据分析：数字模式统计。</li><li>编码：数字编码方案计数。</li></ul></li></ul><hr><h2 id="2.-%E6%95%B0%E4%BD%8D-dp-%E7%9A%84%E8%A7%A3%E6%B3%95" tabindex="-1">2. 数位 DP 的解法</h2><p>数位 DP 通过逐位构造数字并维护状态，结合动态规划解决计数问题。以下详细讲解主要解法：记忆化递归、动态规划、路径恢复。</p><h3 id="2.1-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%88%E6%A0%87%E5%87%86%E6%95%B0%E4%BD%8D-dp%EF%BC%89" tabindex="-1">2.1 记忆化递归（标准数位 DP）</h3><ul><li><strong>思路</strong>：<ul><li>将数字从高位到低位逐位构造，记录当前状态（如当前位、是否贴近上界、前缀和等）。</li><li>使用记忆化递归避免重复计算。</li><li>计算 ( f(x) )，即 ( [1, x] ) 内满足条件的数字个数。</li><li>答案为 ( f® - f(L-1) ).</li></ul></li><li><strong>状态定义</strong>：<ul><li>( dp[pos][state] )：从第 ( pos ) 位开始构造，当前状态为 ( state )，满足条件的数字个数。</li><li>常见状态：<ul><li>( pos ): 当前处理的位（从高到低）。</li><li>( tight ): 是否贴近上界（1: 必须 ≤ 当前位的数字，0: 可取 0-9）。</li><li>( sum ): 前缀数字之和（若条件是和为 ( K )）。</li><li>( mod ): 前缀模 ( K )（若条件是 ( K ) 的倍数）。</li><li>( lead ): 是否允许前导零（1: 允许，0: 不允许）。</li></ul></li></ul></li><li><strong>状态转移</strong>：<ul><li>对于第 ( pos ) 位：<ul><li>若 ( tight = 1 )，可选数字 ( d \in [0, \text{digit[pos]}] ).</li><li>若 ( tight = 0 )，可选数字 ( d \in [0, 9] ).</li><li>新状态：<ul><li>( new_tight = 1 ) 若 ( d = \text{digit[pos]} ) 且 ( tight = 1 )，否则 0。</li><li>更新 ( sum, mod, lead ) 等状态。</li></ul></li><li>递归到下一位：<br>[<br>dp[pos][state] = \sum_{d} dp[pos+1][new_state]<br>]</li></ul></li><li>终止条件：<ul><li>( pos = \text{len(digits)} )，检查是否满足条件（如 ( sum = K )）。</li></ul></li></ul></li><li><strong>初始调用</strong>：<ul><li>( solve(0, 1, 0, 1) )，表示从第 0 位开始，贴近上界，无前缀和，允许前导零。</li></ul></li><li><strong>复杂度</strong>：<ul><li>时间：( O(\log R \cdot S) )，其中 ( S ) 是状态数（如 ( 10 \cdot K )）。</li><li>空间：( O(\log R \cdot S) )，记忆化表格。</li></ul></li><li><strong>适用性</strong>：ACM 竞赛标配，适合 ( R \leq 10^{18} )，时间 ≥ 1 秒。</li></ul><h3 id="2.2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92" tabindex="-1">2.2 动态规划</h3><ul><li><strong>思路</strong>：<ul><li>将记忆化递归转为递推形式，填充 DP 表格。</li><li>从低位到高位迭代，状态同记忆化。</li></ul></li><li><strong>实现</strong>：<ul><li>较少使用，因数位 DP 通常递归更直观。</li><li>适用场景：状态简单，需显式 DP 表格。</li></ul></li><li><strong>复杂度</strong>：<ul><li>同记忆化递归。</li></ul></li><li><strong>适用性</strong>：调试复杂问题或需显式表格。</li></ul><h3 id="2.3-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D" tabindex="-1">2.3 路径恢复</h3><ul><li><strong>目标</strong>：<ul><li>输出一个或多个满足条件的数字。</li></ul></li><li><strong>方法</strong>：<ul><li>在 DP 过程中记录每个状态的选择（选的数字 ( d )）。</li><li>从 ( dp[0][初始状态] ) 回溯，构造数字。</li></ul></li><li><strong>实现</strong>：<ul><li>用数组 ( choice[pos][state] ) 记录 ( d ).</li><li>回溯构造数字字符串。</li></ul></li><li><strong>复杂度</strong>：<ul><li>时间：( O(\log R \cdot S) )（DP）+ ( O(\log R) )（回溯）。</li><li>空间：( O(\log R \cdot S) ).</li></ul></li><li><strong>适用性</strong>：ACM 题目要求输出数字。</li></ul><h3 id="2.4-%E5%8F%98%E7%A7%8D%E4%B8%8E%E4%BC%98%E5%8C%96" tabindex="-1">2.4 变种与优化</h3><ul><li><strong>模运算</strong>：<ul><li>答案模 ( 10^9+7 ).</li></ul></li><li><strong>前导零</strong>：<ul><li>控制是否允许前导零（常见于严格递增条件）。</li></ul></li><li><strong>状态压缩</strong>：<ul><li>若条件复杂（如 LIS），用位掩码压缩状态。</li></ul></li><li><strong>多条件</strong>：<ul><li>同时满足多个条件（如和为 ( K )，是 ( M ) 的倍数）。</li></ul></li><li><strong>空间优化</strong>：<ul><li>滚动数组或清空记忆化表格，空间降到 ( O(S) ).</li></ul></li></ul><hr><h2 id="3.-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">3. 复杂度分析</h2><table><thead><tr><th><strong>方法</strong></th><th><strong>时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>记忆化递归</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>标准问题，( R \leq 10^{18} )，时间 ≥ 1s</td></tr><tr><td>动态规划</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>调试复杂状态，显式表格</td></tr><tr><td>路径恢复</td><td>( O(\log R \cdot S) )</td><td>( O(\log R \cdot S) )</td><td>需输出数字，( R \leq 10^{18} )</td></tr></tbody></table><ul><li><strong>时间</strong>：( O(\log R \cdot S) )，( \log R ) 是位数，( S ) 是状态数（例如 ( 10 \cdot K )）。</li><li><strong>空间</strong>：( O(\log R \cdot S) )，可优化到 ( O(S) ).</li><li><strong>ACM 限制</strong>：<ul><li>( R \leq 10^{18} )，位数 ( \leq 18 )，时间 ≥ 1 秒，Python 适用。</li><li>复杂状态（( S \geq 10^6 )）需 C++.</li></ul></li></ul><hr><h2 id="4.-%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">4. 在 ACM 竞赛中的应用</h2><p>数位 DP 是 ACM 竞赛中的核心计数技术，常见于大范围计数、模运算和变种问题。以下是应用场景和解题思路：</p><ol><li><strong>标准数位 DP</strong>：<ul><li><strong>题目</strong>：Codeforces 1036C（Classy Numbers，非零位 ≤ 3）。</li><li><strong>解法</strong>：记忆化递归。</li><li><strong>方法</strong>：<ul><li>状态：( dp[pos][tight][cnt] )，( cnt ) 为非零位数。</li><li>转移：枚举当前位 ( d )，更新 ( cnt ).</li><li>答案：( f® - f(L-1) ).</li><li>复杂度：时间 ( O(\log R \cdot 10 \cdot 4) ).</li></ul></li><li><strong>Python 优势</strong>：字符串和列表操作简洁。</li></ul></li><li><strong>路径恢复</strong>：<ul><li><strong>题目</strong>：SPOJ NDIGITS（输出满足条件的数字）。</li><li><strong>解法</strong>：DP + 路径恢复。</li><li><strong>方法</strong>：<ul><li>DP 计算满足条件的个数。</li><li>记录选择，回溯构造数字。</li><li>复杂度：时间 ( O(\log R \cdot S) ).</li></ul></li><li><strong>Python 优势</strong>：字符串拼接和回溯直观。</li></ul></li><li><strong>变种问题</strong>：<ul><li><strong>模运算</strong>：HDU 3652（B-number，含 13 且被 13 整除）。</li><li><strong>状态压缩</strong>：HDU 4352（XHXJ’s LIS，数位 DP + LIS）。</li><li><strong>多条件</strong>：AtCoder ABC 162F（Digits，多个约束）。</li><li><strong>示例</strong>：Codeforces 628D（Magic Numbers）。</li><li><strong>方法</strong>：扩展状态（如模、模式匹配）。</li><li><strong>Python 优势</strong>：条件判断和多维数组简洁。<br><strong>ACM 优化技巧</strong>：</li></ul></li></ol><ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>模运算</strong>：防止溢出，模 ( 10^9+7 ).</li><li><strong>状态压缩</strong>：用位掩码或整数压缩复杂状态。</li><li><strong>调试</strong>：打印 DP 表格或构造的数字，验证转移。</li><li><strong>边界处理</strong>：注意 ( L=1 )、前导零、紧界。<br><strong>Python 在 ACM 中的适用性</strong>：</li><li><strong>优点</strong>：<ul><li>代码简洁：DP 约 40-60 行，路径恢复 60-80 行，比赛中 10-15 分钟实现。</li><li>调试方便：打印状态或数字，验证正确性。</li><li>适用：( \log R \leq 18 )，状态 ( S \leq 10^5 )，时间 ≥ 1 秒。</li></ul></li><li><strong>缺点</strong>：<ul><li>效率：Python 比 C++ 慢 5-10 倍，复杂状态可能 TLE。</li><li>内存：Python 数组占用较多，需优化。</li></ul></li><li><strong>优化</strong>：<ul><li>快速 I/O：<code>input = sys.stdin.readline</code>.</li><li>滚动数组：空间降到 ( O(S) ).</li><li>Cython/Numba：加速循环（非比赛场景）。<br><strong>ACM 题目推荐</strong>：</li></ul></li><li>Codeforces 1036C：Classy Numbers（非零位 ≤ 3）。</li><li>HDU 3652：B-number（含 13 且被 13 整除）。</li><li>SPOJ NDIGITS：Number of Digits（路径恢复）。</li><li>AtCoder ABC 162F：Digits（多条件）。</li><li>Codeforces 628D：Magic Numbers（模运算）。</li></ul><hr><h2 id="5.-python-%E5%AE%9E%E7%8E%B0" tabindex="-1">5. Python 实现</h2><p>以下通过数位 DP 的两种典型问题（各位之和为 ( K )、路径恢复）提供 Python 实现，带详细注释，适合 ACM 竞赛。代码格式优化以确保在 OneNote 中清晰显示。</p><h3 id="5.1-%E5%90%84%E4%BD%8D%E4%B9%8B%E5%92%8C%E4%B8%BA-k%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%89" tabindex="-1">5.1 各位之和为 K（记忆化递归）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp_sum_k</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">digits: <span class="built_in">list</span>, pos: <span class="built_in">int</span>, tight: <span class="built_in">int</span>, sum_digits: <span class="built_in">int</span>, lead: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum_digits &gt; K:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dp[pos][tight][sum_digits][lead] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[pos][tight][sum_digits][lead]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        limit = digits[pos] <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">            new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">            new_sum = sum_digits + d</span><br><span class="line">            new_lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            ans = (ans + solve(digits, pos + <span class="number">1</span>, new_tight, new_sum, new_lead)) % MOD</span><br><span class="line">        dp[pos][tight][sum_digits][lead] = ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(x)]</span><br><span class="line">        <span class="keyword">global</span> dp</span><br><span class="line">        dp = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> solve(digits, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (count(R) - count(L - <span class="number">1</span>)) % MOD</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Count of numbers with sum of digits =&quot;</span>, K, <span class="string">&quot;:&quot;</span>, digit_dp_sum_k(L, R, K))</span><br></pre></td></tr></table></figure><h3 id="5.2-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D%EF%BC%88%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E6%95%B0%E5%AD%97%EF%BC%89" tabindex="-1">5.2 路径恢复（输出一个满足条件的数字）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line">MOD = <span class="number">1000000007</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp_path</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">tuple</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数，并返回一个数字&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">digits: <span class="built_in">list</span>, pos: <span class="built_in">int</span>, tight: <span class="built_in">int</span>, sum_digits: <span class="built_in">int</span>, lead: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> pos == <span class="built_in">len</span>(digits):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> sum_digits &gt; K:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> dp[pos][tight][sum_digits][lead] != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> dp[pos][tight][sum_digits][lead]</span><br><span class="line">        </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        limit = digits[pos] <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">            new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">            new_sum = sum_digits + d</span><br><span class="line">            new_lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            cnt = solve(digits, pos + <span class="number">1</span>, new_tight, new_sum, new_lead)</span><br><span class="line">            <span class="keyword">if</span> cnt &gt; <span class="number">0</span> <span class="keyword">and</span> choice[pos][tight][sum_digits][lead] == -<span class="number">1</span>:</span><br><span class="line">                choice[pos][tight][sum_digits][lead] = d</span><br><span class="line">            ans = (ans + cnt) % MOD</span><br><span class="line">        dp[pos][tight][sum_digits][lead] = ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">x: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(x)]</span><br><span class="line">        <span class="keyword">global</span> dp, choice</span><br><span class="line">        dp = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        choice = [[[[-<span class="number">1</span>] * <span class="number">2</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(digits) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">return</span> solve(digits, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯构造数字</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">construct</span>(<span class="params">digits: <span class="built_in">list</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        result = []</span><br><span class="line">        pos, tight, sum_digits, lead = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> pos &lt; <span class="built_in">len</span>(digits):</span><br><span class="line">            d = choice[pos][tight][sum_digits][lead]</span><br><span class="line">            <span class="keyword">if</span> d == -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            result.append(<span class="built_in">str</span>(d))</span><br><span class="line">            tight = tight <span class="keyword">and</span> d == digits[pos]</span><br><span class="line">            sum_digits += d</span><br><span class="line">            lead = lead <span class="keyword">and</span> d == <span class="number">0</span></span><br><span class="line">            pos += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(result) <span class="keyword">if</span> sum_digits == K <span class="keyword">and</span> lead == <span class="number">0</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算答案</span></span><br><span class="line">    ans = (count(R) - count(L - <span class="number">1</span>)) % MOD</span><br><span class="line">    digits = [<span class="built_in">int</span>(d) <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">str</span>(R)]</span><br><span class="line">    number = construct(digits)</span><br><span class="line">    <span class="keyword">return</span> ans, number</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">count, number = digit_dp_path(L, R, K)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Count of numbers with sum of digits =&quot;</span>, K, <span class="string">&quot;:&quot;</span>, count)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;One such number:&quot;</span>, number <span class="keyword">if</span> number <span class="keyword">else</span> <span class="string">&quot;None&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="6.-%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B" tabindex="-1">6. 运行过程</h2><h3 id="%E8%BE%93%E5%85%A5" tabindex="-1">输入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 100 5</span><br></pre></td></tr></table></figure><ul><li>( L = 1, R = 100, K = 5 )</li><li>条件：各位之和为 5。</li></ul><h3 id="6.1-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92" tabindex="-1">6.1 记忆化递归</h3><ul><li><strong>计算 ( f(100) )</strong>：<ul><li>数字：( [1, 0, 0] )，3 位。</li><li>初始：( solve(0, 1, 0, 1) ).</li><li>( pos=0, tight=1, sum=0, lead=1 ):<ul><li>( d=0 ): ( solve(1, 1, 0, 1) ).</li><li>( d=1 ): ( solve(1, 1, 1, 0) ).</li><li>( d=2 ): ( solve(1, 0, 2, 0) ).</li><li>…</li></ul></li><li>( pos=3 ): 检查 ( sum == 5 ).</li><li>结果：6（14, 23, 32, 41, 50, 5）。</li></ul></li><li><strong>计算 ( f(0) )</strong>：<ul><li>结果：0（无数字）。</li></ul></li><li><strong>答案</strong>：( f(100) - f(0) = 6 - 0 = 6 ).</li><li><strong>Space</strong>：( O(\log R \cdot 10 \cdot K) = O(3 \cdot 2 \cdot 6) ).<br><strong>Output</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count of numbers with sum of digits = 5 : 6</span><br></pre></td></tr></table></figure><h3 id="6.2-%E8%B7%AF%E5%BE%84%E6%81%A2%E5%A4%8D" tabindex="-1">6.2 路径恢复</h3><ul><li><strong>DP 和 choice 表格</strong>：<ul><li>同记忆化，( f(100) = 6 ).</li><li>( choice[0][1][0][1] = 1 )（选 1）。</li><li>( choice[1][1][1][0] = 4 )（选 4）。</li></ul></li><li><strong>回溯</strong>：<ul><li>( pos=0, tight=1, sum=0, lead=1 ): ( d=1 ).</li><li>( pos=1, tight=1, sum=1, lead=0 ): ( d=4 ).</li><li>( pos=2 ): ( sum=5 )，结束。</li><li>结果：( 14 ).</li></ul></li><li><strong>答案</strong>：个数 6，数字 14（可能不同，如 23）。</li><li><strong>Space</strong>：( O(\log R \cdot 10 \cdot K) ).<br><strong>Output</strong>:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Count of numbers with sum of digits = 5 : 6</span><br><span class="line">One such number: 14</span><br></pre></td></tr></table></figure><hr><h2 id="7.-%E6%95%B0%E4%BD%8D-dp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1">7. 数位 DP 的优缺点</h2><h3 id="7.1-%E4%BC%98%E7%82%B9" tabindex="-1">7.1 优点</h3><ul><li><strong>高效计数</strong>：( O(\log R \cdot S) )，适合 ( R \leq 10^{18} ).</li><li><strong>灵活状态</strong>：支持多种条件（如和、模、模式）。</li><li><strong>ACM 友好</strong>：Python 实现约 40-80 行，比赛中 10-15 分钟完成。</li><li><strong>调试方便</strong>：打印状态或构造数字，验证正确性。</li><li><strong>路径恢复</strong>：可输出满足条件的数字。</li></ul><h3 id="7.2-%E7%BC%BA%E7%82%B9" tabindex="-1">7.2 缺点</h3><ul><li><strong>状态设计复杂</strong>：需根据条件设计状态（如模、LIS）。</li><li><strong>空间需求</strong>：( O(\log R \cdot S) )，大状态数超内存。</li><li><strong>ACM 限制</strong>：<ul><li>复杂状态（( S \geq 10^6 )）需 C++.</li><li>路径恢复增加实现难度。</li></ul></li><li><strong>边界处理</strong>：<ul><li>注意 ( L=1 )、前导零、紧界。</li></ul></li></ul><h3 id="7.3-%E6%94%B9%E8%BF%9B%E6%96%B9%E5%90%91" tabindex="-1">7.3 改进方向</h3><ul><li><strong>空间优化</strong>：滚动数组，空间降到 ( O(S) ).</li><li><strong>状态压缩</strong>：用位掩码或整数压缩。</li><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code>.</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）.</li><li><strong>预处理</strong>：常见条件预计算（如模表）。</li></ul><hr><h2 id="8.-%E4%B8%8E%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">8. 与其他问题的对比</h2><ul><li><strong>数位 DP vs 子集和</strong>：<ul><li>数位 DP：逐位构造，范围计数。</li><li>子集和：组合优化，存在性.</li></ul></li><li><strong>数位 DP vs 布尔括号</strong>：<ul><li>数位 DP：数字位计数。</li><li>布尔括号：区间 DP，逻辑计数.</li></ul></li><li><strong>数位 DP vs 矩阵链乘法</strong>：<ul><li>数位 DP：计数问题。</li><li>矩阵链乘法：优化代价.</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>数位 DP：大范围计数。</li><li>子集和：背包 DP。</li><li>布尔括号：区间 DP。</li><li>矩阵链乘法：区间 DP。</li></ul></li></ul><hr><h2 id="9.-%E6%80%BB%E7%BB%93" tabindex="-1">9. 总结</h2><p>数位 DP 是解决大范围数字计数问题的强大工具，通过逐位构造和动态规划高效统计：</p><ul><li><strong>核心方法</strong>：<ul><li>记忆化递归：时间 ( O(\log R \cdot S) )，ACM 标配。</li><li>路径恢复：输出满足条件的数字。</li></ul></li><li><strong>ACM 应用</strong>：<ul><li>标准计数（Codeforces 1036C）。</li><li>路径恢复（SPOJ NDIGITS）。</li><li>变种（HDU 4352）。</li></ul></li><li><strong>Python 实现</strong>：约 40-80 行，比赛中 10-15 分钟，适合 ( \log R \leq 18 )，时间 ≥ 1 秒。</li><li><strong>优化</strong>：模运算、快速 I/O、状态压缩。<br>通过记忆化递归和路径恢复的 Python 代码及模拟，展示了数位 DP 的实现和运行过程。在 ACM 竞赛中，数位 DP 是处理大范围计数的核心技术，Python 实现简洁高效。<br><strong>学习建议</strong>：</li></ul><ol><li><strong>手动模拟</strong>：<ul><li>用小数据（如 ( R=20, K=5 )）手动构造数字，验证状态转移。</li></ul></li><li><strong>ACM 练习</strong>：<ul><li>Codeforces 1036C、HDU 3652、SPOJ NDIGITS，用 Python 实现。</li></ul></li><li><strong>深入扩展</strong>：<ul><li>学习状态压缩（HDU 4352）、多条件、模运算。</li></ul></li><li><strong>比赛策略</strong>：<ul><li>优先实现记忆化递归，验证正确性。</li><li>若需数字，添加路径恢复。</li><li>若时间严格，考虑 C++.</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%AE%A1-dp%EF%BC%88digit-dp%EF%BC%89%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E6%95%B0%E4%BD%8D%E7%BB%9F%E8%</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>yolo</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/yolo/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/yolo/</id>
    <published>2025-09-13T13:57:08.000Z</published>
    <updated>2025-09-13T14:01:34.318Z</updated>
    
    <content type="html"><![CDATA[<h1 id="%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B" tabindex="-1">使用 Ultralytics YOLO 进行模型预测</h1><h2 id="%E7%AE%80%E4%BB%8B" tabindex="-1">简介</h2><p>在<strong>机器学习</strong>和<strong>计算机视觉</strong>领域，对视觉数据进行理解处理的过程称为“推理”（‘inference’）或“预测”（‘prediction’）。Ultralytics YOLO11 提供了一项强大的功能，即<strong>预测模式</strong>，专为对各种数据源进行高性能、实时推理而量身定制。</p><h2 id="%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8" tabindex="-1">实际应用</h2><table><thead><tr><th style="text-align:center">制造业</th><th style="text-align:center">体育</th><th style="text-align:center">安全</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">汽车备件检测</td><td style="text-align:center">足球运动员检测</td><td style="text-align:center">人员跌倒检测</td></tr></tbody></table><h2 id="%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%8E%A8%E7%90%86%EF%BC%9F" tabindex="-1">为什么选择 Ultralytics YOLO 进行推理？</h2><p>以下是你应该考虑将 YOLO11 的预测模式用于各种推理需求的原因：</p><ul><li><strong>多功能性</strong>：能够对图像、视频甚至直播流进行推理。</li><li><strong>性能</strong>：专为实时、高速处理而设计，同时不牺牲<strong>准确性</strong>。</li><li><strong>易用性</strong>：直观的 Python 和 CLI 界面，可实现快速部署和测试。</li><li><strong>高度可定制</strong>：提供各种设置和参数，以根据你的特定要求调整模型的推理行为。</li></ul><h3 id="%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD" tabindex="-1">预测模式的关键功能</h3><p>YOLO11 的预测模式设计得既稳健又通用，具备以下特点：</p><ul><li><strong>多数据源兼容性</strong>：无论你的数据是单个图像、一系列图像、视频文件还是实时视频流，预测模式都能处理。</li><li><strong>流式处理模式</strong>：使用流式处理功能可以生成一个内存高效的 <code>Results</code> 对象生成器。通过在预测器的调用方法中设置 <code>stream=True</code> 来启用此功能。</li><li><strong>批量处理</strong>：能够一次性处理多张图像或视频帧，进一步加快推理时间。</li><li><strong>易于集成</strong>：由于其灵活的 API，可以轻松集成到现有的数据管道和其他软件组件中。</li></ul><p>Ultralytics YOLO 模型在推理时，如果传递了 <code>stream=True</code>，则返回一个内存高效的 <code>Results</code> 对象生成器；否则，返回一个 <code>Results</code> 对象列表。</p><p>!!! example “预测”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">=== &quot;使用 `stream=False` 返回列表&quot;</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)  # 预训练的 YOLO11n 模型</span><br><span class="line"></span><br><span class="line">    # 对图像列表进行批量推理</span><br><span class="line">    results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;])  # 返回一个 Results 对象列表</span><br><span class="line"></span><br><span class="line">    # 处理结果列表</span><br><span class="line">    for result in results:</span><br><span class="line">        boxes = result.boxes  # 用于边界框输出的 Boxes 对象</span><br><span class="line">        masks = result.masks  # 用于分割掩码输出的 Masks 对象</span><br><span class="line">        keypoints = result.keypoints  # 用于姿态输出的 Keypoints 对象</span><br><span class="line">        probs = result.probs  # 用于分类输出的 Probs 对象</span><br><span class="line">        obb = result.obb  # 用于 OBB 输出的定向框对象</span><br><span class="line">        result.show()  # 显示到屏幕</span><br><span class="line">        result.save(filename=&quot;result.jpg&quot;)  # 保存到磁盘</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;使用 `stream=True` 返回生成器&quot;</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)  # 预训练的 YOLO11n 模型</span><br><span class="line"></span><br><span class="line">    # 对图像列表进行批量推理</span><br><span class="line">    results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;], stream=True)  # 返回一个 Results 对象生成器</span><br><span class="line"></span><br><span class="line">    # 处理结果生成器</span><br><span class="line">    for result in results:</span><br><span class="line">        boxes = result.boxes  # 用于边界框输出的 Boxes 对象</span><br><span class="line">        masks = result.masks  # 用于分割掩码输出的 Masks 对象</span><br><span class="line">        keypoints = result.keypoints  # 用于姿态输出的 Keypoints 对象</span><br><span class="line">        probs = result.probs  # 用于分类输出的 Probs 对象</span><br><span class="line">        obb = result.obb  # 用于 OBB 输出的定向框对象</span><br><span class="line">        result.show()  # 显示到屏幕</span><br><span class="line">        result.save(filename=&quot;result.jpg&quot;)  # 保存到磁盘</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure><h2 id="%E6%8E%A8%E7%90%86%E6%BA%90" tabindex="-1">推理源</h2><p>YOLO11 可以处理不同类型的输入源进行推理，如下表所示。来源包括静态图像、视频流和各种数据格式。该表还指出每个源是否可以使用参数 <code>stream=True</code> 在流式处理模式下使用 ✅。流式处理模式对于处理视频或直播流很有用，因为它会创建一个结果生成器，而不是将所有帧都加载到内存中。</p><p>!!! tip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 `stream=True` 来处理长视频或大型数据集，以高效地管理内存。当 `stream=False` 时，所有帧或数据点的结果都存储在内存中，这可能很快累积并导致大型输入出现内存不足错误。相比之下，`stream=True` 使用生成器，它只将当前帧或数据点的结果保存在内存中，从而显著减少内存消耗并防止内存不足问题。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">源</th><th style="text-align:left">示例</th><th style="text-align:left">类型</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">图像</td><td style="text-align:left"><code>'image.jpg'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">单个图像文件。</td></tr><tr><td style="text-align:left">URL</td><td style="text-align:left"><code>'https://ultralytics.com/images/bus.jpg'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">图像的 URL。</td></tr><tr><td style="text-align:left">截图</td><td style="text-align:left"><code>'screen'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">捕获屏幕截图。</td></tr><tr><td style="text-align:left">PIL</td><td style="text-align:left"><code>Image.open('image.jpg')</code></td><td style="text-align:left"><code>PIL.Image</code></td><td style="text-align:left">HWC 格式，带有 RGB 通道。</td></tr><tr><td style="text-align:left"><strong>OpenCV</strong></td><td style="text-align:left"><code>cv2.imread('image.jpg')</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">HWC 格式，带有 BGR 通道 <code>uint8 (0-255)</code>。</td></tr><tr><td style="text-align:left">numpy</td><td style="text-align:left"><code>np.zeros((640,1280,3))</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">HWC 格式，带有 BGR 通道 <code>uint8 (0-255)</code>。</td></tr><tr><td style="text-align:left">torch</td><td style="text-align:left"><code>torch.zeros(16,3,320,640)</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">BCHW 格式，带有 RGB 通道 <code>float32 (0.0-1.0)</code>。</td></tr><tr><td style="text-align:left">CSV</td><td style="text-align:left"><code>'sources.csv'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">包含图像、视频或目录路径的 CSV 文件。</td></tr><tr><td style="text-align:left">视频 ✅</td><td style="text-align:left"><code>'video.mp4'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">格式为 MP4、AVI 等的视频文件。</td></tr><tr><td style="text-align:left">目录 ✅</td><td style="text-align:left"><code>'path/'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left">包含图像或视频的目录路径。</td></tr><tr><td style="text-align:left">glob ✅</td><td style="text-align:left"><code>'path/*.jpg'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">用于匹配多个文件的 glob 模式。使用 <code>*</code> 字符作为通配符。</td></tr><tr><td style="text-align:left">YouTube ✅</td><td style="text-align:left"><code>'https://youtu.be/LNwODJXcvt4'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">YouTube 视频的 URL。</td></tr><tr><td style="text-align:left">流 ✅</td><td style="text-align:left"><code>'rtsp://example.com/media.mp4'</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">用于 RTSP、RTMP、TCP 等流媒体协议或 IP 地址的 URL。</td></tr><tr><td style="text-align:left">多流 ✅</td><td style="text-align:left"><code>'list.streams'</code></td><td style="text-align:left"><code>str</code> 或 <code>Path</code></td><td style="text-align:left"><code>.streams</code> 文本文件，每行一个流 URL，即 8 个流将以批量大小 8 运行。</td></tr><tr><td style="text-align:left">摄像头 ✅</td><td style="text-align:left"><code>0</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">连接的摄像头设备的索引，用于运行推理。</td></tr></tbody></table><p>以下是使用每种源类型的代码示例：</p><p>!!! example “预测源”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line">=== &quot;图像&quot;</span><br><span class="line"></span><br><span class="line">    对图像文件运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义图像文件路径</span><br><span class="line">    source = &quot;path/to/image.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;截图&quot;</span><br><span class="line"></span><br><span class="line">    将当前屏幕内容作为截图运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义当前截图为源</span><br><span class="line">    source = &quot;screen&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;URL&quot;</span><br><span class="line"></span><br><span class="line">    对通过 URL 远程托管的图像或视频运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义远程图像或视频 URL</span><br><span class="line">    source = &quot;https://ultralytics.com/images/bus.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;PIL&quot;</span><br><span class="line"></span><br><span class="line">    对使用 Python Imaging Library (PIL) 打开的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from PIL import Image</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用 PIL 打开图像</span><br><span class="line">    source = Image.open(&quot;path/to/image.jpg&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;OpenCV&quot;</span><br><span class="line"></span><br><span class="line">    对使用 OpenCV 读取的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import cv2</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 使用 OpenCV 读取图像</span><br><span class="line">    source = cv2.imread(&quot;path/to/image.jpg&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;numpy&quot;</span><br><span class="line"></span><br><span class="line">    对表示为 numpy 数组的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import numpy as np</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建一个 HWC 形状 (640, 640, 3)，值范围 [0, 255]，类型为 uint8 的随机 numpy 数组</span><br><span class="line">    source = np.random.randint(low=0, high=255, size=(640, 640, 3), dtype=&quot;uint8&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;torch&quot;</span><br><span class="line"></span><br><span class="line">    对表示为 **PyTorch** 张量的图像运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    import torch</span><br><span class="line"></span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 创建一个 BCHW 形状 (1, 3, 640, 640)，值范围 [0, 1]，类型为 float32 的随机 torch 张量</span><br><span class="line">    source = torch.rand(1, 3, 640, 640, dtype=torch.float32)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;CSV&quot;</span><br><span class="line"></span><br><span class="line">    对 CSV 文件中列出的图像、URL、视频和目录集合运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义一个包含图像、URL、视频和目录的 CSV 文件的路径</span><br><span class="line">    source = &quot;path/to/file.csv&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source)  # Results 对象列表</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;视频&quot;</span><br><span class="line"></span><br><span class="line">    对视频文件运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少内存使用。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义视频文件路径</span><br><span class="line">    source = &quot;path/to/video.mp4&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;目录&quot;</span><br><span class="line"></span><br><span class="line">    对目录中的所有图像和视频运行推理。若要同时捕获子目录中的图像和视频，请使用 glob 模式，例如 `path/to/dir/**/*`。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义包含用于推理的图像和视频的目录路径</span><br><span class="line">    source = &quot;path/to/dir&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;glob&quot;</span><br><span class="line"></span><br><span class="line">    对所有与带有 `*` 字符的 glob 表达式匹配的图像和视频运行推理。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义一个 glob 搜索，以查找目录中的所有 JPG 文件</span><br><span class="line">    source = &quot;path/to/dir/*.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 或者定义一个递归 glob 搜索，以查找包括子目录在内的所有 JPG 文件</span><br><span class="line">    source = &quot;path/to/dir/**/*.jpg&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;YouTube&quot;</span><br><span class="line"></span><br><span class="line">    对 YouTube 视频运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少长视频的内存使用。</span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 定义源为 YouTube 视频 URL</span><br><span class="line">    source = &quot;https://youtu.be/LNwODJXcvt4&quot;</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">=== &quot;流&quot;</span><br><span class="line"></span><br><span class="line">    使用流模式通过 RTSP、RTMP、TCP 或 IP 地址协议对直播流进行推理。如果提供单个流，模型将以**批量大小**为 1 运行推理。对于多个流，可以使用 `.streams` 文本文件执行批量推理，其中批量大小由提供的流数量决定（例如，8 个流的批量大小为 8）。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 批量大小为 1 的单个流推理</span><br><span class="line">    source = &quot;rtsp://example.com/media.mp4&quot;  # RTSP、RTMP、TCP 或 IP 流地址</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    对于单个流使用，批量大小默认为 1，从而实现对视频流的高效实时处理。</span><br><span class="line"></span><br><span class="line">=== &quot;多流&quot;</span><br><span class="line"></span><br><span class="line">    要同时处理多个视频流，请使用包含流源的 `.streams` 文本文件。模型将运行批量推理，其中批量大小等于流的数量。此设置可实现对多个视频流的并发高效处理。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 多个流进行批量推理（例如，8 个流的批量大小为 8）</span><br><span class="line">    source = &quot;path/to/list.streams&quot;  # *.streams 文本文件，每行一个流地址</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    `.streams` 文本文件示例：</span><br><span class="line"></span><br><span class="line">    ```text</span><br><span class="line">    rtsp://example.com/media1.mp4</span><br><span class="line">    rtsp://example.com/media2.mp4</span><br><span class="line">    rtmp://example2.com/live</span><br><span class="line">    tcp://192.168.1.100:554</span><br><span class="line">    ...</span><br><span class="line">    ```</span><br><span class="line"></span><br><span class="line">    文件中的每一行都代表一个流源，让你能够同时监控和对多个视频流进行推理。</span><br><span class="line"></span><br><span class="line">=== &quot;摄像头&quot;</span><br><span class="line"></span><br><span class="line">    你可以通过传递特定摄像头的索引来对连接的摄像头设备运行推理。</span><br><span class="line"></span><br><span class="line">    ```python</span><br><span class="line">    from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line">    # 加载预训练的 YOLO11n 模型</span><br><span class="line">    model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line">    # 对源运行推理</span><br><span class="line">    results = model(source=0, stream=True)  # Results 对象生成器</span><br><span class="line">    ```</span><br></pre></td></tr></table></figure><h2 id="%E6%8E%A8%E7%90%86%E5%8F%82%E6%95%B0" tabindex="-1">推理参数</h2><p><code>model.predict()</code> 接受多个参数，这些参数可以在推理时传递以覆盖默认值：</p><p>!!! example</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对 &#x27;bus.jpg&#x27; 运行推理，并带有参数</span><br><span class="line">model.predict(&quot;https://ultralytics.com/images/bus.jpg&quot;, save=True, imgsz=320, conf=0.5)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>推理参数：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>source</code></td><td style="text-align:left"><code>str, int, Path</code></td><td style="text-align:left"><code>'ultralytics.com/images/bus.jpg'</code></td><td style="text-align:left">输入源的路径。可以是文件、目录、URL、视频或 RTMP 流。</td></tr><tr><td style="text-align:left"><code>model</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left"><code>'yolov11n.pt'</code></td><td style="text-align:left">要运行推理的模型文件的路径。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>0.25</code></td><td style="text-align:left">对象置信度阈值。</td></tr><tr><td style="text-align:left"><code>iou</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left"><code>0.7</code></td><td style="text-align:left">边界框交并比 (IoU) 阈值，用于非最大抑制 (NMS)。</td></tr><tr><td style="text-align:left"><code>imgsz</code></td><td style="text-align:left"><code>int</code> 或 <code>tuple</code></td><td style="text-align:left"><code>640</code></td><td style="text-align:left">输入图像的大小，可以是单个整数（正方形）或 (高度, 宽度) 元组。</td></tr><tr><td style="text-align:left"><code>half</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">如果 GPU 可用，则使用 FP16 半精度推理。</td></tr><tr><td style="text-align:left"><code>device</code></td><td style="text-align:left"><code>int</code> 或 <code>str</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">要使用的设备（例如 <code>cuda:0</code> 或 <code>0,1,2,3</code> 或 <code>cpu</code>）。</td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否在屏幕上显示结果。</td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否将预测结果保存到文件中。</td></tr><tr><td style="text-align:left"><code>save_txt</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否将预测结果以 <code>.txt</code> 格式保存。</td></tr><tr><td style="text-align:left"><code>save_conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否在保存的标签中包含置信度分数。</td></tr><tr><td style="text-align:left"><code>save_crop</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否保存裁剪后的预测结果。</td></tr><tr><td style="text-align:left"><code>hide_labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否隐藏预测标签。</td></tr><tr><td style="text-align:left"><code>hide_conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否隐藏预测置信度分数。</td></tr><tr><td style="text-align:left"><code>max_det</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>300</code></td><td style="text-align:left">每张图像的最大检测数量。</td></tr><tr><td style="text-align:left"><code>vid_stride</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>1</code></td><td style="text-align:left">视频帧步长。</td></tr><tr><td style="text-align:left"><code>stream_buffer</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">是否缓冲流帧。</td></tr><tr><td style="text-align:left"><code>line_thickness</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left"><code>2</code></td><td style="text-align:left">边界框的线条粗细（以像素为单位）。</td></tr><tr><td style="text-align:left"><code>visualize</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">在模型推理期间可视化模型特征。</td></tr><tr><td style="text-align:left"><code>augment</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">在推理时应用图像增强（测试时增强）。</td></tr><tr><td style="text-align:left"><code>agnostic_nms</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">执行类别无关的非最大抑制（NMS）。</td></tr><tr><td style="text-align:left"><code>retina_masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>False</code></td><td style="text-align:left">使用高分辨率分割掩码。</td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left"><code>True</code></td><td style="text-align:left">是否在结果中显示边界框。</td></tr></tbody></table><p>可视化参数：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含检测置信度分数。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>line_width</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">边界框的线条宽度。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font_size</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">文本字体大小。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">文本注释的字体名称。</td><td style="text-align:left"><code>'Arial.ttf'</code></td></tr><tr><td style="text-align:left"><code>pil</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将图像作为 PIL Image 对象返回。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">用于绘图的替代图像。如果为 <code>None</code>，则使用原始图像。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>im_gpu</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>kpt_radius</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">绘制的关键点的半径。</td><td style="text-align:left"><code>5</code></td></tr><tr><td style="text-align:left"><code>kpt_line</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">用线条连接关键点。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在注释中包含类别标签。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加边界框。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加掩码。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含分类概率。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">使用默认图像查看器直接显示带注释的图像。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将带注释的图像保存到由 <code>filename</code> 指定的文件。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>filename</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">如果 <code>save</code> 为 <code>True</code>，则为保存带注释的图像的文件路径和名称。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>color_mode</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">指定颜色模式，例如 ‘instance’ 或 ‘class’。</td><td style="text-align:left"><code>'class'</code></td></tr><tr><td style="text-align:left"><code>txt_color</code></td><td style="text-align:left"><code>tuple[int, int, int]</code></td><td style="text-align:left">边界框和图像分类标签的 RGB 文本颜色。</td><td style="text-align:left"><code>(255, 255, 255)</code></td></tr></tbody></table><h2 id="%E5%9B%BE%E5%83%8F%E5%92%8C%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F" tabindex="-1">图像和视频格式</h2><p>YOLO11 支持多种图像和视频格式，具体请参见 <a href="https://github.com/ultralytics/ultralytics/blob/main/ultralytics/data/utils.py">ultralytics/data/utils.py</a>。下表列出了有效的后缀和预测命令示例。</p><h3 id="%E5%9B%BE%E5%83%8F" tabindex="-1">图像</h3><p>下表包含有效的 Ultralytics 图像格式。</p><p>!!! note</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HEIC 图像仅支持推理，不支持训练。</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">图像后缀</th><th style="text-align:left">预测命令示例</th><th style="text-align:left">参考</th></tr></thead><tbody><tr><td style="text-align:left"><code>.bmp</code></td><td style="text-align:left"><code>yolo predict source=image.bmp</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/BMP_file_format">Microsoft BMP 文件格式</a></td></tr><tr><td style="text-align:left"><code>.dng</code></td><td style="text-align:left"><code>yolo predict source=image.dng</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Digital_Negative">Adobe DNG</a></td></tr><tr><td style="text-align:left"><code>.jpeg</code></td><td style="text-align:left"><code>yolo predict source=image.jpeg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a></td></tr><tr><td style="text-align:left"><code>.jpg</code></td><td style="text-align:left"><code>yolo predict source=image.jpg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/JPEG">JPEG</a></td></tr><tr><td style="text-align:left"><code>.mpo</code></td><td style="text-align:left"><code>yolo predict source=image.mpo</code></td><td style="text-align:left"><a href="https://fileinfo.com/extension/mpo">多图片对象</a></td></tr><tr><td style="text-align:left"><code>.png</code></td><td style="text-align:left"><code>yolo predict source=image.png</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/PNG">便携式网络图形</a></td></tr><tr><td style="text-align:left"><code>.tif</code></td><td style="text-align:left"><code>yolo predict source=image.tif</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/TIFF">标签图像文件格式</a></td></tr><tr><td style="text-align:left"><code>.tiff</code></td><td style="text-align:left"><code>yolo predict source=image.tiff</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/TIFF">标签图像文件格式</a></td></tr><tr><td style="text-align:left"><code>.webp</code></td><td style="text-align:left"><code>yolo predict source=image.webp</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/WebP">WebP</a></td></tr><tr><td style="text-align:left"><code>.pfm</code></td><td style="text-align:left"><code>yolo predict source=image.pfm</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Netpbm#File_formats">便携式浮点地图</a></td></tr><tr><td style="text-align:left"><code>.HEIC</code></td><td style="text-align:left"><code>yolo predict source=image.HEIC</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/HEIF">高效图像文件格式</a></td></tr></tbody></table><h3 id="%E8%A7%86%E9%A2%91" tabindex="-1">视频</h3><p>下表包含有效的 Ultralytics 视频格式。</p><table><thead><tr><th style="text-align:left">视频后缀</th><th style="text-align:left">预测命令示例</th><th style="text-align:left">参考</th></tr></thead><tbody><tr><td style="text-align:left"><code>.asf</code></td><td style="text-align:left"><code>yolo predict source=video.asf</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Advanced_Systems_Format">高级系统格式</a></td></tr><tr><td style="text-align:left"><code>.avi</code></td><td style="text-align:left"><code>yolo predict source=video.avi</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Audio_Video_Interleave">音频视频交错</a></td></tr><tr><td style="text-align:left"><code>.gif</code></td><td style="text-align:left"><code>yolo predict source=video.gif</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/GIF">图形交换格式</a></td></tr><tr><td style="text-align:left"><code>.m4v</code></td><td style="text-align:left"><code>yolo predict source=video.m4v</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/M4V">MPEG-4 Part 14</a></td></tr><tr><td style="text-align:left"><code>.mkv</code></td><td style="text-align:left"><code>yolo predict source=video.mkv</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Matroska">Matroska</a></td></tr><tr><td style="text-align:left"><code>.mov</code></td><td style="text-align:left"><code>yolo predict source=video.mov</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/QuickTime_File_Format">QuickTime 文件格式</a></td></tr><tr><td style="text-align:left"><code>.mp4</code></td><td style="text-align:left"><code>yolo predict source=video.mp4</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-4_Part_14">MPEG-4 Part 14 - Wikipedia</a></td></tr><tr><td style="text-align:left"><code>.mpeg</code></td><td style="text-align:left"><code>yolo predict source=video.mpeg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-1">MPEG-1 Part 2</a></td></tr><tr><td style="text-align:left"><code>.mpg</code></td><td style="text-align:left"><code>yolo predict source=video.mpg</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG-1">MPEG-1 Part 2</a></td></tr><tr><td style="text-align:left"><code>.ts</code></td><td style="text-align:left"><code>yolo predict source=video.ts</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/MPEG_transport_stream">MPEG 传输流</a></td></tr><tr><td style="text-align:left"><code>.wmv</code></td><td style="text-align:left"><code>yolo predict source=video.wmv</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/Windows_Media_Video">Windows Media Video</a></td></tr><tr><td style="text-align:left"><code>.webm</code></td><td style="text-align:left"><code>yolo predict source=video.webm</code></td><td style="text-align:left"><a href="https://en.wikipedia.org/wiki/WebM">WebM 项目</a></td></tr></tbody></table><h2 id="%E5%A4%84%E7%90%86%E7%BB%93%E6%9E%9C" tabindex="-1">处理结果</h2><p>所有 Ultralytics 的 <code>predict()</code> 调用都将返回一个 <code>Results</code> 对象列表：</p><p>!!! example “结果”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)</span><br><span class="line">results = model(</span><br><span class="line">    [</span><br><span class="line">        &quot;https://ultralytics.com/images/bus.jpg&quot;,</span><br><span class="line">        &quot;https://ultralytics.com/images/zidane.jpg&quot;,</span><br><span class="line">    ]</span><br><span class="line">)  # 批量推理</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><code>Results</code> 对象具有以下属性：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>orig_img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">作为 numpy 数组的原始图像。</td></tr><tr><td style="text-align:left"><code>orig_shape</code></td><td style="text-align:left"><code>tuple</code></td><td style="text-align:left">原始图像形状，格式为 (高度, 宽度)。</td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>Boxes, optional</code></td><td style="text-align:left">包含检测边界框的 Boxes 对象。</td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>Masks, optional</code></td><td style="text-align:left">包含检测掩码的 Masks 对象。</td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>Probs, optional</code></td><td style="text-align:left">包含用于分类任务的每个类别的概率的 Probs 对象。</td></tr><tr><td style="text-align:left"><code>keypoints</code></td><td style="text-align:left"><code>Keypoints, optional</code></td><td style="text-align:left">包含每个对象检测到的关键点的 Keypoints 对象。</td></tr><tr><td style="text-align:left"><code>obb</code></td><td style="text-align:left"><code>OBB, optional</code></td><td style="text-align:left">包含定向边界框的 OBB 对象。</td></tr><tr><td style="text-align:left"><code>speed</code></td><td style="text-align:left"><code>dict</code></td><td style="text-align:left">字典，包含每个图像的预处理、推理和后处理速度（以毫秒为单位）。</td></tr><tr><td style="text-align:left"><code>names</code></td><td style="text-align:left"><code>dict</code></td><td style="text-align:left">将类别索引映射到类别名称的字典。</td></tr><tr><td style="text-align:left"><code>path</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">图像文件路径。</td></tr><tr><td style="text-align:left"><code>save_dir</code></td><td style="text-align:left"><code>str, optional</code></td><td style="text-align:left">保存结果的目录。</td></tr></tbody></table><p><code>Results</code> 对象具有以下方法：</p><table><thead><tr><th style="text-align:left">方法</th><th style="text-align:left">返回类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>update()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">使用新的检测数据（框、掩码、概率、OBB、关键点）更新 <code>Results</code> 对象。</td></tr><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，所有张量都已移动到 GPU 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">返回 <code>Results</code> 对象的副本，其中张量已移动到指定的设备和数据类型。</td></tr><tr><td style="text-align:left"><code>new()</code></td><td style="text-align:left"><code>Results</code></td><td style="text-align:left">创建一个具有相同图像、路径、名称和速度属性的新 <code>Results</code> 对象。</td></tr><tr><td style="text-align:left"><code>plot()</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">在输入的 RGB 图像上绘制检测结果并返回带注释的图像。</td></tr><tr><td style="text-align:left"><code>show()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">显示带有注释的推理结果图像。</td></tr><tr><td style="text-align:left"><code>save()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将带有注释的推理结果图像保存到文件并返回文件名。</td></tr><tr><td style="text-align:left"><code>verbose()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">返回每个任务的日志字符串，详细说明检测和分类结果。</td></tr><tr><td style="text-align:left"><code>save_txt()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果保存到文本文件并返回保存文件的路径。</td></tr><tr><td style="text-align:left"><code>save_crop()</code></td><td style="text-align:left"><code>None</code></td><td style="text-align:left">将裁剪后的检测图像保存到指定的目录。</td></tr><tr><td style="text-align:left"><code>summary()</code></td><td style="text-align:left"><code>List[Dict[str, Any]]</code></td><td style="text-align:left">将推理结果转换为摘要字典，并可选择进行归一化。</td></tr><tr><td style="text-align:left"><code>to_df()</code></td><td style="text-align:left"><code>DataFrame</code></td><td style="text-align:left">将检测结果转换为 Polars DataFrame。</td></tr><tr><td style="text-align:left"><code>to_csv()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果转换为 CSV 格式。</td></tr><tr><td style="text-align:left"><code>to_json()</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">将检测结果转换为 JSON 格式。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md"><code>Results</code> 类文档</a>。</p><h3 id="boxes" tabindex="-1">Boxes</h3><p><code>Boxes</code> 对象可用于索引、操作和将边界框转换为不同格式。</p><p>!!! example “Boxes”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.boxes)  # 打印包含检测边界框的 Boxes 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Boxes</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CUDA 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到指定的设备。</td></tr><tr><td style="text-align:left"><code>xyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回框。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的置信度值。</td></tr><tr><td style="text-align:left"><code>cls</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的类别值。</td></tr><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的跟踪 ID（如果可用）。</td></tr><tr><td style="text-align:left"><code>xywh</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywh 格式返回框。</td></tr><tr><td style="text-align:left"><code>xyxyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回归一化后的框（通过原始图像大小）。</td></tr><tr><td style="text-align:left"><code>xywhn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywh 格式返回归一化后的框（通过原始图像大小）。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Boxes"><code>Boxes</code> 类文档</a>。</p><h3 id="masks" tabindex="-1">Masks</h3><p><code>Masks</code> 对象可用于索引、操作和将掩码转换为段。</p><p>!!! example “Masks”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-seg 分割模型</span><br><span class="line">model = YOLO(&quot;yolo11n-seg.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.masks)  # 打印包含检测到的实例掩码的 Masks 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Masks</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回掩码张量。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将掩码张量作为 numpy 数组返回。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回掩码张量。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的掩码张量。</td></tr><tr><td style="text-align:left"><code>xyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的归一化段列表。</td></tr><tr><td style="text-align:left"><code>xy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的像素坐标中的段列表。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Masks"><code>Masks</code> 类文档</a>。</p><h3 id="keypoints" tabindex="-1">Keypoints</h3><p><code>Keypoints</code> 对象可用于索引、操作和归一化坐标。</p><p>!!! example “Keypoints”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-pose 姿态模型</span><br><span class="line">model = YOLO(&quot;yolo11n-pose.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.keypoints)  # 打印包含检测到的关键点的 Keypoints 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>Keypoints</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回关键点张量。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将关键点张量作为 numpy 数组返回。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回关键点张量。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的关键点张量。</td></tr><tr><td style="text-align:left"><code>xyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的归一化关键点列表。</td></tr><tr><td style="text-align:left"><code>xy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">表示为张量的像素坐标中的关键点列表。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">如果可用，返回关键点的置信度值，否则为 <code>None</code>。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Keypoints"><code>Keypoints</code> 类文档</a>。</p><h3 id="probs" tabindex="-1">Probs</h3><p><code>Probs</code> 对象可用于索引，获取分类的 <code>top1</code> 和 <code>top5</code> 索引和分数。</p><p>!!! example “Probs”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n-cls 分类模型</span><br><span class="line">model = YOLO(&quot;yolo11n-cls.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.probs)  # 打印包含检测到的类别概率的 Probs 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表总结了 <code>Probs</code> 类的方法和属性：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 CPU 内存上返回概率张量的副本。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将概率张量作为 numpy 数组返回副本。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">在 GPU 内存上返回概率张量的副本。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">返回具有指定设备和数据类型的概率张量的副本。</td></tr><tr><td style="text-align:left"><code>top1</code></td><td style="text-align:left">属性 (<code>int</code>)</td><td style="text-align:left">top 1 类别的索引。</td></tr><tr><td style="text-align:left"><code>top5</code></td><td style="text-align:left">属性 (<code>list[int]</code>)</td><td style="text-align:left">top 5 类别的索引。</td></tr><tr><td style="text-align:left"><code>top1conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">top 1 类别的置信度。</td></tr><tr><td style="text-align:left"><code>top5conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">top 5 类别的置信度。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.Probs"><code>Probs</code> 类文档</a>。</p><h3 id="obb" tabindex="-1">OBB</h3><p><code>OBB</code> 对象可用于索引、操作和将定向边界框转换为不同格式。</p><p>!!! example “OBB”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n-obb.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对图像运行推理</span><br><span class="line">results = model(&quot;https://ultralytics.com/images/boats.jpg&quot;)  # 结果列表</span><br><span class="line"></span><br><span class="line"># 查看结果</span><br><span class="line">for r in results:</span><br><span class="line">    print(r.obb)  # 打印包含定向检测边界框的 OBB 对象</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>下表列出了 <code>OBB</code> 类的方法和属性，包括它们的名称、类型和描述：</p><table><thead><tr><th style="text-align:left">名称</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>cpu()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CPU 内存。</td></tr><tr><td style="text-align:left"><code>numpy()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象转换为 numpy 数组。</td></tr><tr><td style="text-align:left"><code>cuda()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到 CUDA 内存。</td></tr><tr><td style="text-align:left"><code>to()</code></td><td style="text-align:left">方法</td><td style="text-align:left">将对象移动到指定的设备。</td></tr><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的置信度值。</td></tr><tr><td style="text-align:left"><code>cls</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的类别值。</td></tr><tr><td style="text-align:left"><code>id</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">返回框的跟踪 ID（如果可用）。</td></tr><tr><td style="text-align:left"><code>xyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxy 格式返回水平框。</td></tr><tr><td style="text-align:left"><code>xywhr</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xywhr 格式返回旋转框。</td></tr><tr><td style="text-align:left"><code>xyxyxyxy</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxyxyxy 格式返回旋转框。</td></tr><tr><td style="text-align:left"><code>xyxyxyxyn</code></td><td style="text-align:left">属性 (<code>torch.Tensor</code>)</td><td style="text-align:left">以 xyxyxyxy 格式返回归一化后的旋转框（通过图像大小）。</td></tr></tbody></table><p>有关更多详细信息，请参阅 <a href="https://www.google.com/search?q=../reference/engine/results.md%23ultralytics.engine.results.OBB"><code>OBB</code> 类文档</a>。</p><h2 id="%E7%BB%98%E5%88%B6%E7%BB%93%E6%9E%9C" tabindex="-1">绘制结果</h2><p><code>Results</code> 对象中的 <code>plot()</code> 方法通过在原始图像上叠加检测到的对象（如边界框、掩码、关键点和概率）来方便可视化预测。此方法将带注释的图像作为 NumPy 数组返回，便于显示或保存。</p><p>!!! example “绘图”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载预训练的 YOLO11n 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 对 &#x27;bus.jpg&#x27; 运行推理</span><br><span class="line">results = model([&quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;])  # 结果列表</span><br><span class="line"></span><br><span class="line"># 可视化结果</span><br><span class="line">for i, r in enumerate(results):</span><br><span class="line">    # 绘制结果图像</span><br><span class="line">    im_bgr = r.plot()  # BGR 顺序的 numpy 数组</span><br><span class="line">    im_rgb = Image.fromarray(im_bgr[..., ::-1])  # RGB 顺序的 PIL 图像</span><br><span class="line"></span><br><span class="line">    # 将结果显示到屏幕（在支持的环境中）</span><br><span class="line">    r.show()</span><br><span class="line"></span><br><span class="line">    # 将结果保存到磁盘</span><br><span class="line">    r.save(filename=f&quot;results&#123;i&#125;.jpg&quot;)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h3 id="plot()-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0" tabindex="-1"><code>plot()</code> 方法参数</h3><p><code>plot()</code> 方法支持各种参数来自定义输出：</p><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left"><code>conf</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含检测置信度分数。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>line_width</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">边界框的线条宽度。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font_size</code></td><td style="text-align:left"><code>float</code></td><td style="text-align:left">文本字体大小。如果为 <code>None</code>，则随图像大小缩放。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>font</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">文本注释的字体名称。</td><td style="text-align:left"><code>'Arial.ttf'</code></td></tr><tr><td style="text-align:left"><code>pil</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将图像作为 PIL Image 对象返回。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>img</code></td><td style="text-align:left"><code>np.ndarray</code></td><td style="text-align:left">用于绘图的替代图像。如果为 <code>None</code>，则使用原始图像。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>im_gpu</code></td><td style="text-align:left"><code>torch.Tensor</code></td><td style="text-align:left">用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>kpt_radius</code></td><td style="text-align:left"><code>int</code></td><td style="text-align:left">绘制的关键点的半径。</td><td style="text-align:left"><code>5</code></td></tr><tr><td style="text-align:left"><code>kpt_line</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">用线条连接关键点。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>labels</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在注释中包含类别标签。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>boxes</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加边界框。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>masks</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">在图像上叠加掩码。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>probs</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">包含分类概率。</td><td style="text-align:left"><code>True</code></td></tr><tr><td style="text-align:left"><code>show</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">使用默认图像查看器直接显示带注释的图像。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>save</code></td><td style="text-align:left"><code>bool</code></td><td style="text-align:left">将带注释的图像保存到由 <code>filename</code> 指定的文件。</td><td style="text-align:left"><code>False</code></td></tr><tr><td style="text-align:left"><code>filename</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">如果 <code>save</code> 为 <code>True</code>，则为保存带注释的图像的文件路径和名称。</td><td style="text-align:left"><code>None</code></td></tr><tr><td style="text-align:left"><code>color_mode</code></td><td style="text-align:left"><code>str</code></td><td style="text-align:left">指定颜色模式，例如 ‘instance’ 或 ‘class’。</td><td style="text-align:left"><code>'class'</code></td></tr><tr><td style="text-align:left"><code>txt_color</code></td><td style="text-align:left"><code>tuple[int, int, int]</code></td><td style="text-align:left">边界框和图像分类标签的 RGB 文本颜色。</td><td style="text-align:left"><code>(255, 255, 255)</code></td></tr></tbody></table><h2 id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%8E%A8%E7%90%86" tabindex="-1">线程安全推理</h2><p>当你在不同线程中并行运行多个 YOLO 模型时，确保推理的线程安全至关重要。线程安全推理可确保每个线程的预测是隔离的，并且不会相互干扰，从而避免竞态条件并确保一致且可靠的输出。</p><p>在多线程应用程序中使用 YOLO 模型时，为每个线程实例化单独的模型对象或采用线程本地存储以防止冲突非常重要：</p><p>!!! example “线程安全推理”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">在每个线程内实例化一个模型，以实现线程安全推理：</span><br><span class="line">```python</span><br><span class="line">from threading import Thread</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def thread_safe_predict(model, image_path):</span><br><span class="line">    &quot;&quot;&quot;使用本地实例化的 YOLO 模型对图像执行线程安全预测。&quot;&quot;&quot;</span><br><span class="line">    model = YOLO(model)</span><br><span class="line">    results = model.predict(image_path)</span><br><span class="line">    # 处理结果</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 启动每个线程都有自己模型实例的线程</span><br><span class="line">Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image1.jpg&quot;)).start()</span><br><span class="line">Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image2.jpg&quot;)).start()</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>要深入了解 YOLO 模型的线程安全推理和分步说明，请参阅我们的 <a href="https://www.google.com/search?q=../guides/yolo-thread-safe-inference.md">YOLO 线程安全推理指南</a>。本指南将为你提供所有必要的信息，以避免常见陷阱并确保你的多线程推理顺利运行。</p><h2 id="%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E6%BA%90-for-%E5%BE%AA%E7%8E%AF" tabindex="-1">流式处理源 <code>for</code> 循环</h2><p>这是一个使用 OpenCV (<code>cv2</code>) 和 YOLO 对视频帧运行推理的 Python 脚本。该脚本假设你已安装所需的包（<code>opencv-python</code> 和 <code>ultralytics</code>）。</p><p>!!! example “流式处理 for 循环”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">from ultralytics import YOLO</span><br><span class="line"></span><br><span class="line"># 加载 YOLO 模型</span><br><span class="line">model = YOLO(&quot;yolo11n.pt&quot;)</span><br><span class="line"></span><br><span class="line"># 打开视频文件</span><br><span class="line">video_path = &quot;path/to/your/video/file.mp4&quot;</span><br><span class="line">cap = cv2.VideoCapture(video_path)</span><br><span class="line"></span><br><span class="line"># 循环遍历视频帧</span><br><span class="line">while cap.isOpened():</span><br><span class="line">    # 从视频中读取一帧</span><br><span class="line">    success, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    if success:</span><br><span class="line">        # 在帧上运行 YOLO 推理</span><br><span class="line">        results = model(frame)</span><br><span class="line"></span><br><span class="line">        # 在帧上可视化结果</span><br><span class="line">        annotated_frame = results[0].plot()</span><br><span class="line"></span><br><span class="line">        # 显示带注释的帧</span><br><span class="line">        cv2.imshow(&quot;YOLO Inference&quot;, annotated_frame)</span><br><span class="line"></span><br><span class="line">        # 如果按下 &#x27;q&#x27; 键，则中断循环</span><br><span class="line">        if cv2.waitKey(1) &amp; 0xFF == ord(&quot;q&quot;):</span><br><span class="line">            break</span><br><span class="line">    else:</span><br><span class="line">        # 如果到达视频末尾，则中断循环</span><br><span class="line">        break</span><br><span class="line"></span><br><span class="line"># 释放视频捕获对象并关闭显示窗口</span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>该脚本将在视频的每一帧上运行预测，可视化结果，并在窗口中显示它们。可以通过按 ‘q’ 键退出循环。</p><h2 id="%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-(faq)" tabindex="-1">常见问题 (FAQ)</h2><h3 id="%E4%BB%80%E4%B9%88%E6%98%AF-ultralytics-yolo-%E5%8F%8A%E5%85%B6%E7%94%A8%E4%BA%8E%E5%AE%9E%E6%97%B6%E6%8E%A8%E7%90%86%E7%9A%84%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%EF%BC%9F" tabindex="-1">什么是 Ultralytics YOLO 及其用于实时推理的预测模式？</h3><p>Ultralytics YOLO 是一种用于实时<strong>目标检测</strong>、分割和分类的最新模型。其<strong>预测模式</strong>允许用户对各种数据源（如图像、视频和直播流）执行高速推理。它专为性能和多功能性而设计，还提供批量处理和流式处理模式。有关其功能的更多详细信息，请查看 <a href="https://www.google.com/search?q=%23%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%B3%E9%94%AE%E5%8A%9F%E8%83%BD">Ultralytics YOLO 预测模式</a>。</p><h3 id="%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E5%AF%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E6%95%B0%E6%8D%AE%E6%BA%90%E8%BF%90%E8%A1%8C%E6%8E%A8%E7%90%86%EF%BC%9F" tabindex="-1">如何使用 Ultralytics YOLO 对不同的数据源运行推理？</h3><p>Ultralytics YOLO 可以处理各种数据源，包括单个图像、视频、目录、URL 和流。你可以在 <code>model.predict()</code> 调用中指定数据源。例如，对于本地图像，使用 <code>'image.jpg'</code>；对于 URL，使用 <code>'https://ultralytics.com/images/bus.jpg'</code>。请查看文档中关于各种<strong>推理源</strong>的详细示例。</p><h3 id="%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96-yolo-%E6%8E%A8%E7%90%86%E9%80%9F%E5%BA%A6%E5%92%8C%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%EF%BC%9F" tabindex="-1">如何优化 YOLO 推理速度和内存使用？</h3><p>要优化推理速度并高效管理内存，你可以通过在预测器的调用方法中设置 <code>stream=True</code> 来使用流式处理模式。流式处理模式会生成一个内存高效的 <code>Results</code> 对象生成器，而不是将所有帧加载到内存中。对于处理长视频或大型数据集，流式处理模式特别有用。了解有关<strong>流式处理模式</strong>的更多信息。</p><h3 id="ultralytics-yolo-%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%8E%A8%E7%90%86%E5%8F%82%E6%95%B0%EF%BC%9F" tabindex="-1">Ultralytics YOLO 支持哪些推理参数？</h3><p>YOLO 中的 <code>model.predict()</code> 方法支持各种参数，例如 <code>conf</code>、<code>iou</code>、<code>imgsz</code>、<code>device</code> 等。这些参数允许你自定义推理过程，设置置信度阈值、图像大小和用于计算的设备等参数。这些参数的详细说明可以在<strong>推理参数</strong>部分找到。</p><h3 id="%E5%A6%82%E4%BD%95%E5%8F%AF%E8%A7%86%E5%8C%96%E5%92%8C%E4%BF%9D%E5%AD%98-yolo-%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C%EF%BC%9F" tabindex="-1">如何可视化和保存 YOLO 预测结果？</h3><p>使用 YOLO 运行推理后，<code>Results</code> 对象包含用于显示和保存带注释图像的方法。你可以使用 <code>result.show()</code> 和 <code>result.save(filename=&quot;result.jpg&quot;)</code> 等方法来可视化和保存结果。有关这些方法的完整列表，请参阅<strong>处理结果</strong>部分。</p><p>[]: #<br>[]: #<br>[]: #</p><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;%E4%BD%BF%E7%94%A8-ultralytics-yolo-%E8%BF%9B%E8%A1%8C%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B&quot; tabindex=&quot;-1&quot;&gt;使用 Ultralytics YOLO 进行模型预测</summary>
      
    
    
    
    
    <category term="文档、库" scheme="https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2025-09-13T12:57:08.000Z</published>
    <updated>2025-09-13T13:37:52.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1.-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%9F" tabindex="-1">1. 什么是线段树？</h3><p>线段树是一种<strong>二叉树</strong>数据结构，用于存储区间（或称为“线段”）的信息，并支持快速的查询和更新操作。它特别适合解决与区间相关的动态问题，例如：</p><ul><li>求某个区间的和。</li><li>查找某个区间的最大值或最小值。</li><li>对某个区间进行批量更新。<br>线段树的核心思想是将一个大区间递归地划分成多个小子区间，并通过树形结构高效地维护和查询这些区间的聚合信息。</li></ul><hr><h3 id="2.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84" tabindex="-1">2. 线段树的结构</h3><p>线段树的结构可以用以下方式描述：</p><ul><li><strong>节点</strong>：每个节点代表一个区间。</li><li><strong>根节点</strong>：代表整个区间（例如数组的范围[1, n]）。</li><li><strong>叶子节点</strong>：代表单个元素（例如数组中的某个值）。</li><li><strong>中间节点</strong>：代表某个子区间（介于根节点和叶子节点之间）。<br>例如，对于一个数组<code>[1, 3, 5, 7, 9, 11]</code>，线段树的结构如下：</li><li>根节点表示区间<code>[1, 6]</code>。</li><li>根的左子节点表示<code>[1, 3]</code>，右子节点表示<code>[4, 6]</code>。</li><li>进一步划分后，叶子节点分别表示<code>[1, 1]</code>、<code>[2, 2]</code>、<code>[3, 3]</code>、<code>[4, 4]</code>、<code>[5, 5]</code>和<code>[6, 6]</code>。<br>这种递归划分的方式使得线段树能够高效地处理区间问题。</li></ul><hr><h3 id="3.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C" tabindex="-1">3. 线段树的基本操作</h3><p>线段树主要支持以下两种核心操作：</p><h4 id="%E6%9F%A5%E8%AF%A2%EF%BC%88query%EF%BC%89" tabindex="-1"><strong>查询（Query）</strong></h4><p>查询操作用于获取某个区间的聚合信息，例如：</p><ul><li>区间的和。</li><li>区间的最大值或最小值。</li></ul><h4 id="%E6%9B%B4%E6%96%B0%EF%BC%88update%EF%BC%89" tabindex="-1"><strong>更新（Update）</strong></h4><p>更新操作用于修改数据，例如：</p><ul><li>修改单个元素的值（单点更新）。</li><li>对某个区间的元素进行批量修改（区间更新）。<br>这两种操作的时间复杂度均为<strong>O(log n)</strong>，其中<code>n</code>是数组的大小。这是对数级别的高效性使得线段树非常适合动态查询问题。</li></ul><hr><h3 id="4.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA" tabindex="-1">4. 线段树的构建</h3><p>线段树的构建是一个递归过程，通常自底向上完成。以下是构建线段树的基本步骤：</p><ol><li><strong>从根节点开始</strong>：根节点表示整个区间，例如<code>[1, n]</code>。</li><li><strong>划分区间</strong>：将当前区间划分为两个子区间，例如<code>[1, mid]</code>和<code>[mid+1, n]</code>，其中<code>mid = (left + right) / 2</code>。</li><li><strong>递归构建子树</strong>：对左子区间和右子区间分别递归构建子树，直到达到叶子节点。</li><li><strong>合并信息</strong>：在回溯时，根据具体问题将子节点的信息合并到当前节点。例如，对于区间求和问题，当前节点的值是左子节点和右子节点值的和。<br><strong>示例</strong>：<br>对于数组<code>[1, 3, 5, 7, 9, 11]</code>：</li></ol><ul><li>根节点存储<code>[1, 6]</code>的和：<code>1 + 3 + 5 + 7 + 9 + 11 = 36</code>。</li><li>左子节点存储<code>[1, 3]</code>的和：<code>1 + 3 + 5 = 9</code>。</li><li>右子节点存储<code>[4, 6]</code>的和：<code>7 + 9 + 11 = 27</code>。</li><li>递归继续，直到叶子节点存储单个元素。</li></ul><hr><h3 id="5.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9F%A5%E8%AF%A2" tabindex="-1">5. 线段树的查询</h3><p>查询操作同样是递归进行的，用于在O(log n)时间内获取某个区间的聚合信息。查询步骤如下：</p><ol><li><strong>判断当前区间与查询区间的关系</strong>：<ul><li><strong>完全包含</strong>：如果当前区间完全在查询区间内，直接返回当前节点的值。</li><li><strong>无交集</strong>：如果当前区间与查询区间无重叠，返回一个不影响结果的值（例如求和时返回0，求最大值时返回负无穷）。</li><li><strong>部分重叠</strong>：递归查询左子树和右子树，并合并结果。</li></ul></li><li><strong>合并结果</strong>：根据具体问题合并子查询的结果。例如，求和时将左右子树的结果相加。<br><strong>示例</strong>：<br>查询数组<code>[1, 3, 5, 7, 9, 11]</code>中区间<code>[2, 5]</code>的和：</li></ol><ul><li>根节点<code>[1, 6]</code>与<code>[2, 5]</code>部分重叠，递归查询子节点。</li><li>左子节点<code>[1, 3]</code>与<code>[2, 5]</code>部分重叠，继续递归，最终得到<code>[2, 3]</code>的和<code>3 + 5 = 8</code>。</li><li>右子节点<code>[4, 6]</code>与<code>[2, 5]</code>部分重叠，最终得到<code>[4, 5]</code>的和<code>7 + 9 = 16</code>。</li><li>合并结果：<code>8 + 16 = 24</code>。</li></ul><hr><h3 id="6.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E6%9B%B4%E6%96%B0" tabindex="-1">6. 线段树的更新</h3><p>更新操作分为两种类型：</p><h4 id="%E5%8D%95%E7%82%B9%E6%9B%B4%E6%96%B0" tabindex="-1"><strong>单点更新</strong></h4><p>修改数组中某个元素的值，并更新线段树中所有相关节点：</p><ol><li>递归找到对应的叶子节点。</li><li>更新叶子节点的值。</li><li>回溯时，更新所有包含该叶子节点的父节点。<br><strong>示例</strong>：<br>将数组<code>[1, 3, 5, 7, 9, 11]</code>中的第2个元素从3改为10：</li></ol><ul><li>找到叶子节点<code>[2, 2]</code>，更新值为10。</li><li>向上更新：<code>[1, 3]</code>的和从9变为<code>1 + 10 + 5 = 16</code>，根节点<code>[1, 6]</code>的和从36变为<code>43</code>。</li></ul><h4 id="%E5%8C%BA%E9%97%B4%E6%9B%B4%E6%96%B0" tabindex="-1"><strong>区间更新</strong></h4><p>对某个区间的元素进行批量修改，例如将区间<code>[2, 4]</code>的所有值增加5。通常使用**延迟标记（Lazy Propagation）**优化，避免直接更新所有叶子节点：</p><ul><li>在需要更新的节点上记录延迟标记。</li><li>在下次查询或更新时，将标记传播到子节点。</li></ul><hr><h3 id="7.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6" tabindex="-1">7. 线段树的空间复杂度</h3><h2 id="%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%98%AF%E4%B8%80%E4%B8%AA%E8%BF%91%E4%BC%BC%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E8%8A%82%E7%82%B9%E6%80%BB%E6%95%B0%E7%BA%A6%E4%B8%BA2n-1%EF%BC%8C%E5%9B%A0%E6%AD%A4%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%BAo(n)%EF%BC%8C%E5%85%B6%E4%B8%ADn%E6%98%AF%E6%95%B0%E7%BB%84%E7%9A%84%E5%A4%A7%E5%B0%8F%E3%80%82" tabindex="-1">线段树是一个近似满二叉树，节点总数约为<code>2n-1</code>，因此空间复杂度为<strong>O(n)</strong>，其中<code>n</code>是数组的大小。</h2><h3 id="8.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">8. 线段树的应用</h3><p>线段树在算法问题中有广泛应用，包括但不限于：</p><ul><li><strong>区间求和</strong>：计算任意区间的和。</li><li><strong>区间最值</strong>：查找任意区间的最大值或最小值。</li><li><strong>区间更新</strong>：对某个区间批量加减一个值。</li><li><strong>动态规划优化</strong>：加速某些状态转移。</li></ul><hr><h3 id="9.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9" tabindex="-1">9. 线段树的优点与缺点</h3><h4 id="%E4%BC%98%E7%82%B9" tabindex="-1"><strong>优点</strong></h4><ul><li>查询和更新时间复杂度均为<strong>O(log n)</strong>，高效处理动态问题。</li><li>灵活性强，可根据问题定制功能。</li></ul><h4 id="%E7%BC%BA%E7%82%B9" tabindex="-1"><strong>缺点</strong></h4><ul><li>实现相对复杂，代码量较大。</li><li>空间消耗较高，需要额外的O(n)存储。</li></ul><hr><h3 id="9.-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E7%BA%BF%E6%AE%B5%E6%A0%91" tabindex="-1">9. 手动实现线段树</h3><p>由于 Python 标准库和主流第三方库中没有直接提供线段树，开发者通常会根据问题需求手动实现。以下是一个简单的 Python 线段树实现，用于支持<strong>区间求和</strong>和<strong>单点更新</strong>，并包含详细注释以便理解。</p><h4 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%EF%BC%9A%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91" tabindex="-1">代码实现：区间求和线段树</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentTree</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化线段树，arr 是输入数组&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="built_in">len</span>(arr)  <span class="comment"># 数组长度</span></span><br><span class="line">        <span class="variable language_">self</span>.tree = [<span class="number">0</span>] * (<span class="number">4</span> * <span class="variable language_">self</span>.n)  <span class="comment"># 线段树数组，4n 足以容纳所有节点</span></span><br><span class="line">        <span class="variable language_">self</span>.arr = arr  <span class="comment"># 保存原始数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>._build(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>)  <span class="comment"># 递归构建线段树</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_build</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归构建线段树，node 是当前节点，[start, end] 是当前区间&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="comment"># 叶子节点，直接存储数组元素</span></span><br><span class="line">            <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.arr[start]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span>  <span class="comment"># 左子节点</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span>  <span class="comment"># 右子节点</span></span><br><span class="line">        <span class="comment"># 递归构建左右子树</span></span><br><span class="line">        <span class="variable language_">self</span>._build(left_node, start, mid)</span><br><span class="line">        <span class="variable language_">self</span>._build(right_node, mid + <span class="number">1</span>, end)</span><br><span class="line">        <span class="comment"># 合并子节点信息：当前节点存储左右子节点的和</span></span><br><span class="line">        <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.tree[left_node] + <span class="variable language_">self</span>.tree[right_node]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, index: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;单点更新：将 arr[index] 更新为 value&quot;&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.arr[index] = value</span><br><span class="line">        <span class="variable language_">self</span>._update(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>, index, value)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_update</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span>, index: <span class="built_in">int</span>, value: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归更新线段树，index 是要更新的位置，value 是新值&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> start == end:</span><br><span class="line">            <span class="comment"># 叶子节点，直接更新</span></span><br><span class="line">            <span class="variable language_">self</span>.tree[node] = value</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span></span><br><span class="line">        <span class="comment"># 递归更新左子树或右子树</span></span><br><span class="line">        <span class="keyword">if</span> index &lt;= mid:</span><br><span class="line">            <span class="variable language_">self</span>._update(left_node, start, mid, index, value)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>._update(right_node, mid + <span class="number">1</span>, end, index, value)</span><br><span class="line">        <span class="comment"># 合并更新后的子节点信息</span></span><br><span class="line">        <span class="variable language_">self</span>.tree[node] = <span class="variable language_">self</span>.tree[left_node] + <span class="variable language_">self</span>.tree[right_node]</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">query</span>(<span class="params">self, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;查询区间 [left, right] 的和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._query(<span class="number">0</span>, <span class="number">0</span>, <span class="variable language_">self</span>.n - <span class="number">1</span>, left, right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_query</span>(<span class="params">self, node: <span class="built_in">int</span>, start: <span class="built_in">int</span>, end: <span class="built_in">int</span>, left: <span class="built_in">int</span>, right: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;递归查询 [left, right] 的和&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> left &lt;= start <span class="keyword">and</span> end &lt;= right:</span><br><span class="line">            <span class="comment"># 当前区间完全包含在查询区间内，直接返回节点值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">self</span>.tree[node]</span><br><span class="line">        <span class="keyword">if</span> right &lt; start <span class="keyword">or</span> left &gt; end:</span><br><span class="line">            <span class="comment"># 当前区间与查询区间无交集，返回 0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (start + end) // <span class="number">2</span></span><br><span class="line">        left_node = <span class="number">2</span> * node + <span class="number">1</span></span><br><span class="line">        right_node = <span class="number">2</span> * node + <span class="number">2</span></span><br><span class="line">        <span class="comment"># 递归查询左右子树，并合并结果</span></span><br><span class="line">        left_sum = <span class="variable language_">self</span>._query(left_node, start, mid, left, right)</span><br><span class="line">        right_sum = <span class="variable language_">self</span>._query(right_node, mid + <span class="number">1</span>, end, left, right)</span><br><span class="line">        <span class="keyword">return</span> left_sum + right_sum</span><br><span class="line"><span class="comment"># 测试代码</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 初始数组</span></span><br><span class="line">    arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">    seg_tree = SegmentTree(arr)</span><br><span class="line">    <span class="comment"># 测试查询</span></span><br><span class="line">    <span class="built_in">print</span>(seg_tree.query(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 查询 [1, 3] 的和：3 + 5 + 7 = 15</span></span><br><span class="line">    <span class="comment"># 测试更新</span></span><br><span class="line">    seg_tree.update(<span class="number">1</span>, <span class="number">10</span>)  <span class="comment"># 将 arr[1] 从 3 更新为 10</span></span><br><span class="line">    <span class="built_in">print</span>(seg_tree.query(<span class="number">1</span>, <span class="number">3</span>))  <span class="comment"># 查询 [1, 3] 的和：10 + 5 + 7 = 22</span></span><br></pre></td></tr></table></figure><hr><h4 id="%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E" tabindex="-1">代码说明</h4><ol><li><strong>初始化 (<code>__init__</code>)</strong>：<ul><li>创建线段树数组 <code>tree</code>，大小为 <code>4n</code>（足以容纳所有节点）。</li><li>调用 <code>_build</code> 递归构建线段树，存储每个区间的和。</li></ul></li><li><strong>构建 (<code>_build</code>)</strong>：<ul><li>递归划分区间，直到叶子节点。</li><li>叶子节点存储原始数组元素，中间节点存储子节点和。</li></ul></li><li><strong>更新 (<code>update</code> 和 <code>_update</code>)</strong>：<ul><li>单点更新：递归找到对应的叶子节点，更新值。</li><li>回溯时更新所有相关父节点的和。</li></ul></li><li><strong>查询 (<code>query</code> 和 <code>_query</code>)</strong>：<ul><li>查询区间 <code>[left, right]</code> 的和。</li><li>递归处理三种情况：完全包含、无交集、部分重叠。</li></ul></li><li><strong>时间复杂度</strong>：<ul><li>构建：( O(n) )</li><li>查询：( O(\log n) )</li><li>更新：( O(\log n) )</li></ul></li><li><strong>空间复杂度</strong>：<ul><li>( O(n) )，线段树需要 ( 4n ) 的空间。</li></ul></li></ol><hr><h3 id="10.-%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD%EF%BC%88%E9%9C%80%E8%A6%81%E6%97%B6%E5%8F%AF%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0%EF%BC%89" tabindex="-1">10. 线段树的高级功能（需要时可扩展实现）</h3><p>手动实现的线段树可以根据问题需求扩展，以下是常见的高级功能：</p><ol><li><strong>区间更新（Lazy Propagation）</strong>：<ul><li>支持对整个区间批量修改（如将 <code>[l, r]</code> 的值增加一个常数）。</li><li>使用延迟标记（lazy tag）记录未传播的更新，减少时间开销。</li><li>适用场景：动态修改大范围数据。</li></ul></li><li><strong>区间最值</strong>：<ul><li>修改线段树存储最大值或最小值，而不是和。</li><li>例如，查询 <code>[l, r]</code> 的最大值，只需将合并操作从 <code>+</code> 改为 <code>max</code>。</li></ul></li><li><strong>动态线段树</strong>：<ul><li>支持动态添加或删除节点，适用于数据范围不确定的场景。</li><li>实现较复杂，通常结合指针或动态分配。</li></ul></li><li><strong>持久化线段树</strong>：<ul><li>保留线段树的历史版本，支持查询历史状态。</li><li>常用于函数式编程或需要回溯的问题。</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1.-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%9F&quot; tabindex=&quot;-1&quot;&gt;1. 什么是线段树？&lt;/h3&gt;
&lt;p&gt;线段树是一种&lt;strong&gt;二叉树&lt;/strong&gt;数据结构，</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2025-09-13T11:16:41.000Z</published>
    <updated>2025-09-14T04:36:12.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-dp%EF%BC%89%E6%98%AF%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%AD%E7%9A%84%E4%B8%80%E7%A7%8D%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8%E4%BA%8E%E8%A7%A3%E5%86%B3%E5%85%B7%E6%9C%89-%E9%87%8D%E5%8F%A0%E5%AD%90%E9%97%AE%E9%A2%98-%E5%92%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84-%E7%9A%84%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E3%80%82%E5%AE%83%E9%80%9A%E8%BF%87%E5%B0%86%E9%97%AE%E9%A2%98%E5%88%86%E8%A7%A3%E4%B8%BA%E8%BE%83%E5%B0%8F%E7%9A%84%E5%AD%90%E9%97%AE%E9%A2%98%EF%BC%8C%E5%AD%98%E5%82%A8%E5%AD%90%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E4%BB%A5%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E8%AE%A1%E7%AE%97%EF%BC%8C%E4%BB%8E%E8%80%8C%E9%AB%98%E6%95%88%E6%B1%82%E8%A7%A3%E5%A4%8D%E6%9D%82%E9%97%AE%E9%A2%98%E3%80%82%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B-%E4%B8%AD%EF%BC%8Cdp-%E6%98%AF%E6%A0%B8%E5%BF%83%E6%8A%80%E5%B7%A7%EF%BC%8C%E5%B9%BF%E6%B3%9B%E5%BA%94%E7%94%A8%E4%BA%8E%E5%BA%8F%E5%88%97%E3%80%81%E5%9B%BE%E3%80%81%E6%A0%91%E3%80%81%E8%83%8C%E5%8C%85%E3%80%81%E5%8C%BA%E9%97%B4%E7%AD%89%E9%97%AE%E9%A2%98%E3%80%82" tabindex="-1">动态规划（Dynamic Programming，简称 DP）是算法设计中的一种重要方法，用于解决具有 <strong>重叠子问题</strong> 和 <strong>最优子结构</strong> 的优化问题。它通过将问题分解为较小的子问题，存储子问题的解以避免重复计算，从而高效求解复杂问题。在 <strong>ACM 竞赛</strong> 中，DP 是核心技巧，广泛应用于序列、图、树、背包、区间等问题。</h2><h2 id="1.-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" tabindex="-1">1. 动态规划的基本概念</h2><h3 id="1.1-%E5%AE%9A%E4%B9%89" tabindex="-1">1.1 定义</h3><p>动态规划是一种通过 <strong>分阶段</strong> 解决问题的方法，每个阶段的决策依赖于前几个阶段的解。DP 的核心思想是：</p><ul><li><strong>分解问题</strong>：将原问题分解为若干子问题。</li><li><strong>存储中间结果</strong>：用表格（数组或哈希表）保存子问题的解，避免重复计算。</li><li><strong>递归求解</strong>：通过子问题的解递归构建原问题的解。<br>DP 通常用于求解 <strong>最优化问题</strong>（如最大值、最小值、最短路径）或 <strong>计数问题</strong>（如方案数），其适用条件包括：</li><li><strong>最优子结构</strong>：原问题的最优解可由子问题的最优解构成。</li><li><strong>重叠子问题</strong>：子问题在递归分解中被多次求解，适合存储优化。</li><li><strong>无后效性</strong>：当前阶段的决策只依赖于之前阶段的状态，不受后续决策影响。<br><strong>示例</strong>：</li><li><strong>斐波那契数列</strong>：第 ( n ) 项 ( F(n) = F(n-1) + F(n-2) )，子问题重叠，直接递归效率低，DP 存储中间结果优化。</li><li><strong>最长公共子序列（LCS）</strong>：字符串 ( A ) 和 ( B ) 的 LCS 依赖于前缀的 LCS，具有最优子结构。</li></ul><h3 id="1.2-%E5%85%B3%E9%94%AE%E6%80%A7%E8%B4%A8" tabindex="-1">1.2 关键性质</h3><ul><li><strong>状态（State）</strong>：用变量表示子问题的解，通常是数组或多维表格，如 ( dp[i] ) 表示前 ( i ) 项的最优解。</li><li><strong>状态转移方程（Transition）</strong>：描述如何从已知状态推导新状态，如 ( dp[i] = \max(dp[i-1], dp[i-2]) )。</li><li><strong>初始条件（Base Case）</strong>：DP 表格的起点，如 ( dp[0] = 0 )。</li><li><strong>目标</strong>：最终求解的状态，如 ( dp[n] )。</li><li><strong>时间复杂度</strong>：通常为 ( O(\text{状态数} \times \text{转移复杂度}) ).</li><li><strong>空间复杂度</strong>：取决于状态存储，通常为 ( O(\text{状态数}) )，可通过滚动数组优化。</li></ul><h3 id="1.3-dp-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB" tabindex="-1">1.3 DP 与其他方法的区别</h3><ul><li><strong>与递归（Recursion）</strong>：<ul><li>递归直接分解问题，可能重复计算子问题（指数复杂度）。</li><li>DP 存储子问题解（通常多项式复杂度）。</li></ul></li><li><strong>与分治（Divide and Conquer）</strong>：<ul><li>分治将问题分为独立子问题（如归并排序）。</li><li>DP 处理重叠子问题，子问题间有依赖。</li></ul></li><li><strong>与贪心（Greedy）</strong>：<ul><li>贪心基于局部最优，适用于特定问题（如活动选择）。</li><li>DP 考虑全局最优，适用范围更广（如 0-1 背包）。</li></ul></li></ul><h3 id="1.4-dp-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%AD%A5%E9%AA%A4" tabindex="-1">1.4 DP 的设计步骤</h3><ol><li><strong>定义状态</strong>：确定 ( dp[i][j]… ) 表示什么，通常与子问题相关。</li><li><strong>推导状态转移方程</strong>：分析当前状态如何由前几个状态得出。</li><li><strong>确定初始条件</strong>：初始化边界状态（如 ( dp[0][0] )。</li><li><strong>计算顺序</strong>：确保状态按依赖顺序计算（自底向上或记忆化递归）。</li><li><strong>求解目标</strong>：输出最终状态（如 ( dp[n][m] \）。</li><li><strong>优化空间</strong>：若状态只依赖前几行/列，用滚动数组减少空间。</li></ol><h3 id="1.5-%E5%B8%B8%E8%A7%81-dp-%E7%B1%BB%E5%9E%8B" tabindex="-1">1.5 常见 DP 类型</h3><ol><li><strong>线性 DP</strong>：状态沿一维序列转移，如斐波那契、LIS（最长递增子序列）。</li><li><strong>背包 DP</strong>：处理资源分配，如 0-1 背包、完全背包。</li><li><strong>区间 DP</strong>：处理区间合并或分割，如石子合并、括号匹配。</li><li><strong>树形 DP</strong>：在树上进行状态转移，如树的最小支配集。</li><li><strong>状态压缩 DP</strong>：用二进制表示状态，适合小规模集合问题。</li><li><strong>数位 DP</strong>：处理数字范围内的计数问题，如数字和。</li><li><strong>概率/期望 DP</strong>：计算概率或期望值，如博弈问题。</li><li><strong>多维 DP</strong>：处理多变量状态，如 LCS、编辑距离。</li></ol><h3 id="1.6-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" tabindex="-1">1.6 应用场景</h3><ul><li><strong>ACM 竞赛</strong>：<ul><li>序列问题：LIS、LCS、编辑距离。</li><li>背包问题：0-1 背包、完全背包、多重背包。</li><li>区间问题：石子合并、区间调度。</li><li>树上问题：树形 DP、最小点覆盖。</li><li>图上问题：最短路径、DAG 上的 DP。</li></ul></li><li><strong>实际应用</strong>：<ul><li>机器学习：隐马尔可夫模型（HMM）、Viterbi 算法。</li><li>运筹学：资源分配、调度优化。</li><li>生物信息学：序列比对。</li></ul></li></ul><h3 id="1.7-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" tabindex="-1">1.7 复杂度分析</h3><ul><li><strong>时间复杂度</strong>：( O(\text{状态数} \times \text{转移复杂度}) )。<ul><li>例：LCS 为 ( O(n \times m) )，状态数 ( n \times m )，转移 ( O(1) )。</li></ul></li><li><strong>空间复杂度</strong>：( O(\text{状态数}) )，可通过滚动数组优化到 ( O(\text{较小维度}) )。</li><li><strong>记忆化递归</strong>：与递推等价，适合状态空间稀疏或难以确定计算顺序。</li></ul><hr><h2 id="2.-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E7%BC%96%E7%A8%8B%E6%96%B9%E6%B3%95" tabindex="-1">2. 动态规划的编程方法</h2><p>DP 的实现方式主要分为 <strong>递推（Bottom-Up）</strong> 和 <strong>记忆化递归（Top-Down）</strong>，以下详细讲解两种方法的特点和实现步骤。</p><h3 id="2.1-%E9%80%92%E6%8E%A8%EF%BC%88bottom-up%EF%BC%89" tabindex="-1">2.1 递推（Bottom-Up）</h3><ul><li><strong>特点</strong>：<ul><li>自底向上计算，从初始状态递推到目标状态。</li><li>使用循环填充 DP 表格，适合状态空间连续。</li><li>空间效率高，易于优化（如滚动数组）。</li></ul></li><li><strong>步骤</strong>：<ol><li>定义 DP 数组（如 ( dp[i][j] )）。</li><li>初始化边界条件。</li><li>按状态依赖顺序循环，计算状态转移。</li><li>返回目标状态。</li></ol></li><li><strong>适用场景</strong>：状态空间明确，计算顺序简单（如线性 DP、背包 DP）。</li><li><strong>优点</strong>：<ul><li>避免递归开销，运行效率高。</li><li>易于调试，状态计算顺序清晰。</li></ul></li><li><strong>缺点</strong>：<ul><li>状态空间稀疏时可能浪费计算。</li><li>复杂状态转移可能难以推导。<br><strong>示例</strong>：0-1 背包问题</li></ul></li><li>问题：给定 ( n ) 个物品，重量 ( w[i] )，价值 ( v[i] )，背包容量 ( W )，求最大价值。</li><li>状态：( dp[i][j] ) 表示前 ( i ) 个物品，容量 ( j ) 时的最大价值。</li><li>转移：( dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) )（若 ( j \geq w[i] )）。</li><li>初始：( dp[0][j] = 0 )，( dp[i][0] = 0 )。</li><li>目标：( dp[n][W] ).</li></ul><h3 id="2.2-%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%88top-down%EF%BC%89" tabindex="-1">2.2 记忆化递归（Top-Down）</h3><ul><li><strong>特点</strong>：<ul><li>自顶向下递归，从目标状态分解到子问题。</li><li>使用记忆化（Memoization）存储已计算的子问题解。</li><li>适合状态空间稀疏或状态转移复杂。</li></ul></li><li><strong>步骤</strong>：<ol><li>定义递归函数，参数表示状态。</li><li>创建记忆化表格（如字典或数组）。</li><li>在递归中检查是否已计算，若是返回缓存结果。</li><li>计算状态转移，存储结果。</li></ol></li><li><strong>适用场景</strong>：状态空间不规则、递归关系复杂（如树形 DP、数位 DP）。</li><li><strong>优点</strong>：<ul><li>代码直观，递归逻辑易于理解。</li><li>仅计算用到的状态，适合稀疏问题。</li></ul></li><li><strong>缺点</strong>：<ul><li>递归栈开销大，可能导致栈溢出。</li><li>Python 递归深度有限，需调整或转为递推。<br><strong>示例</strong>：最长公共子序列（LCS）</li></ul></li><li>问题：给定字符串 ( A ) 和 ( B )，求最长公共子序列长度。</li><li>状态：( dp[i][j] ) 表示 ( A[0:i] ) 和 ( B[0:j] ) 的 LCS 长度。</li><li>转移：<ul><li>若 ( A[i-1] == B[j-1] )，则 ( dp[i][j] = dp[i-1][j-1] + 1 )。</li><li>否则，( dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) )。</li></ul></li><li>初始：( dp[0][j] = 0 )，( dp[i][0] = 0 ).</li><li>目标：( dp[|A|][|B|] ).</li></ul><h3 id="2.3-%E7%A9%BA%E9%97%B4%E4%BC%98%E5%8C%96" tabindex="-1">2.3 空间优化</h3><ul><li><strong>滚动数组</strong>：<ul><li>若状态只依赖前几行/列，用小数组覆盖大数组。</li><li>例：0-1 背包从 ( dp[n][W] ) 优化到 ( dp[W] )，空间 ( O(W) ).</li></ul></li><li><strong>状态压缩</strong>：<ul><li>用位运算表示状态，适合状态压缩 DP。</li><li>例：TSP（旅行商问题），状态从 ( O(n \times 2^n) ) 压缩到 ( O(2^n) ).</li></ul></li><li><strong>稀疏存储</strong>：<ul><li>用字典或哈希表存储非零状态，适合记忆化递归。</li></ul></li></ul><h3 id="2.4-%E8%B0%83%E8%AF%95%E4%B8%8E%E4%BC%98%E5%8C%96" tabindex="-1">2.4 调试与优化</h3><ul><li><strong>调试</strong>：<ul><li>打印 DP 表格，验证状态转移。</li><li>检查边界条件和初始值。</li><li>用小数据手动模拟，确保逻辑正确。</li></ul></li><li><strong>优化</strong>：<ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>常数优化</strong>：减少循环内操作，如提前计算常量。</li><li><strong>并行化</strong>：复杂 DP 可分块并行（非比赛场景）。</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）。</li></ul></li></ul><hr><h2 id="3.-%E5%9C%A8-acm-%E7%AB%9E%E8%B5%9B%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8" tabindex="-1">3. 在 ACM 竞赛中的应用</h2><p>DP 在 ACM 竞赛中是解决优化和计数问题的核心工具，因其 <strong>通用性</strong> 和 <strong>高效性</strong> 广泛应用于各种题型。以下是常见类型和解题思路：</p><ol><li><strong>线性 DP</strong>：<ul><li><strong>题目</strong>：求序列的最优解，如最长递增子序列（LIS）。</li><li><strong>解法</strong>：定义 ( dp[i] ) 为以 ( i ) 结尾的最优解，转移考虑前序状态。</li><li><strong>示例</strong>：Luogu P1020（导弹拦截，LIS）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i] ) 表示以 ( a[i] ) 结尾的 LIS 长度。</li><li>转移：( dp[i] = \max(dp[j]) + 1 )，其中 ( j &lt; i )，( a[j] &lt; a[i] ).</li><li>复杂度：( O(n^2) )，可优化到 ( O(n \log n) )（二分）。</li></ul></li><li><strong>Python 优势</strong>：列表操作简洁，调试方便。</li></ul></li><li><strong>背包 DP</strong>：<ul><li><strong>题目</strong>：资源分配，如 0-1 背包、完全背包。</li><li><strong>解法</strong>：定义 ( dp[i][j] ) 为前 ( i ) 项容量 ( j ) 的最优解，转移考虑是否选择当前项。</li><li><strong>示例</strong>：Luogu P1048（采药，0-1 背包）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i][j] ) 表示前 ( i ) 种草药，容量 ( j ) 的最大价值。</li><li>转移：( dp[i][j] = \max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) ).</li><li>滚动数组：优化到 ( dp[j] )，空间 ( O(W) ).</li></ul></li><li><strong>Python 优势</strong>：数组操作直观，滚动数组实现简单。</li></ul></li><li><strong>区间 DP</strong>：<ul><li><strong>题目</strong>：处理区间合并或分割，如石子合并。</li><li><strong>解法</strong>：定义 ( dp[l][r] ) 为区间 ( [l, r] ) 的最优解，转移枚举分割点。</li><li><strong>示例</strong>：Luogu P1880（石子合并）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[l][r] ) 表示合并 ( [l, r] ) 石子的最小代价。</li><li>转移：( dp[l][r] = \min(dp[l][k] + dp[k+1][r] + \text{sum}[l,r]) )，( k \in [l, r-1] ).</li><li>复杂度：( O(n^3) ).</li></ul></li><li><strong>Python 优势</strong>：二维数组操作简洁，调试区间状态方便。</li></ul></li><li><strong>树形 DP</strong>：<ul><li><strong>题目</strong>：树上优化，如最小支配集。</li><li><strong>解法</strong>：定义 ( dp[u][s] ) 为节点 ( u ) 在状态 ( s ) 下的最优解，递归转移。</li><li><strong>示例</strong>：Luogu P1352（没有上司的舞会）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[u][0/1] ) 表示节点 ( u ) 不选/选的最大快乐值。</li><li>转移：( dp[u][0] = \sum \max(dp[v][0], dp[v][1]) )，( dp[u][1] = r[u] + \sum dp[v][0] ).</li><li>复杂度：( O(n) ).</li></ul></li><li><strong>Python 优势</strong>：递归实现直观，邻接表管理树结构。</li></ul></li><li><strong>状态压缩 DP</strong>：<ul><li><strong>题目</strong>：小规模集合优化，如 TSP、棋盘覆盖。</li><li><strong>解法</strong>：用二进制表示状态，转移枚举子集。</li><li><strong>示例</strong>：POJ 1185（炮兵阵地）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[i][s][t] ) 表示第 ( i ) 行，当前状态 ( s )，前一行状态 ( t )。</li><li>转移：枚举合法状态，检查兼容性。</li><li>复杂度：( O(n \times 2^m \times 2^m) )，( m ) 为列数。</li></ul></li><li><strong>Python 优势</strong>：位运算简洁，调试状态转换方便。</li></ul></li><li><strong>数位 DP</strong>：<ul><li><strong>题目</strong>：数字范围计数，如满足条件的数字个数。</li><li><strong>解法</strong>：定义 ( dp[pos][state] ) 为前 ( pos ) 位在某状态下的方案数，递归转移。</li><li><strong>示例</strong>：Luogu P2657（Scenic Number）。</li><li><strong>方法</strong>：<ul><li>状态：( dp[pos][prev][lead] ) 表示第 ( pos ) 位，前一位数字，是否前导零。</li><li>转移：枚举当前位数字，检查条件。</li><li>复杂度：( O(\log n \times \text{状态数}) ).</li></ul></li><li><strong>Python 优势</strong>：记忆化递归简洁，调试状态直观。<br><strong>ACM 优化技巧</strong>：</li></ul></li></ol><ul><li><strong>快速 I/O</strong>：Python 用 <code>sys.stdin.readline</code> 加速输入。</li><li><strong>滚动数组</strong>：背包、区间 DP 优化空间到 ( O(\min(n, m)) ).</li><li><strong>状态压缩</strong>：用位运算减少状态空间。</li><li><strong>边界处理</strong>：注意空状态、负索引、越界。</li><li><strong>调试</strong>：打印 DP 表格或递归路径，验证转移。<br><strong>Python 在 ACM 中的适用性</strong>：</li><li><strong>优点</strong>：<ul><li>简洁：Python 实现 DP 约 50-100 行，比赛中 10-20 分钟完成。</li><li>调试：<code>print</code> DP 表格或状态，验证正确性。</li><li>适用：( n \leq 10^5 )，时间限制 ≥ 1 秒，Python 通常通过。</li></ul></li><li><strong>缺点</strong>：<ul><li>效率：Python 比 C++ 慢 5-10 倍，复杂 DP 可能 TLE。</li><li>内存：Python 数组和递归占用较多内存。</li><li>严格限制：( n \geq 10^6 ) 或时间 &lt; 1 秒，可能 TLE。</li></ul></li><li><strong>优化</strong>：<ul><li>用 <code>array</code> 存储 DP 表格，减少内存。</li><li>迭代实现，降低递归开销。</li><li>预处理输入，减少 I/O 瓶颈。<br><strong>ACM 题目推荐</strong>：</li></ul></li><li>Luogu P1020：导弹拦截（LIS）。</li><li>Luogu P1048：采药（0-1 背包）。</li><li>Luogu P1880：石子合并（区间 DP）。</li><li>Luogu P1352：没有上司的舞会（树形 DP）。</li><li>POJ 1185：炮兵阵地（状态压缩 DP）。</li><li>Luogu P2657：Scenic Number（数位 DP）。</li></ul><hr><h2 id="4.-python-%E5%AE%9E%E7%8E%B0" tabindex="-1">4. Python 实现</h2><p>以下是几种典型 DP 问题的 Python 实现，包含递推和记忆化递归，带详细注释，适合 ACM 竞赛快速部署。</p><h3 id="4.1-0-1-%E8%83%8C%E5%8C%85%EF%BC%88%E9%80%92%E6%8E%A8%EF%BC%89" tabindex="-1">4.1 0-1 背包（递推）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack</span>(<span class="params">n: <span class="built_in">int</span>, W: <span class="built_in">int</span>, w: <span class="built_in">list</span>, v: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;0-1 背包：n 物品，容量 W，重量 w[i]，价值 v[i]，求最大价值&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># dp[j] 表示容量 j 的最大价值</span></span><br><span class="line">    dp = [<span class="number">0</span>] * (W + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 枚举物品</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 逆序枚举容量（滚动数组）</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(W, w[i] - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[W]</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">n, W = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">w, v = [], []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    wi, vi = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line">    w.append(wi)</span><br><span class="line">    v.append(vi)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0-1 Knapsack:&quot;</span>, knapsack(n, W, w, v))</span><br></pre></td></tr></table></figure><h3 id="4.2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%EF%BC%88%E8%AE%B0%E5%BF%86%E5%8C%96%E9%80%92%E5%BD%92%EF%BC%89" tabindex="-1">4.2 最长公共子序列（记忆化递归）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lcs</span>(<span class="params">A: <span class="built_in">str</span>, B: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;最长公共子序列：字符串 A 和 B 的 LCS 长度&quot;&quot;&quot;</span></span><br><span class="line">    m, n = <span class="built_in">len</span>(A), <span class="built_in">len</span>(B)</span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (i, j) <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">        <span class="keyword">if</span> A[i-<span class="number">1</span>] == B[j-<span class="number">1</span>]:</span><br><span class="line">            memo[(i, j)] = dp(i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            memo[(i, j)] = <span class="built_in">max</span>(dp(i-<span class="number">1</span>, j), dp(i, j-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> memo[(i, j)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp(m, n)</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">A = <span class="built_in">input</span>().strip()</span><br><span class="line">B = <span class="built_in">input</span>().strip()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;LCS Length:&quot;</span>, lcs(A, B))</span><br></pre></td></tr></table></figure><h3 id="4.3-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6%EF%BC%88%E5%8C%BA%E9%97%B4-dp%EF%BC%8C%E9%80%92%E6%8E%A8%EF%BC%89" tabindex="-1">4.3 石子合并（区间 DP，递推）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stone_merge</span>(<span class="params">n: <span class="built_in">int</span>, a: <span class="built_in">list</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;石子合并：n 堆石子，合并成一堆的最小代价&quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 前缀和</span></span><br><span class="line">    s = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        s[i + <span class="number">1</span>] = s[i] + a[i]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dp[l][r] 表示合并 [l, r] 的最小代价</span></span><br><span class="line">    dp = [[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        dp[i][i] = <span class="number">0</span>  <span class="comment"># 单堆无需合并</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 枚举区间长度</span></span><br><span class="line">    <span class="keyword">for</span> length <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 枚举左端点</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n - length + <span class="number">1</span>):</span><br><span class="line">            r = l + length - <span class="number">1</span></span><br><span class="line">            <span class="comment"># 枚举分割点</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r):</span><br><span class="line">                dp[l][r] = <span class="built_in">min</span>(dp[l][r], dp[l][k] + dp[k+<span class="number">1</span>][r] + s[r+<span class="number">1</span>] - s[l])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][n-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Stone Merge Cost:&quot;</span>, stone_merge(n, a))</span><br></pre></td></tr></table></figure><hr><h2 id="5.-%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B" tabindex="-1">5. 运行过程</h2><h3 id="5.1-0-1-%E8%83%8C%E5%8C%85" tabindex="-1">5.1 0-1 背包</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><ul><li>( n=4 )，( W=5 )，物品：( (w_1=2, v_1=3) ), ( (w_2=1, v_2=2) ), ( (w_3=3, v_3=4) ), ( (w_4=2, v_4=2) ).<br><strong>步骤</strong>：</li><li>初始化：( dp = [0, 0, 0, 0, 0, 0] ).</li><li>物品 1 (( w_1=2, v_1=3 ))：<ul><li>( j=5 \to 2 ): ( dp[5] = \max(0, dp[3]+3)=3 ), …, ( dp[2] = 3 ).</li><li>( dp = [0, 0, 3, 0, 0, 3] ).</li></ul></li><li>物品 2 (( w_2=1, v_2=2 ))：<ul><li>( j=5 \to 1 ): ( dp[5] = \max(3, dp[4]+2)=3 ), …, ( dp[1] = 2 ).</li><li>( dp = [0, 2, 3, 5, 2, 3] ).</li></ul></li><li>物品 3 (( w_3=3, v_3=4 ))：<ul><li>( j=5 \to 3 ): ( dp[5] = \max(3, dp[2]+4)=7 ), …, ( dp[3] = 5 ).</li><li>( dp = [0, 2, 3, 5, 6, 7] ).</li></ul></li><li>物品 4 (( w_4=2, v_4=2 ))：<ul><li>( j=5 \to 2 ): ( dp[5] = \max(7, dp[3]+2)=7 ), …, ( dp[2] = 3 ).</li><li>( dp = [0, 2, 3, 5, 6, 7] ).</li></ul></li><li>结果：( dp[5] = 7 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-1 Knapsack: 7</span><br></pre></td></tr></table></figure><h3 id="5.2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97" tabindex="-1">5.2 最长公共子序列</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABCD</span><br><span class="line">BECAD</span><br></pre></td></tr></table></figure><ul><li>字符串 ( A = “ABCD” )，( B = “BECAD” ).<br><strong>步骤</strong>：</li><li>记忆化递归：<ul><li>( dp(4, 5) ): ( A[3]=D ), ( B[4]=D ), 相等，( dp(4, 5) = dp(3, 4) + 1 ).</li><li>( dp(3, 4) ): ( A[2]=C ), ( B[3]=A ), 不等，( dp(3, 4) = \max(dp(2, 4), dp(3, 3)) ).</li><li>( dp(2, 4) ): ( A[1]=B ), ( B[3]=A ), 不等，( dp(2, 4) = \max(dp(1, 4), dp(2, 3)) ).</li><li>递归继续，计算所有状态。</li></ul></li><li>最终：( dp(4, 5) = 3 )（LCS 为 “BCD”）。</li><li>记忆化表格（部分）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   B E C A D</span><br><span class="line">A 0 0 0 0 0</span><br><span class="line">B 1 1 1 1 1</span><br><span class="line">C 1 1 2 2 2</span><br><span class="line">D 1 1 2 2 3</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LCS Length: 3</span><br></pre></td></tr></table></figure><h3 id="5.3-%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6" tabindex="-1">5.3 石子合并</h3><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 3 5 2</span><br></pre></td></tr></table></figure><ul><li>( n=4 )，石子：( a = [1, 3, 5, 2] ).<br><strong>步骤</strong>：</li><li>前缀和：( s = [0, 1, 4, 9, 11] ).</li><li>初始化：( dp[i][i] = 0 ).</li><li>长度 2：<ul><li>( dp[0][1] = s[2]-s[0] = 4 ).</li><li>( dp[1][2] = s[3]-s[1] = 8 ).</li><li>( dp[2][3] = s[4]-s[2] = 7 ).</li></ul></li><li>长度 3：<ul><li>( dp[0][2] = \min(dp[0][0]+dp[1][2], dp[0][1]+dp[2][2]) + s[3]-s[0] = \min(0+8, 4+0)+9 = 12 ).</li><li>( dp[1][3] = \min(dp[1][1]+dp[2][3], dp[1][2]+dp[3][3]) + s[4]-s[1] = \min(0+7, 8+0)+10 = 17 ).</li></ul></li><li>长度 4：<ul><li>( dp[0][3] = \min(dp[0][k]+dp[k+1][3]+s[4]-s[0]) = \min(0+17, 4+7, 12+0)+11 = 18 ).</li></ul></li><li>结果：( dp[0][3] = 18 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stone Merge Cost: 18</span><br></pre></td></tr></table></figure><hr><h2 id="6.-dp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9" tabindex="-1">6. DP 的优缺点</h2><h3 id="6.1-%E4%BC%98%E7%82%B9" tabindex="-1">6.1 优点</h3><ul><li><strong>高效性</strong>：将指数复杂度降为多项式（如斐波那契从 ( O(2^n) ) 到 ( O(n) )）。</li><li><strong>通用性</strong>：适用于优化、计数、概率等多种问题。</li><li><strong>ACM 友好</strong>：Python 实现简洁，约 50-100 行，比赛中 10-20 分钟完成。</li><li><strong>可优化</strong>：滚动数组、状态压缩显著降低空间复杂度。</li><li><strong>调试方便</strong>：DP 表格直观，易于验证。</li></ul><h3 id="6.2-%E7%BC%BA%E7%82%B9" tabindex="-1">6.2 缺点</h3><ul><li><strong>状态设计复杂</strong>：需要准确定义状态和转移，初学者易出错。</li><li><strong>空间限制</strong>：多维 DP 可能占用大量内存。</li><li><strong>ACM 限制</strong>：<ul><li>大输入（( n \geq 10^6 )）或时间 &lt; 1 秒，Python 可能 TLE。</li><li>复杂状态压缩或数位 DP 实现难度高。</li></ul></li><li><strong>依赖经验</strong>：状态转移方程推导需熟练，比赛中时间紧迫。</li></ul><h3 id="6.3-%E6%94%B9%E8%BF%9B%E6%96%B9%E5%90%91" tabindex="-1">6.3 改进方向</h3><ul><li><strong>滚动数组</strong>：优化空间到 ( O(\min(n, m)) ).</li><li><strong>状态压缩</strong>：用位运算减少状态数。</li><li><strong>迭代实现</strong>：将记忆化递归转为递推，降低递归开销。</li><li><strong>快速 I/O</strong>：优化 Python 输入输出。</li><li><strong>Cython/Numba</strong>：加速 Python 循环（非比赛场景）。</li></ul><hr><h2 id="7.-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94" tabindex="-1">7. 与其他方法的对比</h2><h3 id="7.1-%E4%B8%8E%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" tabindex="-1">7.1 与贪心算法</h3><ul><li><strong>目标</strong>：<ul><li>贪心：局部最优，快速决策。</li><li>DP：全局最优，考虑所有可能。</li></ul></li><li><strong>适用性</strong>：<ul><li>贪心：活动选择、Huffman 编码。</li><li>DP：0-1 背包、LCS。</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>贪心：简单问题，Python 实现快。</li><li>DP：复杂优化问题，Python 通用。</li></ul></li><li><strong>Python 实现</strong>：<ul><li>贪心：代码短，逻辑简单。</li><li>DP：代码稍长，状态设计复杂。</li></ul></li></ul><h3 id="7.2-%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95" tabindex="-1">7.2 与分治算法</h3><ul><li><strong>目标</strong>：<ul><li>分治：分解为独立子问题。</li><li>DP：分解为重叠子问题。</li></ul></li><li><strong>适用性</strong>：<ul><li>分治：归并排序、快速排序。</li><li>DP：LIS、背包问题。</li></ul></li><li><strong>ACM 适用性</strong>：<ul><li>分治：分治 + 递归，适合无重叠问题。</li><li>DP：优化重叠子问题，适合序列、图。</li></ul></li><li><strong>Python 实现</strong>：<ul><li>分治：递归简洁，但可能重复计算。</li><li>DP：存储优化，效率更高。</li></ul></li></ul><h3 id="7.3-%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%93%E5%90%88" tabindex="-1">7.3 与数据结构结合</h3><ul><li><strong>DP + 线段树</strong>：<ul><li>题目：动态区间优化。</li><li>解法：DP 定义状态，线段树维护区间最优值。</li><li>示例：Codeforces 474E（Pillars，LIS + 线段树）。</li></ul></li><li><strong>DP + 单调队列/栈</strong>：<ul><li>题目：序列优化。</li><li>解法：单调队列维护 DP 转移的最优候选。</li><li>示例：Luogu P1725（琪露诺，单调队列 DP）。</li></ul></li><li><strong>DP + 树</strong>：<ul><li>题目：树上优化。</li><li>解法：树形 DP 递归转移。</li><li>示例：Luogu P1352（没有上司的舞会）。</li></ul></li></ul><hr><h2 id="8.-%E6%A8%A1%E6%8B%9F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%88%E8%A1%A5%E5%85%85%E6%95%B0%E4%BD%8D-dp%EF%BC%89" tabindex="-1">8. 模拟运行过程（补充数位 DP）</h2><h3 id="8.1-%E6%95%B0%E4%BD%8D-dp" tabindex="-1">8.1 数位 DP</h3><p><strong>问题</strong>：统计区间 ([L, R]) 内，数字各位之和为 ( K ) 的数的个数。<br><strong>代码</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">input</span> = sys.stdin.readline</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digit_dp</span>(<span class="params">L: <span class="built_in">int</span>, R: <span class="built_in">int</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;数位 DP：统计 [L, R] 内各位和为 K 的数的个数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">num: <span class="built_in">str</span>, K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(num)</span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dp</span>(<span class="params">pos: <span class="built_in">int</span>, <span class="built_in">sum</span>: <span class="built_in">int</span>, tight: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> pos == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="built_in">sum</span> == K <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &gt; K:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (pos, <span class="built_in">sum</span>, tight) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[(pos, <span class="built_in">sum</span>, tight)]</span><br><span class="line">            </span><br><span class="line">            ans = <span class="number">0</span></span><br><span class="line">            limit = <span class="built_in">int</span>(num[pos]) <span class="keyword">if</span> tight <span class="keyword">else</span> <span class="number">9</span></span><br><span class="line">            <span class="keyword">for</span> d <span class="keyword">in</span> <span class="built_in">range</span>(limit + <span class="number">1</span>):</span><br><span class="line">                new_tight = tight <span class="keyword">and</span> d == limit</span><br><span class="line">                ans += dp(pos + <span class="number">1</span>, <span class="built_in">sum</span> + d, new_tight)</span><br><span class="line">            </span><br><span class="line">            memo[(pos, <span class="built_in">sum</span>, tight)] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> count(<span class="built_in">str</span>(R), K) - count(<span class="built_in">str</span>(L-<span class="number">1</span>), K)</span><br><span class="line"><span class="comment"># 测试</span></span><br><span class="line">L, R, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Digit DP Count:&quot;</span>, digit_dp(L, R, K))</span><br></pre></td></tr></table></figure><p><strong>输入</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 20 5</span><br></pre></td></tr></table></figure><ul><li>区间 ([1, 20])，各位和为 5.<br><strong>步骤</strong>：</li><li>计算 ( \text{count}(20, 5) )：<ul><li>( dp(0, 0, \text{True}) ):<ul><li>枚举第一位 ( d=0 \to 2 )：<ul><li>( d=1 ): ( dp(1, 1, \text{True}) ).</li><li>( d=2 ): ( dp(1, 2, \text{True}) ).</li></ul></li><li>( dp(1, 1, \text{True}) ): 第二位 ( d=0 \to 0 )，( dp(2, 1+0, \text{True}) = 0 )（sum=1 &lt; 5）。</li><li>( dp(1, 2, \text{True}) ): ( d=0 )，( dp(2, 2+0, \text{True}) = 0 )（sum=2 &lt; 5）。</li></ul></li><li>结果：0（20 各位和 ≠ 5）。</li></ul></li><li>计算 ( \text{count}(0, 5) )：类似，0（无数字和 5）。</li><li>枚举 ([1, 20])：和为 5 的数为 5, 14。</li><li>结果：( 2 ).<br><strong>输出</strong>：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Digit DP Count: 2</span><br></pre></td></tr></table></figure><hr><h2 id="9.-%E6%80%BB%E7%BB%93" tabindex="-1">9. 总结</h2><p>动态规划是解决优化和计数问题的核心方法，通过状态设计和转移高效分解问题：</p><ul><li><strong>核心性质</strong>：最优子结构、重叠子问题、无后效性。</li><li><strong>编程方法</strong>：递推（自底向上）、记忆化递归（自顶向下）、空间优化。</li><li><strong>ACM 应用</strong>：线性 DP、背包、区间 DP、树形 DP、状态压缩、数位 DP。</li><li><strong>Python 实现</strong>：约 50-100 行，调试方便，适合 ( n \leq 10^5 )，时间 ≥ 1 秒。</li><li><strong>优化</strong>：滚动数组、状态压缩、快速 I/O。<br>通过 Python 代码和样例模拟，展示了 DP 的常见类型和运行过程。在 ACM 竞赛中，DP 是不可或缺的工具，Python 实现适合快速原型和中小规模问题。<br><strong>学习建议</strong>：</li></ul><ol><li><strong>手动模拟</strong>：用小数据（如 ( n=4 )）画 DP 表格，推导转移。</li><li><strong>ACM 练习</strong>：尝试 Luogu P1020、P1048、P1880，用 Python 实现 DP。</li><li><strong>深入扩展</strong>：学习单调队列 DP、斜率优化、凸包优化。</li><li><strong>比赛策略</strong>：<ul><li>优先 Python 快速实现，验证正确性。</li><li>若 TLE，优化 I/O 或切换 C++.<br>如果你有其他问题、需要优化 Python 代码、或想探讨 ACM 题目（如复杂 DP 优化、数据结构结合），请随时告诉我！</li></ul></li></ol><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88dynamic-programming%EF%BC%8C%E7%AE%80%E7%A7%B0-dp%EF%BC%89%E6%98%AF%E7%AE%97%E6%B3%95%E</summary>
      
    
    
    
    
    <category term="算法" scheme="https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
