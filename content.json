{"meta":{"title":"Hexo","subtitle":"","description":"","author":"borrowyourhuaji","url":"https://borrowyourhuaji.github.io","root":"/"},"pages":[],"posts":[{"title":"线段树","slug":"线段树","date":"2025-09-13T12:57:08.000Z","updated":"2025-09-13T12:59:01.534Z","comments":true,"path":"2025/09/13/线段树/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"好的，我将详细讲解线段树（Segment Tree）的概念。线段树是一种非常重要的数据结构，特别是在处理区间查询和更新问题时表现出色。以下是对线段树的全面讲解：1. 什么是线段树？线段树是一种二叉树数据结构，用于存储区间（或称为“线段”）的信息，并支持快速的查询和更新操作。它特别适合解决与区间相关的动态问题，例如： 求某个区间的和。 查找某个区间的最大值或最小值。 对某个区间进行批量更新。线段树的核心思想是将一个大区间递归地划分成多个小子区间，并通过树形结构高效地维护和查询这些区间的聚合信息。 2. 线段树的结构线段树的结构可以用以下方式描述： 节点：每个节点代表一个区间。 根节点：代表整个区间（例如数组的范围[1, n]）。 叶子节点：代表单个元素（例如数组中的某个值）。 中间节点：代表某个子区间（介于根节点和叶子节点之间）。例如，对于一个数组[1, 3, 5, 7, 9, 11]，线段树的结构如下： 根节点表示区间[1, 6]。 根的左子节点表示[1, 3]，右子节点表示[4, 6]。 进一步划分后，叶子节点分别表示[1, 1]、[2, 2]、[3, 3]、[4, 4]、[5, 5]和[6, 6]。这种递归划分的方式使得线段树能够高效地处理区间问题。 3. 线段树的基本操作线段树主要支持以下两种核心操作： 查询（Query）查询操作用于获取某个区间的聚合信息，例如： 区间的和。 区间的最大值或最小值。 更新（Update）更新操作用于修改数据，例如： 修改单个元素的值（单点更新）。 对某个区间的元素进行批量修改（区间更新）。这两种操作的时间复杂度均为O(log n)，其中n是数组的大小。这是对数级别的高效性使得线段树非常适合动态查询问题。 4. 线段树的构建线段树的构建是一个递归过程，通常自底向上完成。以下是构建线段树的基本步骤： 从根节点开始：根节点表示整个区间，例如[1, n]。 划分区间：将当前区间划分为两个子区间，例如[1, mid]和[mid+1, n]，其中mid = (left + right) / 2。 递归构建子树：对左子区间和右子区间分别递归构建子树，直到达到叶子节点。 合并信息：在回溯时，根据具体问题将子节点的信息合并到当前节点。例如，对于区间求和问题，当前节点的值是左子节点和右子节点值的和。示例：对于数组[1, 3, 5, 7, 9, 11]： 根节点存储[1, 6]的和：1 + 3 + 5 + 7 + 9 + 11 = 36。 左子节点存储[1, 3]的和：1 + 3 + 5 = 9。 右子节点存储[4, 6]的和：7 + 9 + 11 = 27。 递归继续，直到叶子节点存储单个元素。 5. 线段树的查询查询操作同样是递归进行的，用于在O(log n)时间内获取某个区间的聚合信息。查询步骤如下： 判断当前区间与查询区间的关系： 完全包含：如果当前区间完全在查询区间内，直接返回当前节点的值。 无交集：如果当前区间与查询区间无重叠，返回一个不影响结果的值（例如求和时返回0，求最大值时返回负无穷）。 部分重叠：递归查询左子树和右子树，并合并结果。 合并结果：根据具体问题合并子查询的结果。例如，求和时将左右子树的结果相加。示例：查询数组[1, 3, 5, 7, 9, 11]中区间[2, 5]的和： 根节点[1, 6]与[2, 5]部分重叠，递归查询子节点。 左子节点[1, 3]与[2, 5]部分重叠，继续递归，最终得到[2, 3]的和3 + 5 = 8。 右子节点[4, 6]与[2, 5]部分重叠，最终得到[4, 5]的和7 + 9 = 16。 合并结果：8 + 16 = 24。 6. 线段树的更新更新操作分为两种类型： 单点更新修改数组中某个元素的值，并更新线段树中所有相关节点： 递归找到对应的叶子节点。 更新叶子节点的值。 回溯时，更新所有包含该叶子节点的父节点。示例：将数组[1, 3, 5, 7, 9, 11]中的第2个元素从3改为10： 找到叶子节点[2, 2]，更新值为10。 向上更新：[1, 3]的和从9变为1 + 10 + 5 = 16，根节点[1, 6]的和从36变为43。 区间更新对某个区间的元素进行批量修改，例如将区间[2, 4]的所有值增加5。通常使用**延迟标记（Lazy Propagation）**优化，避免直接更新所有叶子节点： 在需要更新的节点上记录延迟标记。 在下次查询或更新时，将标记传播到子节点。 7. 线段树的空间复杂度线段树是一个近似满二叉树，节点总数约为2n-1，因此空间复杂度为O(n)，其中n是数组的大小。8. 线段树的应用线段树在算法问题中有广泛应用，包括但不限于： 区间求和：计算任意区间的和。 区间最值：查找任意区间的最大值或最小值。 区间更新：对某个区间批量加减一个值。 动态规划优化：加速某些状态转移。 9. 线段树的优点与缺点优点 查询和更新时间复杂度均为O(log n)，高效处理动态问题。 灵活性强，可根据问题定制功能。 缺点 实现相对复杂，代码量较大。 空间消耗较高，需要额外的O(n)存储。 9. 手动实现线段树由于 Python 标准库和主流第三方库中没有直接提供线段树，开发者通常会根据问题需求手动实现。以下是一个简单的 Python 线段树实现，用于支持区间求和和单点更新，并包含详细注释以便理解。 代码实现：区间求和线段树1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from typing import Listclass SegmentTree: def __init__(self, arr: List[int]): &quot;&quot;&quot;初始化线段树，arr 是输入数组&quot;&quot;&quot; self.n = len(arr) # 数组长度 self.tree = [0] * (4 * self.n) # 线段树数组，4n 足以容纳所有节点 self.arr = arr # 保存原始数组 if self.n &gt; 0: self._build(0, 0, self.n - 1) # 递归构建线段树 def _build(self, node: int, start: int, end: int): &quot;&quot;&quot;递归构建线段树，node 是当前节点，[start, end] 是当前区间&quot;&quot;&quot; if start == end: # 叶子节点，直接存储数组元素 self.tree[node] = self.arr[start] return mid = (start + end) // 2 left_node = 2 * node + 1 # 左子节点 right_node = 2 * node + 2 # 右子节点 # 递归构建左右子树 self._build(left_node, start, mid) self._build(right_node, mid + 1, end) # 合并子节点信息：当前节点存储左右子节点的和 self.tree[node] = self.tree[left_node] + self.tree[right_node] def update(self, index: int, value: int): &quot;&quot;&quot;单点更新：将 arr[index] 更新为 value&quot;&quot;&quot; self.arr[index] = value self._update(0, 0, self.n - 1, index, value) def _update(self, node: int, start: int, end: int, index: int, value: int): &quot;&quot;&quot;递归更新线段树，index 是要更新的位置，value 是新值&quot;&quot;&quot; if start == end: # 叶子节点，直接更新 self.tree[node] = value return mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归更新左子树或右子树 if index &lt;= mid: self._update(left_node, start, mid, index, value) else: self._update(right_node, mid + 1, end, index, value) # 合并更新后的子节点信息 self.tree[node] = self.tree[left_node] + self.tree[right_node] def query(self, left: int, right: int) -&gt; int: &quot;&quot;&quot;查询区间 [left, right] 的和&quot;&quot;&quot; return self._query(0, 0, self.n - 1, left, right) def _query(self, node: int, start: int, end: int, left: int, right: int) -&gt; int: &quot;&quot;&quot;递归查询 [left, right] 的和&quot;&quot;&quot; if left &lt;= start and end &lt;= right: # 当前区间完全包含在查询区间内，直接返回节点值 return self.tree[node] if right &lt; start or left &gt; end: # 当前区间与查询区间无交集，返回 0 return 0 mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归查询左右子树，并合并结果 left_sum = self._query(left_node, start, mid, left, right) right_sum = self._query(right_node, mid + 1, end, left, right) return left_sum + right_sum# 测试代码if __name__ == &quot;__main__&quot;: # 初始数组 arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # 测试查询 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：3 + 5 + 7 = 15 # 测试更新 seg_tree.update(1, 10) # 将 arr[1] 从 3 更新为 10 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：10 + 5 + 7 = 22 代码说明 初始化 (__init__)： 创建线段树数组 tree，大小为 4n（足以容纳所有节点）。 调用 _build 递归构建线段树，存储每个区间的和。 构建 (_build)： 递归划分区间，直到叶子节点。 叶子节点存储原始数组元素，中间节点存储子节点和。 更新 (update 和 _update)： 单点更新：递归找到对应的叶子节点，更新值。 回溯时更新所有相关父节点的和。 查询 (query 和 _query)： 查询区间 [left, right] 的和。 递归处理三种情况：完全包含、无交集、部分重叠。 时间复杂度： 构建：( O(n) ) 查询：( O(\\log n) ) 更新：( O(\\log n) ) 空间复杂度： ( O(n) )，线段树需要 ( 4n ) 的空间。 10. 线段树的高级功能（需要时可扩展实现）手动实现的线段树可以根据问题需求扩展，以下是常见的高级功能： 区间更新（Lazy Propagation）： 支持对整个区间批量修改（如将 [l, r] 的值增加一个常数）。 使用延迟标记（lazy tag）记录未传播的更新，减少时间开销。 适用场景：动态修改大范围数据。 区间最值： 修改线段树存储最大值或最小值，而不是和。 例如，查询 [l, r] 的最大值，只需将合并操作从 + 改为 max。 动态线段树： 支持动态添加或删除节点，适用于数据范围不确定的场景。 实现较复杂，通常结合指针或动态分配。 持久化线段树： 保留线段树的历史版本，支持查询历史状态。 常用于函数式编程或需要回溯的问题。","categories":[],"tags":[]},{"title":"动态规划","slug":"动态规划","date":"2025-09-13T11:16:41.000Z","updated":"2025-09-13T12:53:33.325Z","comments":true,"path":"2025/09/13/动态规划/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划（Dynamic Programming，简称 DP）是算法设计中的一种重要方法，用于解决具有 重叠子问题 和 最优子结构 的优化问题。它通过将问题分解为较小的子问题，存储子问题的解以避免重复计算，从而高效求解复杂问题。在 ACM 竞赛 中，DP 是核心技巧，广泛应用于序列、图、树、背包、区间等问题。本文将详细讲解 DP 的概念、性质、设计步骤、常见类型、编程方法、在 ACM 竞赛中的应用，并提供带详细注释的 Python 实现 示例，以及模拟运行过程，帮助全面理解 DP 及其在竞赛中的价值。1. 动态规划的基本概念1.1 定义动态规划是一种通过 分阶段 解决问题的方法，每个阶段的决策依赖于前几个阶段的解。DP 的核心思想是： 分解问题：将原问题分解为若干子问题。 存储中间结果：用表格（数组或哈希表）保存子问题的解，避免重复计算。 递归求解：通过子问题的解递归构建原问题的解。DP 通常用于求解 最优化问题（如最大值、最小值、最短路径）或 计数问题（如方案数），其适用条件包括： 最优子结构：原问题的最优解可由子问题的最优解构成。 重叠子问题：子问题在递归分解中被多次求解，适合存储优化。 无后效性：当前阶段的决策只依赖于之前阶段的状态，不受后续决策影响。示例： 斐波那契数列：第 ( n ) 项 ( F(n) &#x3D; F(n-1) + F(n-2) )，子问题重叠，直接递归效率低，DP 存储中间结果优化。 最长公共子序列（LCS）：字符串 ( A ) 和 ( B ) 的 LCS 依赖于前缀的 LCS，具有最优子结构。 1.2 关键性质 状态（State）：用变量表示子问题的解，通常是数组或多维表格，如 ( dp[i] ) 表示前 ( i ) 项的最优解。 状态转移方程（Transition）：描述如何从已知状态推导新状态，如 ( dp[i] &#x3D; \\max(dp[i-1], dp[i-2]) )。 初始条件（Base Case）：DP 表格的起点，如 ( dp[0] &#x3D; 0 )。 目标：最终求解的状态，如 ( dp[n] )。 时间复杂度：通常为 ( O(\\text{状态数} \\times \\text{转移复杂度}) ). 空间复杂度：取决于状态存储，通常为 ( O(\\text{状态数}) )，可通过滚动数组优化。 1.3 DP 与其他方法的区别 与递归（Recursion）： 递归直接分解问题，可能重复计算子问题（指数复杂度）。 DP 存储子问题解（通常多项式复杂度）。 与分治（Divide and Conquer）： 分治将问题分为独立子问题（如归并排序）。 DP 处理重叠子问题，子问题间有依赖。 与贪心（Greedy）： 贪心基于局部最优，适用于特定问题（如活动选择）。 DP 考虑全局最优，适用范围更广（如 0-1 背包）。 1.4 DP 的设计步骤 定义状态：确定 ( dp[i][j]… ) 表示什么，通常与子问题相关。 推导状态转移方程：分析当前状态如何由前几个状态得出。 确定初始条件：初始化边界状态（如 ( dp[0][0] )。 计算顺序：确保状态按依赖顺序计算（自底向上或记忆化递归）。 求解目标：输出最终状态（如 ( dp[n][m] \\）。 优化空间：若状态只依赖前几行&#x2F;列，用滚动数组减少空间。 1.5 常见 DP 类型 线性 DP：状态沿一维序列转移，如斐波那契、LIS（最长递增子序列）。 背包 DP：处理资源分配，如 0-1 背包、完全背包。 区间 DP：处理区间合并或分割，如石子合并、括号匹配。 树形 DP：在树上进行状态转移，如树的最小支配集。 状态压缩 DP：用二进制表示状态，适合小规模集合问题。 数位 DP：处理数字范围内的计数问题，如数字和。 概率&#x2F;期望 DP：计算概率或期望值，如博弈问题。 多维 DP：处理多变量状态，如 LCS、编辑距离。 1.6 应用场景 ACM 竞赛： 序列问题：LIS、LCS、编辑距离。 背包问题：0-1 背包、完全背包、多重背包。 区间问题：石子合并、区间调度。 树上问题：树形 DP、最小点覆盖。 图上问题：最短路径、DAG 上的 DP。 实际应用： 机器学习：隐马尔可夫模型（HMM）、Viterbi 算法。 运筹学：资源分配、调度优化。 生物信息学：序列比对。 1.7 复杂度分析 时间复杂度：( O(\\text{状态数} \\times \\text{转移复杂度}) )。 例：LCS 为 ( O(n \\times m) )，状态数 ( n \\times m )，转移 ( O(1) )。 空间复杂度：( O(\\text{状态数}) )，可通过滚动数组优化到 ( O(\\text{较小维度}) )。 记忆化递归：与递推等价，适合状态空间稀疏或难以确定计算顺序。 2. 动态规划的编程方法DP 的实现方式主要分为 递推（Bottom-Up） 和 记忆化递归（Top-Down），以下详细讲解两种方法的特点和实现步骤。 2.1 递推（Bottom-Up） 特点： 自底向上计算，从初始状态递推到目标状态。 使用循环填充 DP 表格，适合状态空间连续。 空间效率高，易于优化（如滚动数组）。 步骤： 定义 DP 数组（如 ( dp[i][j] )）。 初始化边界条件。 按状态依赖顺序循环，计算状态转移。 返回目标状态。 适用场景：状态空间明确，计算顺序简单（如线性 DP、背包 DP）。 优点： 避免递归开销，运行效率高。 易于调试，状态计算顺序清晰。 缺点： 状态空间稀疏时可能浪费计算。 复杂状态转移可能难以推导。示例：0-1 背包问题 问题：给定 ( n ) 个物品，重量 ( w[i] )，价值 ( v[i] )，背包容量 ( W )，求最大价值。 状态：( dp[i][j] ) 表示前 ( i ) 个物品，容量 ( j ) 时的最大价值。 转移：( dp[i][j] &#x3D; \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) )（若 ( j \\geq w[i] )）。 初始：( dp[0][j] &#x3D; 0 )，( dp[i][0] &#x3D; 0 )。 目标：( dp[n][W] ). 2.2 记忆化递归（Top-Down） 特点： 自顶向下递归，从目标状态分解到子问题。 使用记忆化（Memoization）存储已计算的子问题解。 适合状态空间稀疏或状态转移复杂。 步骤： 定义递归函数，参数表示状态。 创建记忆化表格（如字典或数组）。 在递归中检查是否已计算，若是返回缓存结果。 计算状态转移，存储结果。 适用场景：状态空间不规则、递归关系复杂（如树形 DP、数位 DP）。 优点： 代码直观，递归逻辑易于理解。 仅计算用到的状态，适合稀疏问题。 缺点： 递归栈开销大，可能导致栈溢出。 Python 递归深度有限，需调整或转为递推。示例：最长公共子序列（LCS） 问题：给定字符串 ( A ) 和 ( B )，求最长公共子序列长度。 状态：( dp[i][j] ) 表示 ( A[0:i] ) 和 ( B[0:j] ) 的 LCS 长度。 转移： 若 ( A[i-1] &#x3D;&#x3D; B[j-1] )，则 ( dp[i][j] &#x3D; dp[i-1][j-1] + 1 )。 否则，( dp[i][j] &#x3D; \\max(dp[i-1][j], dp[i][j-1]) )。 初始：( dp[0][j] &#x3D; 0 )，( dp[i][0] &#x3D; 0 ). 目标：( dp[|A|][|B|] ). 2.3 空间优化 滚动数组： 若状态只依赖前几行&#x2F;列，用小数组覆盖大数组。 例：0-1 背包从 ( dp[n][W] ) 优化到 ( dp[W] )，空间 ( O(W) ). 状态压缩： 用位运算表示状态，适合状态压缩 DP。 例：TSP（旅行商问题），状态从 ( O(n \\times 2^n) ) 压缩到 ( O(2^n) ). 稀疏存储： 用字典或哈希表存储非零状态，适合记忆化递归。 2.4 调试与优化 调试： 打印 DP 表格，验证状态转移。 检查边界条件和初始值。 用小数据手动模拟，确保逻辑正确。 优化： 快速 I&#x2F;O：Python 用 sys.stdin.readline 加速输入。 常数优化：减少循环内操作，如提前计算常量。 并行化：复杂 DP 可分块并行（非比赛场景）。 Cython&#x2F;Numba：加速 Python 循环（非比赛场景）。 3. 在 ACM 竞赛中的应用DP 在 ACM 竞赛中是解决优化和计数问题的核心工具，因其 通用性 和 高效性 广泛应用于各种题型。以下是常见类型和解题思路： 线性 DP： 题目：求序列的最优解，如最长递增子序列（LIS）。 解法：定义 ( dp[i] ) 为以 ( i ) 结尾的最优解，转移考虑前序状态。 示例：Luogu P1020（导弹拦截，LIS）。 方法： 状态：( dp[i] ) 表示以 ( a[i] ) 结尾的 LIS 长度。 转移：( dp[i] &#x3D; \\max(dp[j]) + 1 )，其中 ( j &lt; i )，( a[j] &lt; a[i] ). 复杂度：( O(n^2) )，可优化到 ( O(n \\log n) )（二分）。 Python 优势：列表操作简洁，调试方便。 背包 DP： 题目：资源分配，如 0-1 背包、完全背包。 解法：定义 ( dp[i][j] ) 为前 ( i ) 项容量 ( j ) 的最优解，转移考虑是否选择当前项。 示例：Luogu P1048（采药，0-1 背包）。 方法： 状态：( dp[i][j] ) 表示前 ( i ) 种草药，容量 ( j ) 的最大价值。 转移：( dp[i][j] &#x3D; \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) ). 滚动数组：优化到 ( dp[j] )，空间 ( O(W) ). Python 优势：数组操作直观，滚动数组实现简单。 区间 DP： 题目：处理区间合并或分割，如石子合并。 解法：定义 ( dp[l][r] ) 为区间 ( [l, r] ) 的最优解，转移枚举分割点。 示例：Luogu P1880（石子合并）。 方法： 状态：( dp[l][r] ) 表示合并 ( [l, r] ) 石子的最小代价。 转移：( dp[l][r] &#x3D; \\min(dp[l][k] + dp[k+1][r] + \\text{sum}[l,r]) )，( k \\in [l, r-1] ). 复杂度：( O(n^3) ). Python 优势：二维数组操作简洁，调试区间状态方便。 树形 DP： 题目：树上优化，如最小支配集。 解法：定义 ( dp[u][s] ) 为节点 ( u ) 在状态 ( s ) 下的最优解，递归转移。 示例：Luogu P1352（没有上司的舞会）。 方法： 状态：( dp[u][0&#x2F;1] ) 表示节点 ( u ) 不选&#x2F;选的最大快乐值。 转移：( dp[u][0] &#x3D; \\sum \\max(dp[v][0], dp[v][1]) )，( dp[u][1] &#x3D; r[u] + \\sum dp[v][0] ). 复杂度：( O(n) ). Python 优势：递归实现直观，邻接表管理树结构。 状态压缩 DP： 题目：小规模集合优化，如 TSP、棋盘覆盖。 解法：用二进制表示状态，转移枚举子集。 示例：POJ 1185（炮兵阵地）。 方法： 状态：( dp[i][s][t] ) 表示第 ( i ) 行，当前状态 ( s )，前一行状态 ( t )。 转移：枚举合法状态，检查兼容性。 复杂度：( O(n \\times 2^m \\times 2^m) )，( m ) 为列数。 Python 优势：位运算简洁，调试状态转换方便。 数位 DP： 题目：数字范围计数，如满足条件的数字个数。 解法：定义 ( dp[pos][state] ) 为前 ( pos ) 位在某状态下的方案数，递归转移。 示例：Luogu P2657（Scenic Number）。 方法： 状态：( dp[pos][prev][lead] ) 表示第 ( pos ) 位，前一位数字，是否前导零。 转移：枚举当前位数字，检查条件。 复杂度：( O(\\log n \\times \\text{状态数}) ). Python 优势：记忆化递归简洁，调试状态直观。ACM 优化技巧： 快速 I&#x2F;O：Python 用 sys.stdin.readline 加速输入。 滚动数组：背包、区间 DP 优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态空间。 边界处理：注意空状态、负索引、越界。 调试：打印 DP 表格或递归路径，验证转移。Python 在 ACM 中的适用性： 优点： 简洁：Python 实现 DP 约 50-100 行，比赛中 10-20 分钟完成。 调试：print DP 表格或状态，验证正确性。 适用：( n \\leq 10^5 )，时间限制 ≥ 1 秒，Python 通常通过。 缺点： 效率：Python 比 C++ 慢 5-10 倍，复杂 DP 可能 TLE。 内存：Python 数组和递归占用较多内存。 严格限制：( n \\geq 10^6 ) 或时间 &lt; 1 秒，可能 TLE。 优化： 用 array 存储 DP 表格，减少内存。 迭代实现，降低递归开销。 预处理输入，减少 I&#x2F;O 瓶颈。ACM 题目推荐： Luogu P1020：导弹拦截（LIS）。 Luogu P1048：采药（0-1 背包）。 Luogu P1880：石子合并（区间 DP）。 Luogu P1352：没有上司的舞会（树形 DP）。 POJ 1185：炮兵阵地（状态压缩 DP）。 Luogu P2657：Scenic Number（数位 DP）。 4. Python 实现以下是几种典型 DP 问题的 Python 实现，包含递推和记忆化递归，带详细注释，适合 ACM 竞赛快速部署。 4.1 0-1 背包（递推）12345678910111213141516171819202122import sysinput = sys.stdin.readlinedef knapsack(n: int, W: int, w: list, v: list) -&gt; int: &quot;&quot;&quot;0-1 背包：n 物品，容量 W，重量 w[i]，价值 v[i]，求最大价值&quot;&quot;&quot; # dp[j] 表示容量 j 的最大价值 dp = [0] * (W + 1) # 枚举物品 for i in range(n): # 逆序枚举容量（滚动数组） for j in range(W, w[i] - 1, -1): dp[j] = max(dp[j], dp[j - w[i]] + v[i]) return dp[W]# 测试n, W = map(int, input().split())w, v = [], []for _ in range(n): wi, vi = map(int, input().split()) w.append(wi) v.append(vi)print(&quot;0-1 Knapsack:&quot;, knapsack(n, W, w, v)) 4.2 最长公共子序列（记忆化递归）1234567891011121314151617181920212223import sysinput = sys.stdin.readlinedef lcs(A: str, B: str) -&gt; int: &quot;&quot;&quot;最长公共子序列：字符串 A 和 B 的 LCS 长度&quot;&quot;&quot; m, n = len(A), len(B) memo = &#123;&#125; def dp(i: int, j: int) -&gt; int: if i == 0 or j == 0: return 0 if (i, j) in memo: return memo[(i, j)] if A[i-1] == B[j-1]: memo[(i, j)] = dp(i-1, j-1) + 1 else: memo[(i, j)] = max(dp(i-1, j), dp(i, j-1)) return memo[(i, j)] return dp(m, n)# 测试A = input().strip()B = input().strip()print(&quot;LCS Length:&quot;, lcs(A, B)) 4.3 石子合并（区间 DP，递推）12345678910111213141516171819202122232425262728import sysinput = sys.stdin.readlinedef stone_merge(n: int, a: list) -&gt; int: &quot;&quot;&quot;石子合并：n 堆石子，合并成一堆的最小代价&quot;&quot;&quot; # 前缀和 s = [0] * (n + 1) for i in range(n): s[i + 1] = s[i] + a[i] # dp[l][r] 表示合并 [l, r] 的最小代价 dp = [[float(&#x27;inf&#x27;)] * n for _ in range(n)] for i in range(n): dp[i][i] = 0 # 单堆无需合并 # 枚举区间长度 for length in range(2, n + 1): # 枚举左端点 for l in range(n - length + 1): r = l + length - 1 # 枚举分割点 for k in range(l, r): dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + s[r+1] - s[l]) return dp[0][n-1]# 测试n = int(input())a = list(map(int, input().split()))print(&quot;Stone Merge Cost:&quot;, stone_merge(n, a)) 5. 运行过程5.1 0-1 背包输入： 123454 52 31 23 42 2 ( n&#x3D;4 )，( W&#x3D;5 )，物品：( (w_1&#x3D;2, v_1&#x3D;3) ), ( (w_2&#x3D;1, v_2&#x3D;2) ), ( (w_3&#x3D;3, v_3&#x3D;4) ), ( (w_4&#x3D;2, v_4&#x3D;2) ).步骤： 初始化：( dp &#x3D; [0, 0, 0, 0, 0, 0] ). 物品 1 (( w_1&#x3D;2, v_1&#x3D;3 ))： ( j&#x3D;5 \\to 2 ): ( dp[5] &#x3D; \\max(0, dp[3]+3)&#x3D;3 ), …, ( dp[2] &#x3D; 3 ). ( dp &#x3D; [0, 0, 3, 0, 0, 3] ). 物品 2 (( w_2&#x3D;1, v_2&#x3D;2 ))： ( j&#x3D;5 \\to 1 ): ( dp[5] &#x3D; \\max(3, dp[4]+2)&#x3D;3 ), …, ( dp[1] &#x3D; 2 ). ( dp &#x3D; [0, 2, 3, 5, 2, 3] ). 物品 3 (( w_3&#x3D;3, v_3&#x3D;4 ))： ( j&#x3D;5 \\to 3 ): ( dp[5] &#x3D; \\max(3, dp[2]+4)&#x3D;7 ), …, ( dp[3] &#x3D; 5 ). ( dp &#x3D; [0, 2, 3, 5, 6, 7] ). 物品 4 (( w_4&#x3D;2, v_4&#x3D;2 ))： ( j&#x3D;5 \\to 2 ): ( dp[5] &#x3D; \\max(7, dp[3]+2)&#x3D;7 ), …, ( dp[2] &#x3D; 3 ). ( dp &#x3D; [0, 2, 3, 5, 6, 7] ). 结果：( dp[5] &#x3D; 7 ).输出： 10-1 Knapsack: 7 5.2 最长公共子序列输入： 12ABCDBECAD 字符串 ( A &#x3D; “ABCD” )，( B &#x3D; “BECAD” ).步骤： 记忆化递归： ( dp(4, 5) ): ( A[3]&#x3D;D ), ( B[4]&#x3D;D ), 相等，( dp(4, 5) &#x3D; dp(3, 4) + 1 ). ( dp(3, 4) ): ( A[2]&#x3D;C ), ( B[3]&#x3D;A ), 不等，( dp(3, 4) &#x3D; \\max(dp(2, 4), dp(3, 3)) ). ( dp(2, 4) ): ( A[1]&#x3D;B ), ( B[3]&#x3D;A ), 不等，( dp(2, 4) &#x3D; \\max(dp(1, 4), dp(2, 3)) ). 递归继续，计算所有状态。 最终：( dp(4, 5) &#x3D; 3 )（LCS 为 “BCD”）。 记忆化表格（部分）：12345 B E C A DA 0 0 0 0 0B 1 1 1 1 1C 1 1 2 2 2D 1 1 2 2 3 输出： 1LCS Length: 3 5.3 石子合并输入： 1241 3 5 2 ( n&#x3D;4 )，石子：( a &#x3D; [1, 3, 5, 2] ).步骤： 前缀和：( s &#x3D; [0, 1, 4, 9, 11] ). 初始化：( dp[i][i] &#x3D; 0 ). 长度 2： ( dp[0][1] &#x3D; s[2]-s[0] &#x3D; 4 ). ( dp[1][2] &#x3D; s[3]-s[1] &#x3D; 8 ). ( dp[2][3] &#x3D; s[4]-s[2] &#x3D; 7 ). 长度 3： ( dp[0][2] &#x3D; \\min(dp[0][0]+dp[1][2], dp[0][1]+dp[2][2]) + s[3]-s[0] &#x3D; \\min(0+8, 4+0)+9 &#x3D; 12 ). ( dp[1][3] &#x3D; \\min(dp[1][1]+dp[2][3], dp[1][2]+dp[3][3]) + s[4]-s[1] &#x3D; \\min(0+7, 8+0)+10 &#x3D; 17 ). 长度 4： ( dp[0][3] &#x3D; \\min(dp[0][k]+dp[k+1][3]+s[4]-s[0]) &#x3D; \\min(0+17, 4+7, 12+0)+11 &#x3D; 18 ). 结果：( dp[0][3] &#x3D; 18 ).输出： 1Stone Merge Cost: 18 6. DP 的优缺点6.1 优点 高效性：将指数复杂度降为多项式（如斐波那契从 ( O(2^n) ) 到 ( O(n) )）。 通用性：适用于优化、计数、概率等多种问题。 ACM 友好：Python 实现简洁，约 50-100 行，比赛中 10-20 分钟完成。 可优化：滚动数组、状态压缩显著降低空间复杂度。 调试方便：DP 表格直观，易于验证。 6.2 缺点 状态设计复杂：需要准确定义状态和转移，初学者易出错。 空间限制：多维 DP 可能占用大量内存。 ACM 限制： 大输入（( n \\geq 10^6 )）或时间 &lt; 1 秒，Python 可能 TLE。 复杂状态压缩或数位 DP 实现难度高。 依赖经验：状态转移方程推导需熟练，比赛中时间紧迫。 6.3 改进方向 滚动数组：优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态数。 迭代实现：将记忆化递归转为递推，降低递归开销。 快速 I&#x2F;O：优化 Python 输入输出。 Cython&#x2F;Numba：加速 Python 循环（非比赛场景）。 7. 与其他方法的对比7.1 与贪心算法 目标： 贪心：局部最优，快速决策。 DP：全局最优，考虑所有可能。 适用性： 贪心：活动选择、Huffman 编码。 DP：0-1 背包、LCS。 ACM 适用性： 贪心：简单问题，Python 实现快。 DP：复杂优化问题，Python 通用。 Python 实现： 贪心：代码短，逻辑简单。 DP：代码稍长，状态设计复杂。 7.2 与分治算法 目标： 分治：分解为独立子问题。 DP：分解为重叠子问题。 适用性： 分治：归并排序、快速排序。 DP：LIS、背包问题。 ACM 适用性： 分治：分治 + 递归，适合无重叠问题。 DP：优化重叠子问题，适合序列、图。 Python 实现： 分治：递归简洁，但可能重复计算。 DP：存储优化，效率更高。 7.3 与数据结构结合 DP + 线段树： 题目：动态区间优化。 解法：DP 定义状态，线段树维护区间最优值。 示例：Codeforces 474E（Pillars，LIS + 线段树）。 DP + 单调队列&#x2F;栈： 题目：序列优化。 解法：单调队列维护 DP 转移的最优候选。 示例：Luogu P1725（琪露诺，单调队列 DP）。 DP + 树： 题目：树上优化。 解法：树形 DP 递归转移。 示例：Luogu P1352（没有上司的舞会）。 8. 模拟运行过程（补充数位 DP）8.1 数位 DP问题：统计区间 ([L, R]) 内，数字各位之和为 ( K ) 的数的个数。代码： 12345678910111213141516171819202122232425262728293031import sysinput = sys.stdin.readlinedef digit_dp(L: int, R: int, K: int) -&gt; int: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位和为 K 的数的个数&quot;&quot;&quot; def count(num: str, K: int) -&gt; int: n = len(num) memo = &#123;&#125; def dp(pos: int, sum: int, tight: bool) -&gt; int: if pos == n: return 1 if sum == K else 0 if sum &gt; K: return 0 if (pos, sum, tight) in memo: return memo[(pos, sum, tight)] ans = 0 limit = int(num[pos]) if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit ans += dp(pos + 1, sum + d, new_tight) memo[(pos, sum, tight)] = ans return ans return dp(0, 0, True) return count(str(R), K) - count(str(L-1), K)# 测试L, R, K = map(int, input().split())print(&quot;Digit DP Count:&quot;, digit_dp(L, R, K)) 输入： 11 20 5 区间 ([1, 20])，各位和为 5.步骤： 计算 ( \\text{count}(20, 5) )： ( dp(0, 0, \\text{True}) ): 枚举第一位 ( d&#x3D;0 \\to 2 )： ( d&#x3D;1 ): ( dp(1, 1, \\text{True}) ). ( d&#x3D;2 ): ( dp(1, 2, \\text{True}) ). ( dp(1, 1, \\text{True}) ): 第二位 ( d&#x3D;0 \\to 0 )，( dp(2, 1+0, \\text{True}) &#x3D; 0 )（sum&#x3D;1 &lt; 5）。 ( dp(1, 2, \\text{True}) ): ( d&#x3D;0 )，( dp(2, 2+0, \\text{True}) &#x3D; 0 )（sum&#x3D;2 &lt; 5）。 结果：0（20 各位和 ≠ 5）。 计算 ( \\text{count}(0, 5) )：类似，0（无数字和 5）。 枚举 ([1, 20])：和为 5 的数为 5, 14。 结果：( 2 ).输出： 1Digit DP Count: 2 9. 总结动态规划是解决优化和计数问题的核心方法，通过状态设计和转移高效分解问题： 核心性质：最优子结构、重叠子问题、无后效性。 编程方法：递推（自底向上）、记忆化递归（自顶向下）、空间优化。 ACM 应用：线性 DP、背包、区间 DP、树形 DP、状态压缩、数位 DP。 Python 实现：约 50-100 行，调试方便，适合 ( n \\leq 10^5 )，时间 ≥ 1 秒。 优化：滚动数组、状态压缩、快速 I&#x2F;O。通过 Python 代码和样例模拟，展示了 DP 的常见类型和运行过程。在 ACM 竞赛中，DP 是不可或缺的工具，Python 实现适合快速原型和中小规模问题。学习建议： 手动模拟：用小数据（如 ( n&#x3D;4 )）画 DP 表格，推导转移。 ACM 练习：尝试 Luogu P1020、P1048、P1880，用 Python 实现 DP。 深入扩展：学习单调队列 DP、斜率优化、凸包优化。 比赛策略： 优先 Python 快速实现，验证正确性。 若 TLE，优化 I&#x2F;O 或切换 C++.如果你有其他问题、需要优化 Python 代码、或想探讨 ACM 题目（如复杂 DP 优化、数据结构结合），请随时告诉我！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2025-09-09T07:21:35.479Z","updated":"2025-09-09T07:21:35.479Z","comments":true,"path":"2025/09/09/hello-world/","permalink":"https://borrowyourhuaji.github.io/2025/09/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}