{"meta":{"title":"Hexo","subtitle":"","description":"","author":"borrowyourhuaji","url":"https://borrowyourhuaji.github.io","root":"/"},"pages":[],"posts":[{"title":"数位dp","slug":"数位dp","date":"2025-09-13T15:00:51.000Z","updated":"2025-09-13T15:01:40.205Z","comments":true,"path":"2025/09/13/数位dp/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/","excerpt":"","text":"数位统计 DP（Digit DP）详细解析 数位统计 DP（Digit Dynamic Programming，简称 Digit DP）是一种基于动态规划的算法技术，广泛应用于 ACM 竞赛、算法设计和计数问题中。它主要用于解决与数字的位数相关的计数问题，例如统计某个范围内满足特定条件的整数个数。数位 DP 特别适合处理大范围（如 ( 10^{18} )）的计数问题，通过逐位构造数字并结合动态规划避免暴力枚举。 1. 数位统计 DP 的基本概念 1.1 定义 数位 DP 是一种用于统计某个范围内整数个数（或满足特定条件的数字）的动态规划方法，通常问题形式如下： 给定一个范围 ([L, R])（例如 ( L, R \\leq 10^{18} )）。 要求统计 ([L, R]) 内满足特定条件的整数个数，例如： 数字的各位之和为某个值（如和为 ( K )）。 数字中不含某位（如不含 4）。 数字是某个数的倍数（如是 3 的倍数）。 数字的各位满足某种模式（如单调递增）。 目标： 计算满足条件的整数个数。 （可选）输出满足条件的数字。 输出： 满足条件的整数个数（可能需要模 ( 10^9+7 )）。 （可选）一个或多个满足条件的数字。 示例： 输入：( L = 1, R = 100 )，条件：数字的各位之和是 5。 满足条件的数字： 5（( 5 = 5 )） 14（( 1 + 4 = 5 )） 23（( 2 + 3 = 5 )） 32（( 3 + 2 = 5 )） 41（( 4 + 1 = 5 )） 50（( 5 + 0 = 5 )） 输出：6（满足条件的数字个数）。 答案计算：统计 ([1, 100]) 内各位之和为 5 的数字个数，通常用 ( f® - f(L-1) )，其中 ( f(x) ) 表示 ( [1, x] ) 内满足条件的数字个数。 关键特点： 逐位构造：从高位到低位逐位确定数字，动态维护状态。 范围处理：通过 ( f® - f(L-1) ) 计算 ([L, R]) 的答案。 状态压缩：用 DP 状态记录前缀信息（如当前数字、前缀和、模数等）。 记忆化：避免重复计算重叠子问题。 大范围适用：适合 ( R \\leq 10^{18} )，暴力枚举不可行。 1.2 数学模型 输入： 范围：( L, R )（整数，( 1 \\leq L \\leq R \\leq 10^{18} )）。 条件：数字的性质（例如，各位之和、模 ( K )、不含某位）。 目标： 计算 ([L, R]) 内满足条件的整数个数 ( C )。 通常通过 ( f® - f(L-1) )，其中 ( f(x) ) 是 ( [1, x] ) 内满足条件的个数。 输出： ( C )（整数，可能模 ( 10^9+7 )）。 （可选）满足条件的数字。 约束： 数字范围大（( 10^{18} )），需高效算法。 条件基于数字的位（十进制或二进制）。 1.3 与其他问题的对比 问题 定义 Goal DP 状态 Complexity 数位 DP 统计范围内满足位数条件的整数个数 满足条件的个数 ( dp[pos][state] ): 第 pos 位的状态 ( O(\\log R \\cdot S) ) 子集和 集合中找子集和为 T 判断是否存在子集 ( dp[i][s] ): 前 i 个元素和为 s ( O(n \\times T) ) 布尔括号 加括号使布尔表达式为 True 的方案数 True 方案数 ( dp[i][j][b] ): 子表达式 [i:j] 为 b ( O(n^3) ) 矩阵链乘法 确定矩阵乘法顺序，最小化乘法次数 最小乘法次数 ( dp[i][j] ): 子链 [i:j] 最小代价 ( O(n^3) ) 数位 DP vs 子集和： 数位 DP：基于数字位，计数问题。 子集和：基于集合，存在性问题。 数位 DP vs 布尔括号： 数位 DP：逐位构造，范围计数。 布尔括号：区间 DP，括号计数。 数位 DP vs 矩阵链乘法： 数位 DP：数字位优化，计数。 矩阵链乘法：乘法顺序优化，最小代价。 1.4 应用场景 ACM 竞赛： 计数问题：Codeforces 1036C（Classy Numbers）。 模运算：AtCoder ABC 162F（Digits）。 路径恢复：SPOJ NDIGITS（输出数字）。 变种：HDU 4352（XHXJ’s LIS，数位 DP + 状态压缩）。 实际应用： 密码学：统计满足条件的数字（如模 ( K )）。 数据库：范围查询优化。 数据分析：数字模式统计。 编码：数字编码方案计数。 2. 数位 DP 的解法 数位 DP 通过逐位构造数字并维护状态，结合动态规划解决计数问题。以下详细讲解主要解法：记忆化递归、动态规划、路径恢复。 2.1 记忆化递归（标准数位 DP） 思路： 将数字从高位到低位逐位构造，记录当前状态（如当前位、是否贴近上界、前缀和等）。 使用记忆化递归避免重复计算。 计算 ( f(x) )，即 ( [1, x] ) 内满足条件的数字个数。 答案为 ( f® - f(L-1) ). 状态定义： ( dp[pos][state] )：从第 ( pos ) 位开始构造，当前状态为 ( state )，满足条件的数字个数。 常见状态： ( pos ): 当前处理的位（从高到低）。 ( tight ): 是否贴近上界（1: 必须 ≤ 当前位的数字，0: 可取 0-9）。 ( sum ): 前缀数字之和（若条件是和为 ( K )）。 ( mod ): 前缀模 ( K )（若条件是 ( K ) 的倍数）。 ( lead ): 是否允许前导零（1: 允许，0: 不允许）。 状态转移： 对于第 ( pos ) 位： 若 ( tight = 1 )，可选数字 ( d \\in [0, \\text{digit[pos]}] ). 若 ( tight = 0 )，可选数字 ( d \\in [0, 9] ). 新状态： ( new_tight = 1 ) 若 ( d = \\text{digit[pos]} ) 且 ( tight = 1 )，否则 0。 更新 ( sum, mod, lead ) 等状态。 递归到下一位： [ dp[pos][state] = \\sum_{d} dp[pos+1][new_state] ] 终止条件： ( pos = \\text{len(digits)} )，检查是否满足条件（如 ( sum = K )）。 初始调用： ( solve(0, 1, 0, 1) )，表示从第 0 位开始，贴近上界，无前缀和，允许前导零。 复杂度： 时间：( O(\\log R \\cdot S) )，其中 ( S ) 是状态数（如 ( 10 \\cdot K )）。 空间：( O(\\log R \\cdot S) )，记忆化表格。 适用性：ACM 竞赛标配，适合 ( R \\leq 10^{18} )，时间 ≥ 1 秒。 2.2 动态规划 思路： 将记忆化递归转为递推形式，填充 DP 表格。 从低位到高位迭代，状态同记忆化。 实现： 较少使用，因数位 DP 通常递归更直观。 适用场景：状态简单，需显式 DP 表格。 复杂度： 同记忆化递归。 适用性：调试复杂问题或需显式表格。 2.3 路径恢复 目标： 输出一个或多个满足条件的数字。 方法： 在 DP 过程中记录每个状态的选择（选的数字 ( d )）。 从 ( dp[0][初始状态] ) 回溯，构造数字。 实现： 用数组 ( choice[pos][state] ) 记录 ( d ). 回溯构造数字字符串。 复杂度： 时间：( O(\\log R \\cdot S) )（DP）+ ( O(\\log R) )（回溯）。 空间：( O(\\log R \\cdot S) ). 适用性：ACM 题目要求输出数字。 2.4 变种与优化 模运算： 答案模 ( 10^9+7 ). 前导零： 控制是否允许前导零（常见于严格递增条件）。 状态压缩： 若条件复杂（如 LIS），用位掩码压缩状态。 多条件： 同时满足多个条件（如和为 ( K )，是 ( M ) 的倍数）。 空间优化： 滚动数组或清空记忆化表格，空间降到 ( O(S) ). 3. 复杂度分析 方法 时间复杂度 空间复杂度 适用场景 记忆化递归 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 标准问题，( R \\leq 10^{18} )，时间 ≥ 1s 动态规划 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 调试复杂状态，显式表格 路径恢复 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 需输出数字，( R \\leq 10^{18} ) 时间：( O(\\log R \\cdot S) )，( \\log R ) 是位数，( S ) 是状态数（例如 ( 10 \\cdot K )）。 空间：( O(\\log R \\cdot S) )，可优化到 ( O(S) ). ACM 限制： ( R \\leq 10^{18} )，位数 ( \\leq 18 )，时间 ≥ 1 秒，Python 适用。 复杂状态（( S \\geq 10^6 )）需 C++. 4. 在 ACM 竞赛中的应用 数位 DP 是 ACM 竞赛中的核心计数技术，常见于大范围计数、模运算和变种问题。以下是应用场景和解题思路： 标准数位 DP： 题目：Codeforces 1036C（Classy Numbers，非零位 ≤ 3）。 解法：记忆化递归。 方法： 状态：( dp[pos][tight][cnt] )，( cnt ) 为非零位数。 转移：枚举当前位 ( d )，更新 ( cnt ). 答案：( f® - f(L-1) ). 复杂度：时间 ( O(\\log R \\cdot 10 \\cdot 4) ). Python 优势：字符串和列表操作简洁。 路径恢复： 题目：SPOJ NDIGITS（输出满足条件的数字）。 解法：DP + 路径恢复。 方法： DP 计算满足条件的个数。 记录选择，回溯构造数字。 复杂度：时间 ( O(\\log R \\cdot S) ). Python 优势：字符串拼接和回溯直观。 变种问题： 模运算：HDU 3652（B-number，含 13 且被 13 整除）。 状态压缩：HDU 4352（XHXJ’s LIS，数位 DP + LIS）。 多条件：AtCoder ABC 162F（Digits，多个约束）。 示例：Codeforces 628D（Magic Numbers）。 方法：扩展状态（如模、模式匹配）。 Python 优势：条件判断和多维数组简洁。 ACM 优化技巧： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 模运算：防止溢出，模 ( 10^9+7 ). 状态压缩：用位掩码或整数压缩复杂状态。 调试：打印 DP 表格或构造的数字，验证转移。 边界处理：注意 ( L=1 )、前导零、紧界。 Python 在 ACM 中的适用性： 优点： 代码简洁：DP 约 40-60 行，路径恢复 60-80 行，比赛中 10-15 分钟实现。 调试方便：打印状态或数字，验证正确性。 适用：( \\log R \\leq 18 )，状态 ( S \\leq 10^5 )，时间 ≥ 1 秒。 缺点： 效率：Python 比 C++ 慢 5-10 倍，复杂状态可能 TLE。 内存：Python 数组占用较多，需优化。 优化： 快速 I/O：input = sys.stdin.readline. 滚动数组：空间降到 ( O(S) ). Cython/Numba：加速循环（非比赛场景）。 ACM 题目推荐： Codeforces 1036C：Classy Numbers（非零位 ≤ 3）。 HDU 3652：B-number（含 13 且被 13 整除）。 SPOJ NDIGITS：Number of Digits（路径恢复）。 AtCoder ABC 162F：Digits（多条件）。 Codeforces 628D：Magic Numbers（模运算）。 5. Python 实现 以下通过数位 DP 的两种典型问题（各位之和为 ( K )、路径恢复）提供 Python 实现，带详细注释，适合 ACM 竞赛。代码格式优化以确保在 OneNote 中清晰显示。 5.1 各位之和为 K（记忆化递归） 1234567891011121314151617181920212223242526272829303132333435import sysinput = sys.stdin.readlineMOD = 1000000007def digit_dp_sum_k(L: int, R: int, K: int) -&gt; int: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数&quot;&quot;&quot; def solve(digits: list, pos: int, tight: int, sum_digits: int, lead: int) -&gt; int: if pos == len(digits): return 1 if sum_digits == K and lead == 0 else 0 if sum_digits &gt; K: return 0 if dp[pos][tight][sum_digits][lead] != -1: return dp[pos][tight][sum_digits][lead] ans = 0 limit = digits[pos] if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit new_sum = sum_digits + d new_lead = lead and d == 0 ans = (ans + solve(digits, pos + 1, new_tight, new_sum, new_lead)) % MOD dp[pos][tight][sum_digits][lead] = ans return ans def count(x: int) -&gt; int: if x &lt; 0: return 0 digits = [int(d) for d in str(x)] global dp dp = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] return solve(digits, 0, 1, 0, 1) return (count(R) - count(L - 1)) % MOD# 测试L, R, K = map(int, input().split())print(&quot;Count of numbers with sum of digits =&quot;, K, &quot;:&quot;, digit_dp_sum_k(L, R, K)) 5.2 路径恢复（输出一个满足条件的数字） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import sysinput = sys.stdin.readlineMOD = 1000000007def digit_dp_path(L: int, R: int, K: int) -&gt; tuple: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数，并返回一个数字&quot;&quot;&quot; def solve(digits: list, pos: int, tight: int, sum_digits: int, lead: int) -&gt; int: if pos == len(digits): return 1 if sum_digits == K and lead == 0 else 0 if sum_digits &gt; K: return 0 if dp[pos][tight][sum_digits][lead] != -1: return dp[pos][tight][sum_digits][lead] ans = 0 limit = digits[pos] if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit new_sum = sum_digits + d new_lead = lead and d == 0 cnt = solve(digits, pos + 1, new_tight, new_sum, new_lead) if cnt &gt; 0 and choice[pos][tight][sum_digits][lead] == -1: choice[pos][tight][sum_digits][lead] = d ans = (ans + cnt) % MOD dp[pos][tight][sum_digits][lead] = ans return ans def count(x: int) -&gt; int: if x &lt; 0: return 0 digits = [int(d) for d in str(x)] global dp, choice dp = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] choice = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] return solve(digits, 0, 1, 0, 1) # 回溯构造数字 def construct(digits: list) -&gt; str: result = [] pos, tight, sum_digits, lead = 0, 1, 0, 1 while pos &lt; len(digits): d = choice[pos][tight][sum_digits][lead] if d == -1: return &quot;&quot; result.append(str(d)) tight = tight and d == digits[pos] sum_digits += d lead = lead and d == 0 pos += 1 return &quot;&quot;.join(result) if sum_digits == K and lead == 0 else &quot;&quot; # 计算答案 ans = (count(R) - count(L - 1)) % MOD digits = [int(d) for d in str(R)] number = construct(digits) return ans, number# 测试L, R, K = map(int, input().split())count, number = digit_dp_path(L, R, K)print(&quot;Count of numbers with sum of digits =&quot;, K, &quot;:&quot;, count)print(&quot;One such number:&quot;, number if number else &quot;None&quot;) 6. 运行过程 输入 11 100 5 ( L = 1, R = 100, K = 5 ) 条件：各位之和为 5。 6.1 记忆化递归 计算 ( f(100) )： 数字：( [1, 0, 0] )，3 位。 初始：( solve(0, 1, 0, 1) ). ( pos=0, tight=1, sum=0, lead=1 ): ( d=0 ): ( solve(1, 1, 0, 1) ). ( d=1 ): ( solve(1, 1, 1, 0) ). ( d=2 ): ( solve(1, 0, 2, 0) ). … ( pos=3 ): 检查 ( sum == 5 ). 结果：6（14, 23, 32, 41, 50, 5）。 计算 ( f(0) )： 结果：0（无数字）。 答案：( f(100) - f(0) = 6 - 0 = 6 ). Space：( O(\\log R \\cdot 10 \\cdot K) = O(3 \\cdot 2 \\cdot 6) ). Output: 1Count of numbers with sum of digits = 5 : 6 6.2 路径恢复 DP 和 choice 表格： 同记忆化，( f(100) = 6 ). ( choice[0][1][0][1] = 1 )（选 1）。 ( choice[1][1][1][0] = 4 )（选 4）。 回溯： ( pos=0, tight=1, sum=0, lead=1 ): ( d=1 ). ( pos=1, tight=1, sum=1, lead=0 ): ( d=4 ). ( pos=2 ): ( sum=5 )，结束。 结果：( 14 ). 答案：个数 6，数字 14（可能不同，如 23）。 Space：( O(\\log R \\cdot 10 \\cdot K) ). Output: 12Count of numbers with sum of digits = 5 : 6One such number: 14 7. 数位 DP 的优缺点 7.1 优点 高效计数：( O(\\log R \\cdot S) )，适合 ( R \\leq 10^{18} ). 灵活状态：支持多种条件（如和、模、模式）。 ACM 友好：Python 实现约 40-80 行，比赛中 10-15 分钟完成。 调试方便：打印状态或构造数字，验证正确性。 路径恢复：可输出满足条件的数字。 7.2 缺点 状态设计复杂：需根据条件设计状态（如模、LIS）。 空间需求：( O(\\log R \\cdot S) )，大状态数超内存。 ACM 限制： 复杂状态（( S \\geq 10^6 )）需 C++. 路径恢复增加实现难度。 边界处理： 注意 ( L=1 )、前导零、紧界。 7.3 改进方向 空间优化：滚动数组，空间降到 ( O(S) ). 状态压缩：用位掩码或整数压缩。 快速 I/O：Python 用 sys.stdin.readline. Cython/Numba：加速 Python 循环（非比赛场景）. 预处理：常见条件预计算（如模表）。 8. 与其他问题的对比 数位 DP vs 子集和： 数位 DP：逐位构造，范围计数。 子集和：组合优化，存在性. 数位 DP vs 布尔括号： 数位 DP：数字位计数。 布尔括号：区间 DP，逻辑计数. 数位 DP vs 矩阵链乘法： 数位 DP：计数问题。 矩阵链乘法：优化代价. ACM 适用性： 数位 DP：大范围计数。 子集和：背包 DP。 布尔括号：区间 DP。 矩阵链乘法：区间 DP。 9. 总结 数位 DP 是解决大范围数字计数问题的强大工具，通过逐位构造和动态规划高效统计： 核心方法： 记忆化递归：时间 ( O(\\log R \\cdot S) )，ACM 标配。 路径恢复：输出满足条件的数字。 ACM 应用： 标准计数（Codeforces 1036C）。 路径恢复（SPOJ NDIGITS）。 变种（HDU 4352）。 Python 实现：约 40-80 行，比赛中 10-15 分钟，适合 ( \\log R \\leq 18 )，时间 ≥ 1 秒。 优化：模运算、快速 I/O、状态压缩。 通过记忆化递归和路径恢复的 Python 代码及模拟，展示了数位 DP 的实现和运行过程。在 ACM 竞赛中，数位 DP 是处理大范围计数的核心技术，Python 实现简洁高效。 学习建议： 手动模拟： 用小数据（如 ( R=20, K=5 )）手动构造数字，验证状态转移。 ACM 练习： Codeforces 1036C、HDU 3652、SPOJ NDIGITS，用 Python 实现。 深入扩展： 学习状态压缩（HDU 4352）、多条件、模运算。 比赛策略： 优先实现记忆化递归，验证正确性。 若需数字，添加路径恢复。 若时间严格，考虑 C++.","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"yolo","slug":"yolo","date":"2025-09-13T13:57:08.000Z","updated":"2025-09-13T14:01:34.318Z","comments":true,"path":"2025/09/13/yolo/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/yolo/","excerpt":"","text":"使用 Ultralytics YOLO 进行模型预测 简介 在机器学习和计算机视觉领域，对视觉数据进行理解处理的过程称为“推理”（‘inference’）或“预测”（‘prediction’）。Ultralytics YOLO11 提供了一项强大的功能，即预测模式，专为对各种数据源进行高性能、实时推理而量身定制。 实际应用 制造业 体育 安全 汽车备件检测 足球运动员检测 人员跌倒检测 为什么选择 Ultralytics YOLO 进行推理？ 以下是你应该考虑将 YOLO11 的预测模式用于各种推理需求的原因： 多功能性：能够对图像、视频甚至直播流进行推理。 性能：专为实时、高速处理而设计，同时不牺牲准确性。 易用性：直观的 Python 和 CLI 界面，可实现快速部署和测试。 高度可定制：提供各种设置和参数，以根据你的特定要求调整模型的推理行为。 预测模式的关键功能 YOLO11 的预测模式设计得既稳健又通用，具备以下特点： 多数据源兼容性：无论你的数据是单个图像、一系列图像、视频文件还是实时视频流，预测模式都能处理。 流式处理模式：使用流式处理功能可以生成一个内存高效的 Results 对象生成器。通过在预测器的调用方法中设置 stream=True 来启用此功能。 批量处理：能够一次性处理多张图像或视频帧，进一步加快推理时间。 易于集成：由于其灵活的 API，可以轻松集成到现有的数据管道和其他软件组件中。 Ultralytics YOLO 模型在推理时，如果传递了 stream=True，则返回一个内存高效的 Results 对象生成器；否则，返回一个 Results 对象列表。 !!! example “预测” 12345678910111213141516171819202122232425262728293031323334353637383940414243=== &quot;使用 `stream=False` 返回列表&quot; ```python from ultralytics import YOLO # 加载模型 model = YOLO(&quot;yolo11n.pt&quot;) # 预训练的 YOLO11n 模型 # 对图像列表进行批量推理 results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;]) # 返回一个 Results 对象列表 # 处理结果列表 for result in results: boxes = result.boxes # 用于边界框输出的 Boxes 对象 masks = result.masks # 用于分割掩码输出的 Masks 对象 keypoints = result.keypoints # 用于姿态输出的 Keypoints 对象 probs = result.probs # 用于分类输出的 Probs 对象 obb = result.obb # 用于 OBB 输出的定向框对象 result.show() # 显示到屏幕 result.save(filename=&quot;result.jpg&quot;) # 保存到磁盘 ```=== &quot;使用 `stream=True` 返回生成器&quot; ```python from ultralytics import YOLO # 加载模型 model = YOLO(&quot;yolo11n.pt&quot;) # 预训练的 YOLO11n 模型 # 对图像列表进行批量推理 results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;], stream=True) # 返回一个 Results 对象生成器 # 处理结果生成器 for result in results: boxes = result.boxes # 用于边界框输出的 Boxes 对象 masks = result.masks # 用于分割掩码输出的 Masks 对象 keypoints = result.keypoints # 用于姿态输出的 Keypoints 对象 probs = result.probs # 用于分类输出的 Probs 对象 obb = result.obb # 用于 OBB 输出的定向框对象 result.show() # 显示到屏幕 result.save(filename=&quot;result.jpg&quot;) # 保存到磁盘 ``` 推理源 YOLO11 可以处理不同类型的输入源进行推理，如下表所示。来源包括静态图像、视频流和各种数据格式。该表还指出每个源是否可以使用参数 stream=True 在流式处理模式下使用 ✅。流式处理模式对于处理视频或直播流很有用，因为它会创建一个结果生成器，而不是将所有帧都加载到内存中。 !!! tip 1使用 `stream=True` 来处理长视频或大型数据集，以高效地管理内存。当 `stream=False` 时，所有帧或数据点的结果都存储在内存中，这可能很快累积并导致大型输入出现内存不足错误。相比之下，`stream=True` 使用生成器，它只将当前帧或数据点的结果保存在内存中，从而显著减少内存消耗并防止内存不足问题。 源 示例 类型 备注 图像 'image.jpg' str 或 Path 单个图像文件。 URL 'https://ultralytics.com/images/bus.jpg' str 图像的 URL。 截图 'screen' str 捕获屏幕截图。 PIL Image.open('image.jpg') PIL.Image HWC 格式，带有 RGB 通道。 OpenCV cv2.imread('image.jpg') np.ndarray HWC 格式，带有 BGR 通道 uint8 (0-255)。 numpy np.zeros((640,1280,3)) np.ndarray HWC 格式，带有 BGR 通道 uint8 (0-255)。 torch torch.zeros(16,3,320,640) torch.Tensor BCHW 格式，带有 RGB 通道 float32 (0.0-1.0)。 CSV 'sources.csv' str 或 Path 包含图像、视频或目录路径的 CSV 文件。 视频 ✅ 'video.mp4' str 或 Path 格式为 MP4、AVI 等的视频文件。 目录 ✅ 'path/' str 或 Path 包含图像或视频的目录路径。 glob ✅ 'path/*.jpg' str 用于匹配多个文件的 glob 模式。使用 * 字符作为通配符。 YouTube ✅ 'https://youtu.be/LNwODJXcvt4' str YouTube 视频的 URL。 流 ✅ 'rtsp://example.com/media.mp4' str 用于 RTSP、RTMP、TCP 等流媒体协议或 IP 地址的 URL。 多流 ✅ 'list.streams' str 或 Path .streams 文本文件，每行一个流 URL，即 8 个流将以批量大小 8 运行。 摄像头 ✅ 0 int 连接的摄像头设备的索引，用于运行推理。 以下是使用每种源类型的代码示例： !!! example “预测源” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264=== &quot;图像&quot; 对图像文件运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义图像文件路径 source = &quot;path/to/image.jpg&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;截图&quot; 将当前屏幕内容作为截图运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义当前截图为源 source = &quot;screen&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;URL&quot; 对通过 URL 远程托管的图像或视频运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义远程图像或视频 URL source = &quot;https://ultralytics.com/images/bus.jpg&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;PIL&quot; 对使用 Python Imaging Library (PIL) 打开的图像运行推理。 ```python from PIL import Image from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 使用 PIL 打开图像 source = Image.open(&quot;path/to/image.jpg&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;OpenCV&quot; 对使用 OpenCV 读取的图像运行推理。 ```python import cv2 from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 使用 OpenCV 读取图像 source = cv2.imread(&quot;path/to/image.jpg&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;numpy&quot; 对表示为 numpy 数组的图像运行推理。 ```python import numpy as np from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 创建一个 HWC 形状 (640, 640, 3)，值范围 [0, 255]，类型为 uint8 的随机 numpy 数组 source = np.random.randint(low=0, high=255, size=(640, 640, 3), dtype=&quot;uint8&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;torch&quot; 对表示为 **PyTorch** 张量的图像运行推理。 ```python import torch from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 创建一个 BCHW 形状 (1, 3, 640, 640)，值范围 [0, 1]，类型为 float32 的随机 torch 张量 source = torch.rand(1, 3, 640, 640, dtype=torch.float32) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;CSV&quot; 对 CSV 文件中列出的图像、URL、视频和目录集合运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义一个包含图像、URL、视频和目录的 CSV 文件的路径 source = &quot;path/to/file.csv&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;视频&quot; 对视频文件运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少内存使用。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义视频文件路径 source = &quot;path/to/video.mp4&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;目录&quot; 对目录中的所有图像和视频运行推理。若要同时捕获子目录中的图像和视频，请使用 glob 模式，例如 `path/to/dir/**/*`。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义包含用于推理的图像和视频的目录路径 source = &quot;path/to/dir&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;glob&quot; 对所有与带有 `*` 字符的 glob 表达式匹配的图像和视频运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义一个 glob 搜索，以查找目录中的所有 JPG 文件 source = &quot;path/to/dir/*.jpg&quot; # 或者定义一个递归 glob 搜索，以查找包括子目录在内的所有 JPG 文件 source = &quot;path/to/dir/**/*.jpg&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;YouTube&quot; 对 YouTube 视频运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少长视频的内存使用。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义源为 YouTube 视频 URL source = &quot;https://youtu.be/LNwODJXcvt4&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;流&quot; 使用流模式通过 RTSP、RTMP、TCP 或 IP 地址协议对直播流进行推理。如果提供单个流，模型将以**批量大小**为 1 运行推理。对于多个流，可以使用 `.streams` 文本文件执行批量推理，其中批量大小由提供的流数量决定（例如，8 个流的批量大小为 8）。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 批量大小为 1 的单个流推理 source = &quot;rtsp://example.com/media.mp4&quot; # RTSP、RTMP、TCP 或 IP 流地址 # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ``` 对于单个流使用，批量大小默认为 1，从而实现对视频流的高效实时处理。=== &quot;多流&quot; 要同时处理多个视频流，请使用包含流源的 `.streams` 文本文件。模型将运行批量推理，其中批量大小等于流的数量。此设置可实现对多个视频流的并发高效处理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 多个流进行批量推理（例如，8 个流的批量大小为 8） source = &quot;path/to/list.streams&quot; # *.streams 文本文件，每行一个流地址 # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ``` `.streams` 文本文件示例： ```text rtsp://example.com/media1.mp4 rtsp://example.com/media2.mp4 rtmp://example2.com/live tcp://192.168.1.100:554 ... ``` 文件中的每一行都代表一个流源，让你能够同时监控和对多个视频流进行推理。=== &quot;摄像头&quot; 你可以通过传递特定摄像头的索引来对连接的摄像头设备运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 对源运行推理 results = model(source=0, stream=True) # Results 对象生成器 ``` 推理参数 model.predict() 接受多个参数，这些参数可以在推理时传递以覆盖默认值： !!! example 123456789```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对 &#x27;bus.jpg&#x27; 运行推理，并带有参数model.predict(&quot;https://ultralytics.com/images/bus.jpg&quot;, save=True, imgsz=320, conf=0.5)``` 推理参数： 参数 类型 默认值 描述 source str, int, Path 'ultralytics.com/images/bus.jpg' 输入源的路径。可以是文件、目录、URL、视频或 RTMP 流。 model str 'yolov11n.pt' 要运行推理的模型文件的路径。 conf float 0.25 对象置信度阈值。 iou float 0.7 边界框交并比 (IoU) 阈值，用于非最大抑制 (NMS)。 imgsz int 或 tuple 640 输入图像的大小，可以是单个整数（正方形）或 (高度, 宽度) 元组。 half bool False 如果 GPU 可用，则使用 FP16 半精度推理。 device int 或 str None 要使用的设备（例如 cuda:0 或 0,1,2,3 或 cpu）。 show bool False 是否在屏幕上显示结果。 save bool False 是否将预测结果保存到文件中。 save_txt bool False 是否将预测结果以 .txt 格式保存。 save_conf bool False 是否在保存的标签中包含置信度分数。 save_crop bool False 是否保存裁剪后的预测结果。 hide_labels bool False 是否隐藏预测标签。 hide_conf bool False 是否隐藏预测置信度分数。 max_det int 300 每张图像的最大检测数量。 vid_stride int 1 视频帧步长。 stream_buffer bool False 是否缓冲流帧。 line_thickness int 2 边界框的线条粗细（以像素为单位）。 visualize bool False 在模型推理期间可视化模型特征。 augment bool False 在推理时应用图像增强（测试时增强）。 agnostic_nms bool False 执行类别无关的非最大抑制（NMS）。 retina_masks bool False 使用高分辨率分割掩码。 boxes bool True 是否在结果中显示边界框。 可视化参数： 参数 类型 描述 默认值 conf bool 包含检测置信度分数。 True line_width float 边界框的线条宽度。如果为 None，则随图像大小缩放。 None font_size float 文本字体大小。如果为 None，则随图像大小缩放。 None font str 文本注释的字体名称。 'Arial.ttf' pil bool 将图像作为 PIL Image 对象返回。 False img np.ndarray 用于绘图的替代图像。如果为 None，则使用原始图像。 None im_gpu torch.Tensor 用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。 None kpt_radius int 绘制的关键点的半径。 5 kpt_line bool 用线条连接关键点。 True labels bool 在注释中包含类别标签。 True boxes bool 在图像上叠加边界框。 True masks bool 在图像上叠加掩码。 True probs bool 包含分类概率。 True show bool 使用默认图像查看器直接显示带注释的图像。 False save bool 将带注释的图像保存到由 filename 指定的文件。 False filename str 如果 save 为 True，则为保存带注释的图像的文件路径和名称。 None color_mode str 指定颜色模式，例如 ‘instance’ 或 ‘class’。 'class' txt_color tuple[int, int, int] 边界框和图像分类标签的 RGB 文本颜色。 (255, 255, 255) 图像和视频格式 YOLO11 支持多种图像和视频格式，具体请参见 ultralytics/data/utils.py。下表列出了有效的后缀和预测命令示例。 图像 下表包含有效的 Ultralytics 图像格式。 !!! note 1HEIC 图像仅支持推理，不支持训练。 图像后缀 预测命令示例 参考 .bmp yolo predict source=image.bmp Microsoft BMP 文件格式 .dng yolo predict source=image.dng Adobe DNG .jpeg yolo predict source=image.jpeg JPEG .jpg yolo predict source=image.jpg JPEG .mpo yolo predict source=image.mpo 多图片对象 .png yolo predict source=image.png 便携式网络图形 .tif yolo predict source=image.tif 标签图像文件格式 .tiff yolo predict source=image.tiff 标签图像文件格式 .webp yolo predict source=image.webp WebP .pfm yolo predict source=image.pfm 便携式浮点地图 .HEIC yolo predict source=image.HEIC 高效图像文件格式 视频 下表包含有效的 Ultralytics 视频格式。 视频后缀 预测命令示例 参考 .asf yolo predict source=video.asf 高级系统格式 .avi yolo predict source=video.avi 音频视频交错 .gif yolo predict source=video.gif 图形交换格式 .m4v yolo predict source=video.m4v MPEG-4 Part 14 .mkv yolo predict source=video.mkv Matroska .mov yolo predict source=video.mov QuickTime 文件格式 .mp4 yolo predict source=video.mp4 MPEG-4 Part 14 - Wikipedia .mpeg yolo predict source=video.mpeg MPEG-1 Part 2 .mpg yolo predict source=video.mpg MPEG-1 Part 2 .ts yolo predict source=video.ts MPEG 传输流 .wmv yolo predict source=video.wmv Windows Media Video .webm yolo predict source=video.webm WebM 项目 处理结果 所有 Ultralytics 的 predict() 调用都将返回一个 Results 对象列表： !!! example “结果” 123456789101112131415```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)results = model( [ &quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;, ]) # 批量推理``` Results 对象具有以下属性： 属性 类型 描述 orig_img np.ndarray 作为 numpy 数组的原始图像。 orig_shape tuple 原始图像形状，格式为 (高度, 宽度)。 boxes Boxes, optional 包含检测边界框的 Boxes 对象。 masks Masks, optional 包含检测掩码的 Masks 对象。 probs Probs, optional 包含用于分类任务的每个类别的概率的 Probs 对象。 keypoints Keypoints, optional 包含每个对象检测到的关键点的 Keypoints 对象。 obb OBB, optional 包含定向边界框的 OBB 对象。 speed dict 字典，包含每个图像的预处理、推理和后处理速度（以毫秒为单位）。 names dict 将类别索引映射到类别名称的字典。 path str 图像文件路径。 save_dir str, optional 保存结果的目录。 Results 对象具有以下方法： 方法 返回类型 描述 update() None 使用新的检测数据（框、掩码、概率、OBB、关键点）更新 Results 对象。 cpu() Results 返回 Results 对象的副本，所有张量都已移动到 CPU 内存。 numpy() Results 返回 Results 对象的副本，所有张量都已转换为 numpy 数组。 cuda() Results 返回 Results 对象的副本，所有张量都已移动到 GPU 内存。 to() Results 返回 Results 对象的副本，其中张量已移动到指定的设备和数据类型。 new() Results 创建一个具有相同图像、路径、名称和速度属性的新 Results 对象。 plot() np.ndarray 在输入的 RGB 图像上绘制检测结果并返回带注释的图像。 show() None 显示带有注释的推理结果图像。 save() str 将带有注释的推理结果图像保存到文件并返回文件名。 verbose() str 返回每个任务的日志字符串，详细说明检测和分类结果。 save_txt() str 将检测结果保存到文本文件并返回保存文件的路径。 save_crop() None 将裁剪后的检测图像保存到指定的目录。 summary() List[Dict[str, Any]] 将推理结果转换为摘要字典，并可选择进行归一化。 to_df() DataFrame 将检测结果转换为 Polars DataFrame。 to_csv() str 将检测结果转换为 CSV 格式。 to_json() str 将检测结果转换为 JSON 格式。 有关更多详细信息，请参阅 Results 类文档。 Boxes Boxes 对象可用于索引、操作和将边界框转换为不同格式。 !!! example “Boxes” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.boxes) # 打印包含检测边界框的 Boxes 对象``` 下表列出了 Boxes 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 将对象移动到 CPU 内存。 numpy() 方法 将对象转换为 numpy 数组。 cuda() 方法 将对象移动到 CUDA 内存。 to() 方法 将对象移动到指定的设备。 xyxy 属性 (torch.Tensor) 以 xyxy 格式返回框。 conf 属性 (torch.Tensor) 返回框的置信度值。 cls 属性 (torch.Tensor) 返回框的类别值。 id 属性 (torch.Tensor) 返回框的跟踪 ID（如果可用）。 xywh 属性 (torch.Tensor) 以 xywh 格式返回框。 xyxyn 属性 (torch.Tensor) 以 xyxy 格式返回归一化后的框（通过原始图像大小）。 xywhn 属性 (torch.Tensor) 以 xywh 格式返回归一化后的框（通过原始图像大小）。 有关更多详细信息，请参阅 Boxes 类文档。 Masks Masks 对象可用于索引、操作和将掩码转换为段。 !!! example “Masks” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-seg 分割模型model = YOLO(&quot;yolo11n-seg.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.masks) # 打印包含检测到的实例掩码的 Masks 对象``` 下表列出了 Masks 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回掩码张量。 numpy() 方法 将掩码张量作为 numpy 数组返回。 cuda() 方法 在 GPU 内存上返回掩码张量。 to() 方法 返回具有指定设备和数据类型的掩码张量。 xyn 属性 (torch.Tensor) 表示为张量的归一化段列表。 xy 属性 (torch.Tensor) 表示为张量的像素坐标中的段列表。 有关更多详细信息，请参阅 Masks 类文档。 Keypoints Keypoints 对象可用于索引、操作和归一化坐标。 !!! example “Keypoints” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-pose 姿态模型model = YOLO(&quot;yolo11n-pose.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.keypoints) # 打印包含检测到的关键点的 Keypoints 对象``` 下表列出了 Keypoints 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回关键点张量。 numpy() 方法 将关键点张量作为 numpy 数组返回。 cuda() 方法 在 GPU 内存上返回关键点张量。 to() 方法 返回具有指定设备和数据类型的关键点张量。 xyn 属性 (torch.Tensor) 表示为张量的归一化关键点列表。 xy 属性 (torch.Tensor) 表示为张量的像素坐标中的关键点列表。 conf 属性 (torch.Tensor) 如果可用，返回关键点的置信度值，否则为 None。 有关更多详细信息，请参阅 Keypoints 类文档。 Probs Probs 对象可用于索引，获取分类的 top1 和 top5 索引和分数。 !!! example “Probs” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-cls 分类模型model = YOLO(&quot;yolo11n-cls.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.probs) # 打印包含检测到的类别概率的 Probs 对象``` 下表总结了 Probs 类的方法和属性： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回概率张量的副本。 numpy() 方法 将概率张量作为 numpy 数组返回副本。 cuda() 方法 在 GPU 内存上返回概率张量的副本。 to() 方法 返回具有指定设备和数据类型的概率张量的副本。 top1 属性 (int) top 1 类别的索引。 top5 属性 (list[int]) top 5 类别的索引。 top1conf 属性 (torch.Tensor) top 1 类别的置信度。 top5conf 属性 (torch.Tensor) top 5 类别的置信度。 有关更多详细信息，请参阅 Probs 类文档。 OBB OBB 对象可用于索引、操作和将定向边界框转换为不同格式。 !!! example “OBB” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n-obb.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/boats.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.obb) # 打印包含定向检测边界框的 OBB 对象``` 下表列出了 OBB 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 将对象移动到 CPU 内存。 numpy() 方法 将对象转换为 numpy 数组。 cuda() 方法 将对象移动到 CUDA 内存。 to() 方法 将对象移动到指定的设备。 conf 属性 (torch.Tensor) 返回框的置信度值。 cls 属性 (torch.Tensor) 返回框的类别值。 id 属性 (torch.Tensor) 返回框的跟踪 ID（如果可用）。 xyxy 属性 (torch.Tensor) 以 xyxy 格式返回水平框。 xywhr 属性 (torch.Tensor) 以 xywhr 格式返回旋转框。 xyxyxyxy 属性 (torch.Tensor) 以 xyxyxyxy 格式返回旋转框。 xyxyxyxyn 属性 (torch.Tensor) 以 xyxyxyxy 格式返回归一化后的旋转框（通过图像大小）。 有关更多详细信息，请参阅 OBB 类文档。 绘制结果 Results 对象中的 plot() 方法通过在原始图像上叠加检测到的对象（如边界框、掩码、关键点和概率）来方便可视化预测。此方法将带注释的图像作为 NumPy 数组返回，便于显示或保存。 !!! example “绘图” 1234567891011121314151617181920212223```pythonfrom PIL import Imagefrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对 &#x27;bus.jpg&#x27; 运行推理results = model([&quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;]) # 结果列表# 可视化结果for i, r in enumerate(results): # 绘制结果图像 im_bgr = r.plot() # BGR 顺序的 numpy 数组 im_rgb = Image.fromarray(im_bgr[..., ::-1]) # RGB 顺序的 PIL 图像 # 将结果显示到屏幕（在支持的环境中） r.show() # 将结果保存到磁盘 r.save(filename=f&quot;results&#123;i&#125;.jpg&quot;)``` plot() 方法参数 plot() 方法支持各种参数来自定义输出： 参数 类型 描述 默认值 conf bool 包含检测置信度分数。 True line_width float 边界框的线条宽度。如果为 None，则随图像大小缩放。 None font_size float 文本字体大小。如果为 None，则随图像大小缩放。 None font str 文本注释的字体名称。 'Arial.ttf' pil bool 将图像作为 PIL Image 对象返回。 False img np.ndarray 用于绘图的替代图像。如果为 None，则使用原始图像。 None im_gpu torch.Tensor 用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。 None kpt_radius int 绘制的关键点的半径。 5 kpt_line bool 用线条连接关键点。 True labels bool 在注释中包含类别标签。 True boxes bool 在图像上叠加边界框。 True masks bool 在图像上叠加掩码。 True probs bool 包含分类概率。 True show bool 使用默认图像查看器直接显示带注释的图像。 False save bool 将带注释的图像保存到由 filename 指定的文件。 False filename str 如果 save 为 True，则为保存带注释的图像的文件路径和名称。 None color_mode str 指定颜色模式，例如 ‘instance’ 或 ‘class’。 'class' txt_color tuple[int, int, int] 边界框和图像分类标签的 RGB 文本颜色。 (255, 255, 255) 线程安全推理 当你在不同线程中并行运行多个 YOLO 模型时，确保推理的线程安全至关重要。线程安全推理可确保每个线程的预测是隔离的，并且不会相互干扰，从而避免竞态条件并确保一致且可靠的输出。 在多线程应用程序中使用 YOLO 模型时，为每个线程实例化单独的模型对象或采用线程本地存储以防止冲突非常重要： !!! example “线程安全推理” 123456789101112131415161718在每个线程内实例化一个模型，以实现线程安全推理：```pythonfrom threading import Threadfrom ultralytics import YOLOdef thread_safe_predict(model, image_path): &quot;&quot;&quot;使用本地实例化的 YOLO 模型对图像执行线程安全预测。&quot;&quot;&quot; model = YOLO(model) results = model.predict(image_path) # 处理结果# 启动每个线程都有自己模型实例的线程Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image1.jpg&quot;)).start()Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image2.jpg&quot;)).start()``` 要深入了解 YOLO 模型的线程安全推理和分步说明，请参阅我们的 YOLO 线程安全推理指南。本指南将为你提供所有必要的信息，以避免常见陷阱并确保你的多线程推理顺利运行。 流式处理源 for 循环 这是一个使用 OpenCV (cv2) 和 YOLO 对视频帧运行推理的 Python 脚本。该脚本假设你已安装所需的包（opencv-python 和 ultralytics）。 !!! example “流式处理 for 循环” 1234567891011121314151617181920212223242526272829303132333435363738```pythonimport cv2from ultralytics import YOLO# 加载 YOLO 模型model = YOLO(&quot;yolo11n.pt&quot;)# 打开视频文件video_path = &quot;path/to/your/video/file.mp4&quot;cap = cv2.VideoCapture(video_path)# 循环遍历视频帧while cap.isOpened(): # 从视频中读取一帧 success, frame = cap.read() if success: # 在帧上运行 YOLO 推理 results = model(frame) # 在帧上可视化结果 annotated_frame = results[0].plot() # 显示带注释的帧 cv2.imshow(&quot;YOLO Inference&quot;, annotated_frame) # 如果按下 &#x27;q&#x27; 键，则中断循环 if cv2.waitKey(1) &amp; 0xFF == ord(&quot;q&quot;): break else: # 如果到达视频末尾，则中断循环 break# 释放视频捕获对象并关闭显示窗口cap.release()cv2.destroyAllWindows()``` 该脚本将在视频的每一帧上运行预测，可视化结果，并在窗口中显示它们。可以通过按 ‘q’ 键退出循环。 常见问题 (FAQ) 什么是 Ultralytics YOLO 及其用于实时推理的预测模式？ Ultralytics YOLO 是一种用于实时目标检测、分割和分类的最新模型。其预测模式允许用户对各种数据源（如图像、视频和直播流）执行高速推理。它专为性能和多功能性而设计，还提供批量处理和流式处理模式。有关其功能的更多详细信息，请查看 Ultralytics YOLO 预测模式。 如何使用 Ultralytics YOLO 对不同的数据源运行推理？ Ultralytics YOLO 可以处理各种数据源，包括单个图像、视频、目录、URL 和流。你可以在 model.predict() 调用中指定数据源。例如，对于本地图像，使用 'image.jpg'；对于 URL，使用 'https://ultralytics.com/images/bus.jpg'。请查看文档中关于各种推理源的详细示例。 如何优化 YOLO 推理速度和内存使用？ 要优化推理速度并高效管理内存，你可以通过在预测器的调用方法中设置 stream=True 来使用流式处理模式。流式处理模式会生成一个内存高效的 Results 对象生成器，而不是将所有帧加载到内存中。对于处理长视频或大型数据集，流式处理模式特别有用。了解有关流式处理模式的更多信息。 Ultralytics YOLO 支持哪些推理参数？ YOLO 中的 model.predict() 方法支持各种参数，例如 conf、iou、imgsz、device 等。这些参数允许你自定义推理过程，设置置信度阈值、图像大小和用于计算的设备等参数。这些参数的详细说明可以在推理参数部分找到。 如何可视化和保存 YOLO 预测结果？ 使用 YOLO 运行推理后，Results 对象包含用于显示和保存带注释图像的方法。你可以使用 result.show() 和 result.save(filename=&quot;result.jpg&quot;) 等方法来可视化和保存结果。有关这些方法的完整列表，请参阅处理结果部分。 []: # []: # []: #","categories":[],"tags":[{"name":"文档、库","slug":"文档、库","permalink":"https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"}]},{"title":"线段树","slug":"线段树","date":"2025-09-13T12:57:08.000Z","updated":"2025-09-13T13:37:52.139Z","comments":true,"path":"2025/09/13/线段树/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"1. 什么是线段树？ 线段树是一种二叉树数据结构，用于存储区间（或称为“线段”）的信息，并支持快速的查询和更新操作。它特别适合解决与区间相关的动态问题，例如： 求某个区间的和。 查找某个区间的最大值或最小值。 对某个区间进行批量更新。 线段树的核心思想是将一个大区间递归地划分成多个小子区间，并通过树形结构高效地维护和查询这些区间的聚合信息。 2. 线段树的结构 线段树的结构可以用以下方式描述： 节点：每个节点代表一个区间。 根节点：代表整个区间（例如数组的范围[1, n]）。 叶子节点：代表单个元素（例如数组中的某个值）。 中间节点：代表某个子区间（介于根节点和叶子节点之间）。 例如，对于一个数组[1, 3, 5, 7, 9, 11]，线段树的结构如下： 根节点表示区间[1, 6]。 根的左子节点表示[1, 3]，右子节点表示[4, 6]。 进一步划分后，叶子节点分别表示[1, 1]、[2, 2]、[3, 3]、[4, 4]、[5, 5]和[6, 6]。 这种递归划分的方式使得线段树能够高效地处理区间问题。 3. 线段树的基本操作 线段树主要支持以下两种核心操作： 查询（Query） 查询操作用于获取某个区间的聚合信息，例如： 区间的和。 区间的最大值或最小值。 更新（Update） 更新操作用于修改数据，例如： 修改单个元素的值（单点更新）。 对某个区间的元素进行批量修改（区间更新）。 这两种操作的时间复杂度均为O(log n)，其中n是数组的大小。这是对数级别的高效性使得线段树非常适合动态查询问题。 4. 线段树的构建 线段树的构建是一个递归过程，通常自底向上完成。以下是构建线段树的基本步骤： 从根节点开始：根节点表示整个区间，例如[1, n]。 划分区间：将当前区间划分为两个子区间，例如[1, mid]和[mid+1, n]，其中mid = (left + right) / 2。 递归构建子树：对左子区间和右子区间分别递归构建子树，直到达到叶子节点。 合并信息：在回溯时，根据具体问题将子节点的信息合并到当前节点。例如，对于区间求和问题，当前节点的值是左子节点和右子节点值的和。 示例： 对于数组[1, 3, 5, 7, 9, 11]： 根节点存储[1, 6]的和：1 + 3 + 5 + 7 + 9 + 11 = 36。 左子节点存储[1, 3]的和：1 + 3 + 5 = 9。 右子节点存储[4, 6]的和：7 + 9 + 11 = 27。 递归继续，直到叶子节点存储单个元素。 5. 线段树的查询 查询操作同样是递归进行的，用于在O(log n)时间内获取某个区间的聚合信息。查询步骤如下： 判断当前区间与查询区间的关系： 完全包含：如果当前区间完全在查询区间内，直接返回当前节点的值。 无交集：如果当前区间与查询区间无重叠，返回一个不影响结果的值（例如求和时返回0，求最大值时返回负无穷）。 部分重叠：递归查询左子树和右子树，并合并结果。 合并结果：根据具体问题合并子查询的结果。例如，求和时将左右子树的结果相加。 示例： 查询数组[1, 3, 5, 7, 9, 11]中区间[2, 5]的和： 根节点[1, 6]与[2, 5]部分重叠，递归查询子节点。 左子节点[1, 3]与[2, 5]部分重叠，继续递归，最终得到[2, 3]的和3 + 5 = 8。 右子节点[4, 6]与[2, 5]部分重叠，最终得到[4, 5]的和7 + 9 = 16。 合并结果：8 + 16 = 24。 6. 线段树的更新 更新操作分为两种类型： 单点更新 修改数组中某个元素的值，并更新线段树中所有相关节点： 递归找到对应的叶子节点。 更新叶子节点的值。 回溯时，更新所有包含该叶子节点的父节点。 示例： 将数组[1, 3, 5, 7, 9, 11]中的第2个元素从3改为10： 找到叶子节点[2, 2]，更新值为10。 向上更新：[1, 3]的和从9变为1 + 10 + 5 = 16，根节点[1, 6]的和从36变为43。 区间更新 对某个区间的元素进行批量修改，例如将区间[2, 4]的所有值增加5。通常使用**延迟标记（Lazy Propagation）**优化，避免直接更新所有叶子节点： 在需要更新的节点上记录延迟标记。 在下次查询或更新时，将标记传播到子节点。 7. 线段树的空间复杂度 线段树是一个近似满二叉树，节点总数约为2n-1，因此空间复杂度为O(n)，其中n是数组的大小。 8. 线段树的应用 线段树在算法问题中有广泛应用，包括但不限于： 区间求和：计算任意区间的和。 区间最值：查找任意区间的最大值或最小值。 区间更新：对某个区间批量加减一个值。 动态规划优化：加速某些状态转移。 9. 线段树的优点与缺点 优点 查询和更新时间复杂度均为O(log n)，高效处理动态问题。 灵活性强，可根据问题定制功能。 缺点 实现相对复杂，代码量较大。 空间消耗较高，需要额外的O(n)存储。 9. 手动实现线段树 由于 Python 标准库和主流第三方库中没有直接提供线段树，开发者通常会根据问题需求手动实现。以下是一个简单的 Python 线段树实现，用于支持区间求和和单点更新，并包含详细注释以便理解。 代码实现：区间求和线段树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from typing import Listclass SegmentTree: def __init__(self, arr: List[int]): &quot;&quot;&quot;初始化线段树，arr 是输入数组&quot;&quot;&quot; self.n = len(arr) # 数组长度 self.tree = [0] * (4 * self.n) # 线段树数组，4n 足以容纳所有节点 self.arr = arr # 保存原始数组 if self.n &gt; 0: self._build(0, 0, self.n - 1) # 递归构建线段树 def _build(self, node: int, start: int, end: int): &quot;&quot;&quot;递归构建线段树，node 是当前节点，[start, end] 是当前区间&quot;&quot;&quot; if start == end: # 叶子节点，直接存储数组元素 self.tree[node] = self.arr[start] return mid = (start + end) // 2 left_node = 2 * node + 1 # 左子节点 right_node = 2 * node + 2 # 右子节点 # 递归构建左右子树 self._build(left_node, start, mid) self._build(right_node, mid + 1, end) # 合并子节点信息：当前节点存储左右子节点的和 self.tree[node] = self.tree[left_node] + self.tree[right_node] def update(self, index: int, value: int): &quot;&quot;&quot;单点更新：将 arr[index] 更新为 value&quot;&quot;&quot; self.arr[index] = value self._update(0, 0, self.n - 1, index, value) def _update(self, node: int, start: int, end: int, index: int, value: int): &quot;&quot;&quot;递归更新线段树，index 是要更新的位置，value 是新值&quot;&quot;&quot; if start == end: # 叶子节点，直接更新 self.tree[node] = value return mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归更新左子树或右子树 if index &lt;= mid: self._update(left_node, start, mid, index, value) else: self._update(right_node, mid + 1, end, index, value) # 合并更新后的子节点信息 self.tree[node] = self.tree[left_node] + self.tree[right_node] def query(self, left: int, right: int) -&gt; int: &quot;&quot;&quot;查询区间 [left, right] 的和&quot;&quot;&quot; return self._query(0, 0, self.n - 1, left, right) def _query(self, node: int, start: int, end: int, left: int, right: int) -&gt; int: &quot;&quot;&quot;递归查询 [left, right] 的和&quot;&quot;&quot; if left &lt;= start and end &lt;= right: # 当前区间完全包含在查询区间内，直接返回节点值 return self.tree[node] if right &lt; start or left &gt; end: # 当前区间与查询区间无交集，返回 0 return 0 mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归查询左右子树，并合并结果 left_sum = self._query(left_node, start, mid, left, right) right_sum = self._query(right_node, mid + 1, end, left, right) return left_sum + right_sum# 测试代码if __name__ == &quot;__main__&quot;: # 初始数组 arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # 测试查询 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：3 + 5 + 7 = 15 # 测试更新 seg_tree.update(1, 10) # 将 arr[1] 从 3 更新为 10 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：10 + 5 + 7 = 22 代码说明 初始化 (__init__)： 创建线段树数组 tree，大小为 4n（足以容纳所有节点）。 调用 _build 递归构建线段树，存储每个区间的和。 构建 (_build)： 递归划分区间，直到叶子节点。 叶子节点存储原始数组元素，中间节点存储子节点和。 更新 (update 和 _update)： 单点更新：递归找到对应的叶子节点，更新值。 回溯时更新所有相关父节点的和。 查询 (query 和 _query)： 查询区间 [left, right] 的和。 递归处理三种情况：完全包含、无交集、部分重叠。 时间复杂度： 构建：( O(n) ) 查询：( O(\\log n) ) 更新：( O(\\log n) ) 空间复杂度： ( O(n) )，线段树需要 ( 4n ) 的空间。 10. 线段树的高级功能（需要时可扩展实现） 手动实现的线段树可以根据问题需求扩展，以下是常见的高级功能： 区间更新（Lazy Propagation）： 支持对整个区间批量修改（如将 [l, r] 的值增加一个常数）。 使用延迟标记（lazy tag）记录未传播的更新，减少时间开销。 适用场景：动态修改大范围数据。 区间最值： 修改线段树存储最大值或最小值，而不是和。 例如，查询 [l, r] 的最大值，只需将合并操作从 + 改为 max。 动态线段树： 支持动态添加或删除节点，适用于数据范围不确定的场景。 实现较复杂，通常结合指针或动态分配。 持久化线段树： 保留线段树的历史版本，支持查询历史状态。 常用于函数式编程或需要回溯的问题。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"动态规划","slug":"动态规划","date":"2025-09-13T11:16:41.000Z","updated":"2025-09-13T13:37:51.043Z","comments":true,"path":"2025/09/13/动态规划/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划（Dynamic Programming，简称 DP）是算法设计中的一种重要方法，用于解决具有 重叠子问题 和 最优子结构 的优化问题。它通过将问题分解为较小的子问题，存储子问题的解以避免重复计算，从而高效求解复杂问题。在 ACM 竞赛 中，DP 是核心技巧，广泛应用于序列、图、树、背包、区间等问题。本文将详细讲解 DP 的概念、性质、设计步骤、常见类型、编程方法、在 ACM 竞赛中的应用，并提供带详细注释的 Python 实现 示例，以及模拟运行过程，帮助全面理解 DP 及其在竞赛中的价值。 1. 动态规划的基本概念 1.1 定义 动态规划是一种通过 分阶段 解决问题的方法，每个阶段的决策依赖于前几个阶段的解。DP 的核心思想是： 分解问题：将原问题分解为若干子问题。 存储中间结果：用表格（数组或哈希表）保存子问题的解，避免重复计算。 递归求解：通过子问题的解递归构建原问题的解。 DP 通常用于求解 最优化问题（如最大值、最小值、最短路径）或 计数问题（如方案数），其适用条件包括： 最优子结构：原问题的最优解可由子问题的最优解构成。 重叠子问题：子问题在递归分解中被多次求解，适合存储优化。 无后效性：当前阶段的决策只依赖于之前阶段的状态，不受后续决策影响。 示例： 斐波那契数列：第 ( n ) 项 ( F(n) = F(n-1) + F(n-2) )，子问题重叠，直接递归效率低，DP 存储中间结果优化。 最长公共子序列（LCS）：字符串 ( A ) 和 ( B ) 的 LCS 依赖于前缀的 LCS，具有最优子结构。 1.2 关键性质 状态（State）：用变量表示子问题的解，通常是数组或多维表格，如 ( dp[i] ) 表示前 ( i ) 项的最优解。 状态转移方程（Transition）：描述如何从已知状态推导新状态，如 ( dp[i] = \\max(dp[i-1], dp[i-2]) )。 初始条件（Base Case）：DP 表格的起点，如 ( dp[0] = 0 )。 目标：最终求解的状态，如 ( dp[n] )。 时间复杂度：通常为 ( O(\\text{状态数} \\times \\text{转移复杂度}) ). 空间复杂度：取决于状态存储，通常为 ( O(\\text{状态数}) )，可通过滚动数组优化。 1.3 DP 与其他方法的区别 与递归（Recursion）： 递归直接分解问题，可能重复计算子问题（指数复杂度）。 DP 存储子问题解（通常多项式复杂度）。 与分治（Divide and Conquer）： 分治将问题分为独立子问题（如归并排序）。 DP 处理重叠子问题，子问题间有依赖。 与贪心（Greedy）： 贪心基于局部最优，适用于特定问题（如活动选择）。 DP 考虑全局最优，适用范围更广（如 0-1 背包）。 1.4 DP 的设计步骤 定义状态：确定 ( dp[i][j]… ) 表示什么，通常与子问题相关。 推导状态转移方程：分析当前状态如何由前几个状态得出。 确定初始条件：初始化边界状态（如 ( dp[0][0] )。 计算顺序：确保状态按依赖顺序计算（自底向上或记忆化递归）。 求解目标：输出最终状态（如 ( dp[n][m] \\）。 优化空间：若状态只依赖前几行/列，用滚动数组减少空间。 1.5 常见 DP 类型 线性 DP：状态沿一维序列转移，如斐波那契、LIS（最长递增子序列）。 背包 DP：处理资源分配，如 0-1 背包、完全背包。 区间 DP：处理区间合并或分割，如石子合并、括号匹配。 树形 DP：在树上进行状态转移，如树的最小支配集。 状态压缩 DP：用二进制表示状态，适合小规模集合问题。 数位 DP：处理数字范围内的计数问题，如数字和。 概率/期望 DP：计算概率或期望值，如博弈问题。 多维 DP：处理多变量状态，如 LCS、编辑距离。 1.6 应用场景 ACM 竞赛： 序列问题：LIS、LCS、编辑距离。 背包问题：0-1 背包、完全背包、多重背包。 区间问题：石子合并、区间调度。 树上问题：树形 DP、最小点覆盖。 图上问题：最短路径、DAG 上的 DP。 实际应用： 机器学习：隐马尔可夫模型（HMM）、Viterbi 算法。 运筹学：资源分配、调度优化。 生物信息学：序列比对。 1.7 复杂度分析 时间复杂度：( O(\\text{状态数} \\times \\text{转移复杂度}) )。 例：LCS 为 ( O(n \\times m) )，状态数 ( n \\times m )，转移 ( O(1) )。 空间复杂度：( O(\\text{状态数}) )，可通过滚动数组优化到 ( O(\\text{较小维度}) )。 记忆化递归：与递推等价，适合状态空间稀疏或难以确定计算顺序。 2. 动态规划的编程方法 DP 的实现方式主要分为 递推（Bottom-Up） 和 记忆化递归（Top-Down），以下详细讲解两种方法的特点和实现步骤。 2.1 递推（Bottom-Up） 特点： 自底向上计算，从初始状态递推到目标状态。 使用循环填充 DP 表格，适合状态空间连续。 空间效率高，易于优化（如滚动数组）。 步骤： 定义 DP 数组（如 ( dp[i][j] )）。 初始化边界条件。 按状态依赖顺序循环，计算状态转移。 返回目标状态。 适用场景：状态空间明确，计算顺序简单（如线性 DP、背包 DP）。 优点： 避免递归开销，运行效率高。 易于调试，状态计算顺序清晰。 缺点： 状态空间稀疏时可能浪费计算。 复杂状态转移可能难以推导。 示例：0-1 背包问题 问题：给定 ( n ) 个物品，重量 ( w[i] )，价值 ( v[i] )，背包容量 ( W )，求最大价值。 状态：( dp[i][j] ) 表示前 ( i ) 个物品，容量 ( j ) 时的最大价值。 转移：( dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) )（若 ( j \\geq w[i] )）。 初始：( dp[0][j] = 0 )，( dp[i][0] = 0 )。 目标：( dp[n][W] ). 2.2 记忆化递归（Top-Down） 特点： 自顶向下递归，从目标状态分解到子问题。 使用记忆化（Memoization）存储已计算的子问题解。 适合状态空间稀疏或状态转移复杂。 步骤： 定义递归函数，参数表示状态。 创建记忆化表格（如字典或数组）。 在递归中检查是否已计算，若是返回缓存结果。 计算状态转移，存储结果。 适用场景：状态空间不规则、递归关系复杂（如树形 DP、数位 DP）。 优点： 代码直观，递归逻辑易于理解。 仅计算用到的状态，适合稀疏问题。 缺点： 递归栈开销大，可能导致栈溢出。 Python 递归深度有限，需调整或转为递推。 示例：最长公共子序列（LCS） 问题：给定字符串 ( A ) 和 ( B )，求最长公共子序列长度。 状态：( dp[i][j] ) 表示 ( A[0:i] ) 和 ( B[0:j] ) 的 LCS 长度。 转移： 若 ( A[i-1] == B[j-1] )，则 ( dp[i][j] = dp[i-1][j-1] + 1 )。 否则，( dp[i][j] = \\max(dp[i-1][j], dp[i][j-1]) )。 初始：( dp[0][j] = 0 )，( dp[i][0] = 0 ). 目标：( dp[|A|][|B|] ). 2.3 空间优化 滚动数组： 若状态只依赖前几行/列，用小数组覆盖大数组。 例：0-1 背包从 ( dp[n][W] ) 优化到 ( dp[W] )，空间 ( O(W) ). 状态压缩： 用位运算表示状态，适合状态压缩 DP。 例：TSP（旅行商问题），状态从 ( O(n \\times 2^n) ) 压缩到 ( O(2^n) ). 稀疏存储： 用字典或哈希表存储非零状态，适合记忆化递归。 2.4 调试与优化 调试： 打印 DP 表格，验证状态转移。 检查边界条件和初始值。 用小数据手动模拟，确保逻辑正确。 优化： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 常数优化：减少循环内操作，如提前计算常量。 并行化：复杂 DP 可分块并行（非比赛场景）。 Cython/Numba：加速 Python 循环（非比赛场景）。 3. 在 ACM 竞赛中的应用 DP 在 ACM 竞赛中是解决优化和计数问题的核心工具，因其 通用性 和 高效性 广泛应用于各种题型。以下是常见类型和解题思路： 线性 DP： 题目：求序列的最优解，如最长递增子序列（LIS）。 解法：定义 ( dp[i] ) 为以 ( i ) 结尾的最优解，转移考虑前序状态。 示例：Luogu P1020（导弹拦截，LIS）。 方法： 状态：( dp[i] ) 表示以 ( a[i] ) 结尾的 LIS 长度。 转移：( dp[i] = \\max(dp[j]) + 1 )，其中 ( j &lt; i )，( a[j] &lt; a[i] ). 复杂度：( O(n^2) )，可优化到 ( O(n \\log n) )（二分）。 Python 优势：列表操作简洁，调试方便。 背包 DP： 题目：资源分配，如 0-1 背包、完全背包。 解法：定义 ( dp[i][j] ) 为前 ( i ) 项容量 ( j ) 的最优解，转移考虑是否选择当前项。 示例：Luogu P1048（采药，0-1 背包）。 方法： 状态：( dp[i][j] ) 表示前 ( i ) 种草药，容量 ( j ) 的最大价值。 转移：( dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) ). 滚动数组：优化到 ( dp[j] )，空间 ( O(W) ). Python 优势：数组操作直观，滚动数组实现简单。 区间 DP： 题目：处理区间合并或分割，如石子合并。 解法：定义 ( dp[l][r] ) 为区间 ( [l, r] ) 的最优解，转移枚举分割点。 示例：Luogu P1880（石子合并）。 方法： 状态：( dp[l][r] ) 表示合并 ( [l, r] ) 石子的最小代价。 转移：( dp[l][r] = \\min(dp[l][k] + dp[k+1][r] + \\text{sum}[l,r]) )，( k \\in [l, r-1] ). 复杂度：( O(n^3) ). Python 优势：二维数组操作简洁，调试区间状态方便。 树形 DP： 题目：树上优化，如最小支配集。 解法：定义 ( dp[u][s] ) 为节点 ( u ) 在状态 ( s ) 下的最优解，递归转移。 示例：Luogu P1352（没有上司的舞会）。 方法： 状态：( dp[u][0/1] ) 表示节点 ( u ) 不选/选的最大快乐值。 转移：( dp[u][0] = \\sum \\max(dp[v][0], dp[v][1]) )，( dp[u][1] = r[u] + \\sum dp[v][0] ). 复杂度：( O(n) ). Python 优势：递归实现直观，邻接表管理树结构。 状态压缩 DP： 题目：小规模集合优化，如 TSP、棋盘覆盖。 解法：用二进制表示状态，转移枚举子集。 示例：POJ 1185（炮兵阵地）。 方法： 状态：( dp[i][s][t] ) 表示第 ( i ) 行，当前状态 ( s )，前一行状态 ( t )。 转移：枚举合法状态，检查兼容性。 复杂度：( O(n \\times 2^m \\times 2^m) )，( m ) 为列数。 Python 优势：位运算简洁，调试状态转换方便。 数位 DP： 题目：数字范围计数，如满足条件的数字个数。 解法：定义 ( dp[pos][state] ) 为前 ( pos ) 位在某状态下的方案数，递归转移。 示例：Luogu P2657（Scenic Number）。 方法： 状态：( dp[pos][prev][lead] ) 表示第 ( pos ) 位，前一位数字，是否前导零。 转移：枚举当前位数字，检查条件。 复杂度：( O(\\log n \\times \\text{状态数}) ). Python 优势：记忆化递归简洁，调试状态直观。 ACM 优化技巧： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 滚动数组：背包、区间 DP 优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态空间。 边界处理：注意空状态、负索引、越界。 调试：打印 DP 表格或递归路径，验证转移。 Python 在 ACM 中的适用性： 优点： 简洁：Python 实现 DP 约 50-100 行，比赛中 10-20 分钟完成。 调试：print DP 表格或状态，验证正确性。 适用：( n \\leq 10^5 )，时间限制 ≥ 1 秒，Python 通常通过。 缺点： 效率：Python 比 C++ 慢 5-10 倍，复杂 DP 可能 TLE。 内存：Python 数组和递归占用较多内存。 严格限制：( n \\geq 10^6 ) 或时间 &lt; 1 秒，可能 TLE。 优化： 用 array 存储 DP 表格，减少内存。 迭代实现，降低递归开销。 预处理输入，减少 I/O 瓶颈。 ACM 题目推荐： Luogu P1020：导弹拦截（LIS）。 Luogu P1048：采药（0-1 背包）。 Luogu P1880：石子合并（区间 DP）。 Luogu P1352：没有上司的舞会（树形 DP）。 POJ 1185：炮兵阵地（状态压缩 DP）。 Luogu P2657：Scenic Number（数位 DP）。 4. Python 实现 以下是几种典型 DP 问题的 Python 实现，包含递推和记忆化递归，带详细注释，适合 ACM 竞赛快速部署。 4.1 0-1 背包（递推） 12345678910111213141516171819202122import sysinput = sys.stdin.readlinedef knapsack(n: int, W: int, w: list, v: list) -&gt; int: &quot;&quot;&quot;0-1 背包：n 物品，容量 W，重量 w[i]，价值 v[i]，求最大价值&quot;&quot;&quot; # dp[j] 表示容量 j 的最大价值 dp = [0] * (W + 1) # 枚举物品 for i in range(n): # 逆序枚举容量（滚动数组） for j in range(W, w[i] - 1, -1): dp[j] = max(dp[j], dp[j - w[i]] + v[i]) return dp[W]# 测试n, W = map(int, input().split())w, v = [], []for _ in range(n): wi, vi = map(int, input().split()) w.append(wi) v.append(vi)print(&quot;0-1 Knapsack:&quot;, knapsack(n, W, w, v)) 4.2 最长公共子序列（记忆化递归） 1234567891011121314151617181920212223import sysinput = sys.stdin.readlinedef lcs(A: str, B: str) -&gt; int: &quot;&quot;&quot;最长公共子序列：字符串 A 和 B 的 LCS 长度&quot;&quot;&quot; m, n = len(A), len(B) memo = &#123;&#125; def dp(i: int, j: int) -&gt; int: if i == 0 or j == 0: return 0 if (i, j) in memo: return memo[(i, j)] if A[i-1] == B[j-1]: memo[(i, j)] = dp(i-1, j-1) + 1 else: memo[(i, j)] = max(dp(i-1, j), dp(i, j-1)) return memo[(i, j)] return dp(m, n)# 测试A = input().strip()B = input().strip()print(&quot;LCS Length:&quot;, lcs(A, B)) 4.3 石子合并（区间 DP，递推） 12345678910111213141516171819202122232425262728import sysinput = sys.stdin.readlinedef stone_merge(n: int, a: list) -&gt; int: &quot;&quot;&quot;石子合并：n 堆石子，合并成一堆的最小代价&quot;&quot;&quot; # 前缀和 s = [0] * (n + 1) for i in range(n): s[i + 1] = s[i] + a[i] # dp[l][r] 表示合并 [l, r] 的最小代价 dp = [[float(&#x27;inf&#x27;)] * n for _ in range(n)] for i in range(n): dp[i][i] = 0 # 单堆无需合并 # 枚举区间长度 for length in range(2, n + 1): # 枚举左端点 for l in range(n - length + 1): r = l + length - 1 # 枚举分割点 for k in range(l, r): dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + s[r+1] - s[l]) return dp[0][n-1]# 测试n = int(input())a = list(map(int, input().split()))print(&quot;Stone Merge Cost:&quot;, stone_merge(n, a)) 5. 运行过程 5.1 0-1 背包 输入： 123454 52 31 23 42 2 ( n=4 )，( W=5 )，物品：( (w_1=2, v_1=3) ), ( (w_2=1, v_2=2) ), ( (w_3=3, v_3=4) ), ( (w_4=2, v_4=2) ). 步骤： 初始化：( dp = [0, 0, 0, 0, 0, 0] ). 物品 1 (( w_1=2, v_1=3 ))： ( j=5 \\to 2 ): ( dp[5] = \\max(0, dp[3]+3)=3 ), …, ( dp[2] = 3 ). ( dp = [0, 0, 3, 0, 0, 3] ). 物品 2 (( w_2=1, v_2=2 ))： ( j=5 \\to 1 ): ( dp[5] = \\max(3, dp[4]+2)=3 ), …, ( dp[1] = 2 ). ( dp = [0, 2, 3, 5, 2, 3] ). 物品 3 (( w_3=3, v_3=4 ))： ( j=5 \\to 3 ): ( dp[5] = \\max(3, dp[2]+4)=7 ), …, ( dp[3] = 5 ). ( dp = [0, 2, 3, 5, 6, 7] ). 物品 4 (( w_4=2, v_4=2 ))： ( j=5 \\to 2 ): ( dp[5] = \\max(7, dp[3]+2)=7 ), …, ( dp[2] = 3 ). ( dp = [0, 2, 3, 5, 6, 7] ). 结果：( dp[5] = 7 ). 输出： 10-1 Knapsack: 7 5.2 最长公共子序列 输入： 12ABCDBECAD 字符串 ( A = “ABCD” )，( B = “BECAD” ). 步骤： 记忆化递归： ( dp(4, 5) ): ( A[3]=D ), ( B[4]=D ), 相等，( dp(4, 5) = dp(3, 4) + 1 ). ( dp(3, 4) ): ( A[2]=C ), ( B[3]=A ), 不等，( dp(3, 4) = \\max(dp(2, 4), dp(3, 3)) ). ( dp(2, 4) ): ( A[1]=B ), ( B[3]=A ), 不等，( dp(2, 4) = \\max(dp(1, 4), dp(2, 3)) ). 递归继续，计算所有状态。 最终：( dp(4, 5) = 3 )（LCS 为 “BCD”）。 记忆化表格（部分）：12345 B E C A DA 0 0 0 0 0B 1 1 1 1 1C 1 1 2 2 2D 1 1 2 2 3 输出： 1LCS Length: 3 5.3 石子合并 输入： 1241 3 5 2 ( n=4 )，石子：( a = [1, 3, 5, 2] ). 步骤： 前缀和：( s = [0, 1, 4, 9, 11] ). 初始化：( dp[i][i] = 0 ). 长度 2： ( dp[0][1] = s[2]-s[0] = 4 ). ( dp[1][2] = s[3]-s[1] = 8 ). ( dp[2][3] = s[4]-s[2] = 7 ). 长度 3： ( dp[0][2] = \\min(dp[0][0]+dp[1][2], dp[0][1]+dp[2][2]) + s[3]-s[0] = \\min(0+8, 4+0)+9 = 12 ). ( dp[1][3] = \\min(dp[1][1]+dp[2][3], dp[1][2]+dp[3][3]) + s[4]-s[1] = \\min(0+7, 8+0)+10 = 17 ). 长度 4： ( dp[0][3] = \\min(dp[0][k]+dp[k+1][3]+s[4]-s[0]) = \\min(0+17, 4+7, 12+0)+11 = 18 ). 结果：( dp[0][3] = 18 ). 输出： 1Stone Merge Cost: 18 6. DP 的优缺点 6.1 优点 高效性：将指数复杂度降为多项式（如斐波那契从 ( O(2^n) ) 到 ( O(n) )）。 通用性：适用于优化、计数、概率等多种问题。 ACM 友好：Python 实现简洁，约 50-100 行，比赛中 10-20 分钟完成。 可优化：滚动数组、状态压缩显著降低空间复杂度。 调试方便：DP 表格直观，易于验证。 6.2 缺点 状态设计复杂：需要准确定义状态和转移，初学者易出错。 空间限制：多维 DP 可能占用大量内存。 ACM 限制： 大输入（( n \\geq 10^6 )）或时间 &lt; 1 秒，Python 可能 TLE。 复杂状态压缩或数位 DP 实现难度高。 依赖经验：状态转移方程推导需熟练，比赛中时间紧迫。 6.3 改进方向 滚动数组：优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态数。 迭代实现：将记忆化递归转为递推，降低递归开销。 快速 I/O：优化 Python 输入输出。 Cython/Numba：加速 Python 循环（非比赛场景）。 7. 与其他方法的对比 7.1 与贪心算法 目标： 贪心：局部最优，快速决策。 DP：全局最优，考虑所有可能。 适用性： 贪心：活动选择、Huffman 编码。 DP：0-1 背包、LCS。 ACM 适用性： 贪心：简单问题，Python 实现快。 DP：复杂优化问题，Python 通用。 Python 实现： 贪心：代码短，逻辑简单。 DP：代码稍长，状态设计复杂。 7.2 与分治算法 目标： 分治：分解为独立子问题。 DP：分解为重叠子问题。 适用性： 分治：归并排序、快速排序。 DP：LIS、背包问题。 ACM 适用性： 分治：分治 + 递归，适合无重叠问题。 DP：优化重叠子问题，适合序列、图。 Python 实现： 分治：递归简洁，但可能重复计算。 DP：存储优化，效率更高。 7.3 与数据结构结合 DP + 线段树： 题目：动态区间优化。 解法：DP 定义状态，线段树维护区间最优值。 示例：Codeforces 474E（Pillars，LIS + 线段树）。 DP + 单调队列/栈： 题目：序列优化。 解法：单调队列维护 DP 转移的最优候选。 示例：Luogu P1725（琪露诺，单调队列 DP）。 DP + 树： 题目：树上优化。 解法：树形 DP 递归转移。 示例：Luogu P1352（没有上司的舞会）。 8. 模拟运行过程（补充数位 DP） 8.1 数位 DP 问题：统计区间 ([L, R]) 内，数字各位之和为 ( K ) 的数的个数。 代码： 12345678910111213141516171819202122232425262728293031import sysinput = sys.stdin.readlinedef digit_dp(L: int, R: int, K: int) -&gt; int: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位和为 K 的数的个数&quot;&quot;&quot; def count(num: str, K: int) -&gt; int: n = len(num) memo = &#123;&#125; def dp(pos: int, sum: int, tight: bool) -&gt; int: if pos == n: return 1 if sum == K else 0 if sum &gt; K: return 0 if (pos, sum, tight) in memo: return memo[(pos, sum, tight)] ans = 0 limit = int(num[pos]) if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit ans += dp(pos + 1, sum + d, new_tight) memo[(pos, sum, tight)] = ans return ans return dp(0, 0, True) return count(str(R), K) - count(str(L-1), K)# 测试L, R, K = map(int, input().split())print(&quot;Digit DP Count:&quot;, digit_dp(L, R, K)) 输入： 11 20 5 区间 ([1, 20])，各位和为 5. 步骤： 计算 ( \\text{count}(20, 5) )： ( dp(0, 0, \\text{True}) ): 枚举第一位 ( d=0 \\to 2 )： ( d=1 ): ( dp(1, 1, \\text{True}) ). ( d=2 ): ( dp(1, 2, \\text{True}) ). ( dp(1, 1, \\text{True}) ): 第二位 ( d=0 \\to 0 )，( dp(2, 1+0, \\text{True}) = 0 )（sum=1 &lt; 5）。 ( dp(1, 2, \\text{True}) ): ( d=0 )，( dp(2, 2+0, \\text{True}) = 0 )（sum=2 &lt; 5）。 结果：0（20 各位和 ≠ 5）。 计算 ( \\text{count}(0, 5) )：类似，0（无数字和 5）。 枚举 ([1, 20])：和为 5 的数为 5, 14。 结果：( 2 ). 输出： 1Digit DP Count: 2 9. 总结 动态规划是解决优化和计数问题的核心方法，通过状态设计和转移高效分解问题： 核心性质：最优子结构、重叠子问题、无后效性。 编程方法：递推（自底向上）、记忆化递归（自顶向下）、空间优化。 ACM 应用：线性 DP、背包、区间 DP、树形 DP、状态压缩、数位 DP。 Python 实现：约 50-100 行，调试方便，适合 ( n \\leq 10^5 )，时间 ≥ 1 秒。 优化：滚动数组、状态压缩、快速 I/O。 通过 Python 代码和样例模拟，展示了 DP 的常见类型和运行过程。在 ACM 竞赛中，DP 是不可或缺的工具，Python 实现适合快速原型和中小规模问题。 学习建议： 手动模拟：用小数据（如 ( n=4 )）画 DP 表格，推导转移。 ACM 练习：尝试 Luogu P1020、P1048、P1880，用 Python 实现 DP。 深入扩展：学习单调队列 DP、斜率优化、凸包优化。 比赛策略： 优先 Python 快速实现，验证正确性。 若 TLE，优化 I/O 或切换 C++. 如果你有其他问题、需要优化 Python 代码、或想探讨 ACM 题目（如复杂 DP 优化、数据结构结合），请随时告诉我！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"文档、库","slug":"文档、库","permalink":"https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"}]}