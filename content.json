{"meta":{"title":"Hexo","subtitle":"","description":"","author":"borrowyourhuaji","url":"https://borrowyourhuaji.github.io","root":"/"},"pages":[],"posts":[{"title":"tool command","slug":"ubuntu-tool-command","date":"2025-09-14T05:56:52.000Z","updated":"2025-09-14T05:58:13.781Z","comments":true,"path":"2025/09/14/ubuntu-tool-command/","permalink":"https://borrowyourhuaji.github.io/2025/09/14/ubuntu-tool-command/","excerpt":"","text":"1. grep 工具详解 grep（Global Regular Expression Print）是 Linux 中用于搜索文本的强大工具，通过正则表达式或固定字符串匹配文件内容或标准输入，输出匹配的行。它在文件查看、日志分析、数据过滤等场景中广泛使用。 1.1 功能 搜索文本: 在文件或标准输入中查找匹配指定模式（pattern）的行。 支持正则表达式: 使用正则表达式匹配复杂模式。 变体: 包括 egrep（扩展正则表达式）、fgrep（固定字符串匹配）、rgrep（递归搜索）。 灵活性: 可结合管道（|）处理其他命令的输出。 1.2 语法 1grep [选项] 模式 [文件...] 模式: 要搜索的字符串或正则表达式。 文件: 一个或多个文件路径，若省略则从标准输入读取。 选项: 控制搜索行为、输出格式等。 1.3 常用选项 以下是 grep 的常用选项，分为搜索控制、输出格式和上下文控制三类： 搜索控制: -i, --ignore-case: 忽略大小写。 示例: grep -i &quot;error&quot; log.txt（匹配 “Error” 或 “ERROR”）。 -w, --word-regexp: 仅匹配完整单词（避免部分匹配）。 示例: grep -w &quot;run&quot; script.sh（匹配 “run” 但不匹配 “running”）。 -v, --invert-match: 输出不匹配的行。 示例: grep -v &quot;^#&quot; config.conf（排除以 # 开头的注释行）。 -r, --recursive: 递归搜索目录中的所有文件。 示例: grep -r &quot;TODO&quot; /project/（搜索 /project/ 目录下包含 “TODO” 的文件）。 -l, --files-with-matches: 仅输出包含匹配的文件名。 示例: grep -l &quot;error&quot; *.log（列出包含 “error” 的日志文件）。 -L, --files-without-match: 输出不包含匹配的文件名。 示例: grep -L &quot;error&quot; *.log。 -e 模式, --regexp=模式: 指定多个模式（可多次使用）。 示例: grep -e &quot;error&quot; -e &quot;warning&quot; log.txt（匹配 “error” 或 “warning”）。 -E, --extended-regexp: 使用扩展正则表达式（等同 egrep）。 示例: grep -E &quot;error|warning&quot; log.txt。 -F, --fixed-strings: 按固定字符串匹配（等同 fgrep，禁用正则）。 示例: grep -F &quot;http://&quot; urls.txt（匹配字面字符串 “http://”）。 -P, --perl-regexp: 使用 Perl 兼容正则表达式（需支持）。 示例: grep -P &quot;\\d+&quot; numbers.txt（匹配数字）。 输出格式: -n, --line-number: 显示匹配行的行号。 示例: grep -n &quot;error&quot; log.txt。 -c, --count: 输出匹配行的数量。 示例: grep -c &quot;error&quot; log.txt。 -o, --only-matching: 仅输出匹配的部分（而非整行）。 示例: grep -o &quot;[0-9]+&quot; data.txt（提取所有数字）。 --color: 高亮显示匹配内容（默认自动启用）。 示例: grep --color &quot;error&quot; log.txt。 -b, --byte-offset: 显示匹配内容的字节偏移量。 示例: grep -b &quot;key&quot; file.txt。 上下文控制: -A 行数, --after-context=行数: 显示匹配行后的指定行数。 示例: grep -A 2 &quot;error&quot; log.txt（显示匹配行及后两行）。 -B 行数, --before-context=行数: 显示匹配行前的指定行数。 示例: grep -B 2 &quot;error&quot; log.txt。 -C 行数, --context=行数: 显示匹配行前后各指定行数。 示例: grep -C 2 &quot;error&quot; log.txt。 1.4 使用场景 日志分析: 查找错误或特定事件（如 grep &quot;ERROR&quot; /var/log/syslog）。 配置文件筛选: 提取非注释行或特定配置项。 代码搜索: 在源代码中查找函数或关键字。 数据处理: 结合管道过滤命令输出（如 ps aux | grep python）。 1.5 示例 基本搜索： 1grep &quot;error&quot; /var/log/syslog 输出 syslog 中包含 “error” 的行。 忽略大小写： 1grep -i &quot;warning&quot; log.txt 匹配 “Warning” 或 “WARNING”。 递归搜索目录： 1grep -r &quot;TODO&quot; /home/user/project/ 在项目目录下查找所有包含 “TODO” 的文件。 显示行号和上下文： 1grep -n -C 3 &quot;exception&quot; app.log 显示包含 “exception” 的行、行号及前后各 3 行。 提取匹配部分： 1grep -o &quot;[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;&quot; log.txt 提取日志中的 IP 地址。 结合管道： 1ps aux | grep -i &quot;firefox&quot; 查找运行中的 Firefox 进程。 多个模式： 1grep -e &quot;error&quot; -e &quot;fail&quot; log.txt 匹配包含 “error” 或 “fail” 的行。 1.6 正则表达式基础 grep 默认使用基本正则表达式（BRE），-E 启用扩展正则表达式（ERE），-P 启用 Perl 正则表达式。常用正则语法： .: 任意单个字符。 *: 前字符 0 次或多次。 +: 前字符 1 次或多次（需 -E 或 -P）。 ?: 前字符 0 次或 1 次（需 -E 或 -P）。 []: 字符集，如 [a-z] 匹配小写字母。 ^: 行首。 $: 行尾。 |: 或操作（如 error|warning，需 -E）。 \\d: 数字（需 -P）。 \\w: 单词字符（需 -P）。 示例: grep &quot;^[A-Z]&quot; file.txt: 匹配以大写字母开头的行。 grep -E &quot;error|warning&quot; log.txt: 匹配 “error” 或 “warning”。 grep -P &quot;\\d&#123;3&#125;-\\d&#123;2&#125;-\\d&#123;4&#125;&quot; data.txt: 匹配类似 “123-45-6789” 的模式。 1.7 高级用法 结合 find: 搜索特定类型文件中的内容。 1find /var/log -name &quot;*.log&quot; -exec grep &quot;error&quot; &#123;&#125; \\; 在所有 .log 文件中搜索 “error”。 管道过滤: 处理复杂输出。 1dmesg | grep -i &quot;usb&quot; | grep -v &quot;disconnected&quot; 查找 USB 相关消息，排除 “disconnected”。 统计匹配: 计算特定模式出现次数。 1grep -c &quot;GET&quot; access.log 统计 HTTP GET 请求次数。 脚本化: 在 shell 脚本中动态搜索。 123if grep -q &quot;error&quot; log.txt; then echo &quot;Error found!&quot;fi -q 选项静默检查是否存在匹配。 1.8 注意事项 性能: 对大文件或目录递归搜索（-r）可能较慢，考虑使用 fgrep（固定字符串）或 ripgrep（见下文）。 正则表达式转义: 特殊字符（如 .、*）需用 \\ 转义（除非用 -F）。 权限: 搜索系统文件（如 /var/log）可能需 sudo。 编码: 非 ASCII 文件可能需指定编码（如 LC_ALL=C grep ...）。 2. grep 变体 grep 有以下变体，功能类似但侧重点不同： egrep 功能: 等同于 grep -E，使用扩展正则表达式（ERE），无需转义 |、+ 等。 语法: egrep [选项] 模式 [文件...] 场景: 需要复杂正则表达式（如 error|warning）时。 示例: 1egrep &quot;error|warning&quot; log.txt 匹配 “error” 或 “warning”。 注意: egrep 是 grep -E 的别名，现代系统中建议直接用 grep -E。 fgrep 功能: 等同于 grep -F，按固定字符串匹配，不解析正则表达式，速度更快。 语法: fgrep [选项] 字符串 [文件...] 场景: 搜索字面字符串（如 URL 或代码片段）无需正则。 示例: 1fgrep &quot;http://&quot; urls.txt 匹配字面字符串 “http://”。 注意: 适合搜索特殊字符，避免转义麻烦。 rgrep 功能: 等同于 grep -r，递归搜索目录中的文件。 语法: rgrep [选项] 模式 [目录...] 场景: 搜索项目目录中的代码或配置文件。 示例: 1rgrep &quot;TODO&quot; /home/user/project/ 递归搜索包含 “TODO” 的文件。 注意: rgrep 是 grep -r 的别名，建议用 grep -r。 3. 相关工具 以下工具与 grep 常结合使用，扩展文件查看和编辑功能，简要讲解其语法和用途。 3.1 sed（Stream Editor） 功能: 流编辑器，用于文本替换、删除、插入等操作，适合批量处理。 语法: 1sed [选项] &#x27;命令&#x27; [文件...] 常用选项: -i: 直接修改原文件（建议备份，如 -i.bak）。 -e: 执行多个命令。 -r: 使用扩展正则表达式。 常用命令: s/模式/替换/g: 全局替换。 d: 删除匹配行。 p: 打印匹配行。 示例: sed 's/error/warning/g' log.txt: 将 “error” 替换为 “warning”。 sed -i.bak '/^#/d' config.txt: 删除注释行并备份原文件。 sed '10,20d' data.txt: 删除第 10 到 20 行。 与 grep 结合: 1grep &quot;error&quot; log.txt | sed &#x27;s/error/ERROR/g&#x27; 筛选 “error” 行并将其改为 “ERROR”。 场景: 批量修改配置文件、清理日志。 3.2 awk 功能: 文本处理工具，适合处理结构化数据（如 CSV、日志），支持字段提取和计算。 语法: 1awk [选项] &#x27;程序&#x27; [文件...] 常用选项: -F 分隔符: 指定字段分隔符（如 ','）。 -v 变量=值: 定义变量。 常用程序: &#123;print $n&#125;: 打印第 n 列。 /模式/ &#123;动作&#125;: 对匹配模式执行动作。 BEGIN &#123;动作&#125;: 文件处理前执行。 END &#123;动作&#125;: 文件处理后执行。 示例: awk -F',' '&#123;print $1&#125;' data.csv: 打印 CSV 第一列。 awk '/error/ &#123;print&#125;' log.txt: 打印包含 “error” 的行。 awk '&#123;sum+=$2&#125; END &#123;print sum&#125;' numbers.txt: 计算第二列总和。 与 grep 结合: 1grep &quot;error&quot; log.txt | awk &#x27;&#123;print $1, $3&#125;&#x27; 筛选 “error” 行并打印第一和第三列。 场景: 提取日志字段、统计数据。 3.3 ripgrep (rg) 功能: 现代高性能搜索工具，类似 grep 但更快，支持更多功能（需安装 sudo apt install ripgrep）。 语法: 1rg [选项] 模式 [路径] 常用选项: -i: 忽略大小写。 -w: 匹配完整单词。 -g 模式: 按文件名模式过滤（如 *.py）。 --no-heading: 不显示文件名标题。 --files: 仅列出匹配文件。 场景: 大型项目代码搜索、快速日志分析。 示例: rg &quot;TODO&quot; /project/: 递归搜索 “TODO”。 rg -i &quot;error&quot; *.log: 在日志文件中搜索 “error”。 rg -g &quot;*.py&quot; &quot;def&quot;: 在 Python 文件中搜索函数定义。 与 grep 的区别: 更快：利用多线程和优化算法。 默认递归且忽略 .git 等隐藏目录。 更智能：支持复杂正则和文件类型过滤。 注意: ripgrep 需安装，适合高性能场景。 4. 高级使用场景与示例 以下展示 grep 及相关工具在实际任务中的组合应用： 日志分析: 查找最近 10 分钟的错误日志：1tail -n 1000 /var/log/syslog | grep &quot;error&quot; 提取错误相关的 IP 地址：1grep &quot;error&quot; log.txt | grep -o &quot;[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;\\.[0-9]\\&#123;1,3\\&#125;&quot; 批量修改配置文件: 删除所有注释行并替换关键字：1grep -v &quot;^#&quot; config.txt | sed &#x27;s/server/host/g&#x27; &gt; newconfig.txt 统计特定模式: 计算 HTTP 请求类型：1grep -E &quot;GET|POST&quot; access.log | awk &#x27;&#123;print $6&#125;&#x27; | sort | uniq -c 输出每种请求类型的出现次数。 代码搜索与清理: 查找所有 Python 文件中的 TODO：1rg -g &quot;*.py&quot; &quot;TODO&quot; /project/ 替换代码中的旧变量名：1find /project -name &quot;*.py&quot; -exec sed -i &#x27;s/old_var/new_var/g&#x27; &#123;&#125; \\; 实时监控与过滤: 实时监控错误日志并提取时间戳：1tail -f /var/log/syslog | grep &quot;error&quot; | awk &#x27;&#123;print $1, $2, $3&#125;&#x27; 5. 注意事项与扩展 性能优化: 使用 fgrep 或 ripgrep 处理固定字符串搜索以提高速度。 限制搜索范围（如 grep -r &quot;pattern&quot; /specific/dir）避免全盘扫描。 正则表达式调试: 测试复杂正则表达式时，先用 grep -o 查看匹配部分。 使用工具如 regex101.com 验证正则语法。 权限问题: 搜索系统文件（如 /var/log）可能需 sudo，如 sudo grep &quot;error&quot; /var/log/secure. 编码问题: 处理非 ASCII 文件时，可能需设置 LC_ALL=C。 示例: LC_ALL=C grep &quot;pattern&quot; file.txt. 学习资源: 查看手册：man grep, man sed, man awk。 安装 tldr（sudo apt install tldr）获取简明示例。 在线教程：如 DigitalOcean 的 grep 指南或 Ubuntu 社区文档。 替代工具: ripgrep (rg): 更快、更现代，适合大型项目。 ack: 面向开发者的搜索工具，专注于代码。 ag (silversearcher): 类似 ripgrep，高性能搜索。","categories":[],"tags":[]},{"title":"ubuntu services cmommand","slug":"ubuntu-services-cmommand","date":"2025-09-13T15:42:12.000Z","updated":"2025-09-14T04:36:32.931Z","comments":true,"path":"2025/09/13/ubuntu-services-cmommand/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/ubuntu-services-cmommand/","excerpt":"","text":"🔹 一、基础网络命令（内置/通用） 命令 功能 示例 ping 测试连通性 ping baidu.com curl HTTP/HTTPS 请求 curl -I https://example.com wget 下载文件 wget https://example.com/file.zip traceroute 路由跟踪 traceroute 8.8.8.8 mtr 动态路由跟踪（集成 ping+traceroute） mtr google.com telnet 测试 TCP 端口连通 telnet example.com 80 nc / netcat 网络测试、端口扫描、socket调试 nc -zv 192.168.1.1 22-80 dig DNS 查询（来自 dnsutils 包） dig google.com nslookup DNS 查询（老工具） nslookup baidu.com host 简单 DNS 查询 host github.com 🔹 二、旧工具 Net-tools（逐渐被替代，但仍常用） 需安装：sudo apt install net-tools 命令 功能 示例 ifconfig 查看/配置网络接口 ifconfig eth0 up route 查看/配置路由表 route -n arp 查看/管理 ARP 缓存 arp -a netstat 查看端口、连接、路由 netstat -tulnp 🔹 三、新工具 iproute2（现代替代方案，推荐） 自带在 Ubuntu，无需安装。 命令 功能 示例 ip addr 查看/管理 IP 地址 ip addr show ip link 查看/配置网卡 ip link set eth0 up ip route 查看/管理路由表 ip route add default via 192.168.1.1 ip neigh 查看/管理 ARP 表 ip neigh show ss 替代 netstat，查看 socket ss -tulnp 🔹 四、网络诊断与测试 命令 功能 示例 ethtool 网卡信息、速率 ethtool eth0 iwconfig 无线网卡配置（Wi-Fi） iwconfig wlan0 iwlist 扫描无线网络 iwlist wlan0 scan nmcli NetworkManager CLI，配置网络 nmcli device status systemd-resolve DNS 解析调试（systemd-resolved） systemd-resolve google.com curl ifconfig.me 查看公网 IP curl ifconfig.me whois 域名/IP 查询 whois example.com 🔹 五、服务管理相关 命令 功能 示例 service networking restart 重启网络服务 systemctl restart NetworkManager 重启 NetworkManager nmcli 全面网络管理工具 nmcli con up id mywifi wpa_cli / wpa_supplicant Wi-Fi 配置工具 wpa_cli status 🔹 六、抓包与流量分析 命令 功能 示例 tcpdump 抓包分析 tcpdump -i eth0 port 80 wireshark / tshark 高级抓包工具 tshark -i wlan0 iftop 实时流量监控 iftop -i eth0 nload 网络流量实时曲线 nload iptraf-ng 网络统计工具 iptraf-ng 🔹 七、防火墙与安全 命令 功能 示例 ufw 简易防火墙管理（Ubuntu 默认推荐） ufw allow 22/tcp iptables 底层防火墙配置 iptables -L -n -v firewalld 另一套防火墙（部分系统用） firewall-cmd --list-all fail2ban-client SSH 防暴力破解工具 fail2ban-client status 🔹 八、其他常见网络命令 命令 功能 示例 scp 远程拷贝文件（基于 SSH） scp file user@host:/path/ rsync 高效同步文件 rsync -avz dir user@host:/path/ ftp / sftp 文件传输 sftp user@host ssh 远程登录 ssh user@host 🔹 九、练习路线（给你练手的建议） 入门： 用 ping、curl、wget 测试网络 用 ip addr、ifconfig 查看网卡 进阶： 用 ss -tulnp 找出占用端口的服务 用 ip route 修改默认路由 用 ufw 添加规则限制端口 高级： 用 tcpdump 抓包，配合 wireshark 分析 HTTP/HTTPS 用 iptables 手写 NAT 转发规则 用 nload 或 iftop 看实时流量 Ubuntu 网络相关命令列表 1. 网络接口管理 ifconfig: 显示或配置网络接口（传统工具，需安装 net-tools）。 示例: ifconfig eth0 (显示 eth0 接口信息)。 ip: 现代网络接口管理工具，显示或配置 IP 地址、路由等。 示例: ip addr show (显示所有接口信息)。 nmcli: NetworkManager 命令行工具，管理网络连接。 示例: nmcli con show (列出网络连接)。 ethtool: 显示或配置网络接口状态（如速度、双工模式）。 示例: ethtool eth0 (显示 eth0 状态)。 iwconfig: 配置无线网络接口（需安装 wireless-tools）。 示例: iwconfig wlan0 (显示无线接口信息)。 iw: 现代无线网络接口管理工具。 示例: iw dev wlan0 scan (扫描无线网络)。 ifup: 启用网络接口（需配置 /etc/network/interfaces）。 示例: sudo ifup eth0。 ifdown: 禁用网络接口。 示例: sudo ifdown eth0。 route: 显示或配置路由表（需安装 net-tools）。 示例: route -n (显示数字格式路由表)。 ip route: 现代路由表管理工具。 示例: ip route show (显示路由表)。 2. 网络诊断与测试 ping: 测试与目标主机的网络连通性。 示例: ping -c 4 google.com (发送 4 个数据包)。 traceroute: 显示数据包到目标主机的路由路径（需安装）。 示例: traceroute google.com。 mtr: 结合 ping 和 traceroute 的实时网络诊断工具（需安装）。 示例: mtr google.com。 dig: 查询 DNS 记录（需安装 dnsutils）。 示例: dig example.com。 nslookup: 查询 DNS 名称解析。 示例: nslookup example.com。 host: 简单 DNS 查询工具。 示例: host example.com。 netstat: 显示网络连接、路由表、接口统计（需安装 net-tools）。 示例: netstat -tuln (显示监听的 TCP/UDP 端口)。 ss: 现代网络套接字统计工具，替代 netstat。 示例: ss -tuln (显示监听端口)。 nmap: 网络扫描和端口探测工具（需安装）。 示例: nmap localhost (扫描本地主机端口)。 telnet: 测试远程主机端口连通性。 示例: telnet example.com 80 (测试 80 端口)。 nc (netcat): 多功能网络工具，用于端口测试、数据传输等。 示例: nc -zv localhost 22 (测试端口连接)。 arp: 显示或管理 ARP 缓存（地址解析协议）。 示例: arp -n (显示 ARP 表)。 ip neighbor: 现代 ARP 表管理工具。 示例: ip neighbor show (显示邻居表)。 3. 网络文件传输 curl: 从 URL 下载或发送数据，支持 HTTP/HTTPS/FTP 等。 示例: curl -O https://example.com/file.txt (下载文件)。 wget: 非交互式文件下载工具。 示例: wget https://example.com/file.zip。 scp: 通过 SSH 安全复制文件到远程主机。 示例: scp file.txt user@host:/path。 rsync: 高效的文件同步和传输工具。 示例: rsync -avz file.txt user@host:/path (同步文件)。 ftp: 交互式 FTP 文件传输（需安装 FTP 客户端）。 示例: ftp ftp.example.com。 sftp: 通过 SSH 进行安全的 FTP 文件传输。 示例: sftp user@host。 4. 远程连接与管理 ssh: 安全远程登录到另一台主机。 示例: ssh user@host。 ssh-keygen: 生成 SSH 密钥对。 示例: ssh-keygen -t rsa。 ssh-copy-id: 将公钥复制到远程主机以实现免密码登录。 示例: ssh-copy-id user@host。 telnet: 非安全远程连接（不推荐，测试用）。 示例: telnet host 23。 5. 网络服务管理 systemctl: 管理网络相关服务（如 NetworkManager、sshd）。 示例: sudo systemctl restart ssh。 service: 传统方式管理系统服务。 示例: sudo service networking restart。 ufw: 简易防火墙配置工具。 示例: sudo ufw allow 22 (允许 SSH 端口)。 iptables: 配置内核防火墙规则（高级用户）。 示例: sudo iptables -L (列出规则)。 firewalld: 动态防火墙管理工具（需安装）。 示例: sudo firewall-cmd --list-all。 6. 网络监控与分析 tcpdump: 捕获和分析网络数据包（需安装）。 示例: sudo tcpdump -i eth0 (捕获 eth0 接口数据包)。 wireshark: 图形化网络协议分析工具（需安装）。 示例: wireshark &amp; (启动 GUI 界面)。 iftop: 实时显示网络接口带宽使用情况（需安装）。 示例: sudo iftop -i eth0。 nload: 监控网络带宽使用情况（需安装）。 示例: nload eth0。 vnstat: 统计网络流量（需安装）。 示例: vnstat -i eth0 (显示 eth0 流量统计)。 7. 其他网络相关工具 hostname: 显示或设置系统主机名。 示例: hostname。 hostnamectl: 管理主机名（现代 systemd 工具）。 示例: hostnamectl set-hostname newname。 whois: 查询域名注册信息（需安装）。 示例: whois example.com。 curlftpfs: 将 FTP 服务器挂载为本地文件系统（需安装）。 示例: curlftpfs ftp://user:pass@host /mnt/ftp。 avahi-discover: 发现局域网内 mDNS/DNS-SD 服务（需安装）。 示例: avahi-discover。 ipcalc: 计算 IP 地址和子网信息（需安装）。 示例: ipcalc 192.168.1.0/24。 dhclient: 获取或释放 DHCP 租约。 示例: sudo dhclient eth0。 dnsmasq: 轻量级 DNS 和 DHCP 服务器（需安装）。 示例: sudo dnsmasq。 说明 安装说明: 部分命令（如 net-tools、nmap、wireshark 等）可能需要安装，运行 sudo apt install &lt;包名&gt;。 权限: 网络配置或监控命令通常需要 sudo 权限。 文档查询: 使用 man &lt;命令&gt; 或 tldr &lt;命令&gt; 获取详细用法（tldr 需安装）。 扩展: 更多高级工具可通过 apt search network 或 compgen -c | grep network 发现。","categories":[],"tags":[{"name":"service","slug":"service","permalink":"https://borrowyourhuaji.github.io/tags/service/"}]},{"title":"ubuntu common cmommand","slug":"ubuntu-common-cmommand","date":"2025-09-13T15:37:46.000Z","updated":"2025-09-14T06:07:40.268Z","comments":true,"path":"2025/09/13/ubuntu-common-cmommand/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/ubuntu-common-cmommand/","excerpt":"","text":"🔹 1. 基础操作命令 功能 命令 说明 查看当前目录 pwd print working directory 列出文件 ls、ls -l、ls -a 加 -l 显示详细，加 -a 显示隐藏文件 切换目录 cd 目录名 cd .. 返回上一级，cd ~ 回家目录 创建目录 mkdir test 递归创建：mkdir -p a/b/c 创建文件 touch file.txt 更新文件时间，若不存在就新建 删除文件 rm file.txt 删除目录：rm -r dirname 拷贝 cp a b 拷贝文件；cp -r dir1 dir2 复制目录 移动/重命名 mv a b 文件移动/改名 查看文件内容 cat file、less file、head file、tail file tail -f log.txt 实时看日志 🔹 2. 用户和权限 功能 命令 说明 当前用户 whoami 切换用户 su 用户名 临时管理员 sudo 命令 修改权限 chmod 755 file 读/写/执行权限 修改属主 chown user:group file 🔹 3. 软件管理 (Ubuntu apt) 功能 命令 说明 更新源 sudo apt update 更新索引，不升级 升级系统 sudo apt upgrade 升级已安装包 安装软件 sudo apt install 包名 卸载软件 sudo apt remove 包名 搜索软件 apt search 关键词 查看已安装 `dpkg -l grep 包名` 🔹 4. 进程和系统 功能 命令 说明 查看进程 ps aux、top、htop 杀进程 kill -9 pid 系统状态 uptime（负载）、free -h（内存）、df -h（磁盘）、du -sh（目录大小） 网络 ping baidu.com、curl ifconfig.me（查看公网 IP）、ss -tulpn（监听端口） 🔹 5. WSL 专属命令（在 Windows PowerShell / CMD 用） 这些是 WSL 特有的，在 Windows 的命令行运行，而不是 Ubuntu 内： 功能 命令 说明 进入 WSL wsl 默认发行版 指定发行版 wsl -d Ubuntu-22.04 查看已安装发行版 wsl -l -v 运行 Linux 命令 wsl ls -la 在 Windows 下直接执行 导入导出 wsl --export / wsl --import 关闭 wsl --shutdown Ubuntu 常用命令列表 1. 文件和目录管理（File &amp; Directory Management） 1. 查看目录内容 ls 功能: 列出当前或指定目录中的文件和文件夹。 语法: ls [选项] [路径] 常用选项: -l: 长格式显示，包含权限、所有者、大小、修改时间等。 -a: 显示隐藏文件（以 . 开头的文件）。 -h: 以人类可读格式显示文件大小（如 KB、MB）。 -R: 递归列出子目录内容。 -t: 按修改时间排序（最新优先）。 场景: 检查目录内容、确认文件存在、查看文件属性。 示例: ls -la /home/user: 显示 /home/user 目录下所有文件（包括隐藏文件）的详细信息。 ls -lh /var/log: 显示日志目录中文件的可读大小。 ls -R /etc: 递归列出 /etc 及其子目录内容。 dir 功能: 类似 ls，但以更详细的格式显示目录内容（类似 DOS 的 dir）。 语法: dir [选项] [路径] 常用选项: -a: 显示所有文件（包括隐藏）。 -l: 纵向列表显示。 --color: 以颜色区分文件类型。 场景: 需要与传统 DOS 风格类似的输出，或在脚本中需要更结构化的列表。 示例: dir -a /tmp: 显示 /tmp 目录下所有文件。 dir --color /home: 以彩色输出列出家目录内容。 tree 功能: 以树状结构显示目录内容（需安装 sudo apt install tree）。 语法: tree [选项] [路径] 常用选项: -a: 显示隐藏文件。 -d: 仅显示目录。 -L 级别: 限制递归深度。 -f: 显示完整路径。 场景: 可视化目录结构，适合文档整理或教学。 示例: tree -a /home/user: 显示家目录及其子目录的完整树状结构。 tree -d -L 2 /etc: 显示 /etc 目录下两级目录结构。 2. 切换和查看目录 cd 功能: 更改当前工作目录。 语法: cd [路径] 常用选项/用法: cd ..: 返回上一级目录。 cd -: 返回上一个工作目录。 cd ~: 切换到用户家目录。 cd /: 切换到根目录。 场景: 在终端导航文件系统，进入特定目录进行操作。 示例: cd /var/log: 进入日志目录。 cd ~/Documents: 进入用户家目录下的 Documents 文件夹。 cd .. &amp;&amp; cd /tmp: 返回上一级目录后进入 /tmp。 pwd 功能: 显示当前工作目录的绝对路径。 语法: pwd [选项] 常用选项: -P: 显示物理路径（解析符号链接）。 -L: 显示逻辑路径（包含符号链接）。 场景: 确认当前所在目录，尤其在复杂脚本或符号链接环境中。 示例: pwd: 显示当前路径，如 /home/user/project。 pwd -P: 显示解析符号链接后的实际路径。 3. 创建文件和目录 touch 功能: 创建空文件或更新文件的时间戳。 语法: touch [选项] 文件名 常用选项: -t 时间: 设置特定时间戳（如 YYYYMMDDhhmm）。 -m: 仅更新修改时间。 -a: 仅更新访问时间。 -c: 若文件不存在，不创建。 场景: 创建占位文件、更新时间戳以标记文件状态。 示例: touch file.txt: 创建空文件 file.txt。 touch -t 202509141200 file.txt: 将文件时间戳设为 2025 年 9 月 14 日 12:00。 touch -c existing_file.txt: 更新现有文件时间戳，不创建新文件。 mkdir 功能: 创建新目录。 语法: mkdir [选项] 目录名 常用选项: -p: 创建父目录（若不存在）。 -m 权限: 设置目录权限（如 755）。 -v: 显示创建过程。 场景: 组织文件系统、创建项目目录。 示例: mkdir newfolder: 创建名为 newfolder 的目录。 mkdir -p /path/to/nested/dir: 创建嵌套目录结构。 mkdir -m 700 private_dir: 创建权限为 700 的目录。 4. 删除文件和目录 rm 功能: 删除文件或目录。 语法: rm [选项] 文件/目录 常用选项: -r 或 -R: 递归删除目录及其内容。 -f: 强制删除，不提示确认。 -i: 交互式删除，逐个确认。 -v: 显示删除过程。 场景: 清理无用文件、释放磁盘空间。 注意: 使用 -rf 需谨慎，可能导致不可恢复的数据丢失。 示例: rm file.txt: 删除单个文件。 rm -r folder: 递归删除 folder 及其内容。 rm -rf /tmp/*: 强制删除 /tmp 下的所有内容（需谨慎）。 rmdir 功能: 删除空目录。 语法: rmdir [选项] 目录名 常用选项: -p: 删除空目录及其空父目录。 -v: 显示删除过程。 场景: 删除不再需要的空目录。 示例: rmdir emptyfolder: 删除空目录 emptyfolder。 rmdir -p parent/child: 删除 child 及其空父目录 parent。 5. 复制和移动 cp 功能: 复制文件或目录到指定位置。 语法: cp [选项] 源 目标 常用选项: -r 或 -R: 递归复制目录及其内容。 -p: 保留文件属性（如权限、时间戳）。 -i: 交互式复制，覆盖前提示。 -u: 仅复制比目标新或不存在的文件。 -v: 显示复制过程。 场景: 备份文件、复制项目目录。 示例: cp file.txt /backup/: 复制 file.txt 到 /backup/。 cp -r project /backup/: 递归复制 project 目录。 cp -up *.txt /backup/: 仅复制更新或新的 .txt 文件。 mv 功能: 移动或重命名文件/目录。 语法: mv [选项] 源 目标 常用选项: -i: 交互式移动，覆盖前提示。 -f: 强制覆盖目标文件。 -u: 仅移动比目标新或不存在的文件。 -v: 显示移动过程。 场景: 重命名文件、移动文件到新位置。 示例: mv oldname.txt newname.txt: 重命名文件。 mv project /archive/: 移动 project 目录到 /archive/。 mv -i file.txt /existing/: 若目标存在，提示是否覆盖。 6. 链接管理 ln 功能: 创建硬链接或符号链接。 语法: ln [选项] 源 链接名 常用选项: -s: 创建符号链接（软链接）。 -f: 强制创建，覆盖现有链接。 -n: 不将目标视为目录。 场景: 创建文件/目录的快捷方式，节省空间或便于访问。 示例: ln -s /var/log/app.log app_link: 创建指向 app.log 的符号链接。 ln file.txt hardlink.txt: 创建 file.txt 的硬链接。 注意: 硬链接共享 inode，符号链接是独立文件，指向源路径。 7. 查找文件和目录 find 功能: 在目录中搜索文件或目录，基于名称、类型、时间等条件。 语法: find [路径] [选项] 常用选项: -name 模式: 按文件名搜索（支持通配符）。 -type 类型: 指定类型（如 f 表示文件，d 表示目录）。 -mtime 天数: 按修改时间搜索（如 -mtime -7 表示 7 天内修改）。 -exec 命令: 对找到的文件执行命令。 -size 大小: 按文件大小搜索（如 +100M 表示大于 100MB）。 场景: 查找丢失文件、清理大文件、批量操作。 示例: find /home -name &quot;*.txt&quot;: 查找家目录下所有 .txt 文件。 find / -type d -name &quot;temp&quot;: 查找所有名为 temp 的目录。 find /var -size +1G -exec rm -v &#123;&#125; \\;: 删除 /var 下大于 1GB 的文件。 locate 功能: 快速查找文件（基于预构建的数据库）。 语法: locate [选项] 模式 常用选项: -i: 忽略大小写。 -r: 使用正则表达式。 -c: 显示匹配计数。 场景: 快速定位文件，适合频繁查找。 注意: 需定期运行 sudo updatedb 更新数据库。 示例: locate config.yaml: 查找所有名为 config.yaml 的文件。 locate -i readme: 查找忽略大小写的 readme 文件。 8. 文件系统信息 du 功能: 计算目录或文件的磁盘使用量。 语法: du [选项] [路径] 常用选项: -h: 人类可读格式（如 KB、MB）。 -s: 汇总目录总大小。 -c: 显示总计。 --max-depth=N: 限制目录深度。 场景: 检查磁盘占用、识别大文件/目录。 示例: du -sh /home/user: 显示家目录总大小。 du -h --max-depth=1 /var: 显示 /var 下子目录的占用情况。 du -hc *.log: 显示当前目录下 .log 文件的总大小。 df 功能: 显示文件系统的磁盘使用情况。 语法: df [选项] [文件系统] 常用选项: -h: 人类可读格式。 -T: 显示文件系统类型。 -i: 显示 inode 使用情况。 场景: 检查磁盘剩余空间、监控存储设备。 示例: df -h: 显示所有文件系统的磁盘使用情况。 df -T /home: 显示 /home 的文件系统类型和使用量。 9. 文件权限与属性 chmod 功能: 修改文件或目录的权限。 语法: chmod [选项] 权限 文件/目录 常用选项: -R: 递归修改目录及其内容。 -v: 显示修改过程。 权限表示: 数字表示（如 755: 所有者读/写/执行，组和其他读/执行）。 符号表示（如 u+x: 给所有者添加执行权限）。 场景: 设置文件访问权限，保护敏感数据。 示例: chmod 644 file.txt: 设置文件为所有者读写、其他读。 chmod -R 755 /web: 递归设置 /web 目录权限。 chmod u+x script.sh: 给 script.sh 的所有者添加执行权限。 chown 功能: 更改文件或目录的所有者和组。 语法: chown [选项] 用户[:组] 文件/目录 常用选项: -R: 递归更改目录及其内容。 -v: 显示更改过程。 --reference=文件: 使用参考文件的用户/组。 场景: 转移文件所有权、修复权限问题。 示例: sudo chown user1 file.txt: 将 file.txt 的所有者改为 user1。 sudo chown -R user1:group1 /data: 递归更改 /data 的所有者和组。 sudo chown --reference=file1 file2: 将 file2 的所有者/组设为与 file1 相同。 chgrp 功能: 更改文件或目录的所属组。 语法: chgrp [选项] 组 文件/目录 常用选项: -R: 递归更改。 -v: 显示更改过程。 场景: 调整文件所属组，管理团队访问权限。 示例: chgrp developers project: 将 project 的所属组改为 developers。 chgrp -R staff /shared: 递归更改 /shared 的组。 10. 文件查看与操作 cat 功能: 连接并显示文件内容，或创建文件。 语法: cat [选项] 文件 常用选项: -n: 显示行号。 -E: 显示行尾的 $ 符号。 -s: 压缩连续空行。 场景: 查看小文件内容、合并文件。 示例: cat file.txt: 显示 file.txt 内容。 cat file1.txt file2.txt &gt; combined.txt: 合并文件到 combined.txt。 cat -n log.txt: 显示 log.txt 带行号的内容。 less 功能: 分页查看文件内容，支持上下滚动。 语法: less [选项] 文件 常用选项: -N: 显示行号。 -S: 不换行显示长行。 -i: 忽略搜索大小写。 场景: 查看大文件、浏览日志。 示例: less /var/log/syslog: 分页查看系统日志。 less -N config.conf: 显示带行号的配置文件。 more 功能: 分页查看文件内容（较老，功能少于 less）。 语法: more [选项] 文件 常用选项: -d: 显示交互提示。 +num: 从第 num 行开始显示。 场景: 快速查看文件内容。 示例: more file.txt: 分页显示 file.txt。 more +50 log.txt: 从第 50 行开始显示。 head 功能: 显示文件开头几行（默认 10 行）。 语法: head [选项] 文件 常用选项: -n 行数: 指定显示行数。 -c 字节数: 显示指定字节数。 场景: 查看文件开头，检查日志或配置文件。 示例: head -n 5 file.txt: 显示 file.txt 前 5 行。 head -c 100 log.txt: 显示 log.txt 前 100 字节。 tail 功能: 显示文件末尾几行（默认 10 行）。 语法: tail [选项] 文件 常用选项: -n 行数: 指定显示行数。 -f: 实时监控文件变化。 场景: 监控日志文件、查看最新数据。 示例: tail -n 20 log.txt: 显示 log.txt 最后 20 行。 tail -f /var/log/syslog: 实时监控系统日志。 11. 其他高级命令 file 功能: 确定文件类型（如文本、二进制、目录）。 语法: file [选项] 文件 常用选项: -i: 输出 MIME 类型。 -b: 仅输出文件类型，不包括文件名。 场景: 识别文件格式，排查未知文件。 示例: file image.png: 显示 image.png 的类型（如 PNG image）。 file -i /bin/ls: 输出 /bin/ls 的 MIME 类型。 stat 功能: 显示文件或文件系统的详细状态信息（如时间戳、权限、inode）。 语法: stat [选项] 文件 常用选项: -f: 显示文件系统状态而非文件。 -c 格式: 自定义输出格式。 场景: 调试文件系统问题、查看元数据。 示例: stat file.txt: 显示 file.txt 的详细信息。 stat -c %s file.txt: 仅输出文件大小（字节）。 truncate 功能: 调整文件大小（扩展或截断）。 语法: truncate [选项] 文件 常用选项: -s 大小: 设置文件大小（如 +10M 扩展 10MB，-10M 减少 10MB）。 -c: 不创建不存在的文件。 场景: 创建固定大小文件、清理大文件内容。 示例: truncate -s 10M bigfile: 创建或调整 bigfile 为 10MB。 truncate -s 0 log.txt: 清空 log.txt。 2. 文件查看和编辑（File Viewing &amp; Editing） 1. 文件内容查看 这些命令用于快速查看文件内容，适合不同场景（如小文件、大文件、实时监控等）。 cat 功能: 连接并显示文件内容，或将多个文件内容合并输出，也可用于创建文件。 语法: cat [选项] [文件...] 常用选项: -n: 显示行号（包括空行）。 -b: 显示非空行号。 -E: 在行尾显示 $ 符号。 -s: 压缩连续空行为一空行。 -T: 显示制表符为 ^I。 场景: 查看小型文本文件内容（如配置文件）。 合并多个文件输出到终端或新文件。 通过重定向快速创建小文件。 示例: cat config.txt: 显示 config.txt 的内容。 cat -n log.txt: 显示 log.txt 内容并带行号。 cat file1.txt file2.txt &gt; combined.txt: 合并两个文件到 combined.txt。 cat &gt; newfile.txt: 接受用户输入创建新文件（按 Ctrl+D 保存退出）。 高级用法: 结合管道：cat access.log | grep &quot;error&quot;: 筛选包含 “error” 的行。 查看二进制文件（谨慎）：cat -v binaryfile 显示不可打印字符。 注意: 对于大文件，cat 一次性输出可能导致终端卡顿，建议使用 less 或 tail。 less 功能: 分页查看文件内容，支持上下滚动、前后搜索，适合大文件。 语法: less [选项] 文件 常用选项: -N: 显示行号。 -S: 不换行显示长行（水平滚动）。 -i: 搜索时忽略大小写。 -m: 显示类似 more 的百分比提示。 -F: 若文件较小，直接显示并退出。 场景: 浏览大型日志文件（如 /var/log/syslog）。 在配置文件中搜索特定内容。 查看长文档而无需加载全部内容。 交互键: 上下箭头或 j/k: 上下移动。 /关键字: 向前搜索。 ?关键字: 向后搜索。 q: 退出。 g/G: 跳到文件开头/结尾。 示例: less /var/log/syslog: 分页查看系统日志。 less -N config.conf: 显示带行号的配置文件。 less +/error log.txt: 打开文件并跳转到第一个 “error” 出现处。 高级用法: 实时监控：less +F log.txt（类似 tail -f，按 Ctrl+C 切换交互模式）。 多个文件：less file1.txt file2.txt，使用 :n 和 :p 切换文件。 注意: less 比 more 更强大，支持双向滚动和搜索。 more 功能: 分页查看文件内容，仅支持向下滚动，功能较 less 简单。 语法: more [选项] 文件 常用选项: -d: 显示交互提示（如按空格继续）。 +num: 从第 num 行开始显示。 -s: 压缩连续空行。 -p: 清屏后显示。 场景: 快速查看中小型文件内容。 在资源受限的系统上替代 less。 交互键: 空格: 下一页。 Enter: 下一行。 q: 退出。 /关键字: 搜索。 示例: more file.txt: 分页显示 file.txt。 more +50 log.txt: 从第 50 行开始显示。 more -s data.txt: 压缩空行后显示。 高级用法: 结合管道：ls -l | more: 分页显示目录列表。 注意: more 功能有限，推荐优先使用 less。 head 功能: 显示文件开头几行（默认 10 行），适合快速检查文件。 语法: head [选项] 文件 常用选项: -n 行数: 指定显示行数。 -c 字节数: 显示指定字节数。 -q: 多个文件时不显示文件名。 -v: 显示文件名标题。 场景: 查看日志或配置文件的开头。 提取 CSV 文件的表头。 示例: head -n 5 file.txt: 显示 file.txt 前 5 行。 head -c 100 log.txt: 显示 log.txt 前 100 字节。 head *.txt: 显示当前目录下所有 .txt 文件的前 10 行。 高级用法: 结合管道：head -n 1 data.csv | cut -d',' -f1: 提取 CSV 文件第一列的表头。 注意: 对于二进制文件，-c 选项更适合。 tail 功能: 显示文件末尾几行（默认 10 行），支持实时监控。 语法: tail [选项] 文件 常用选项: -n 行数: 指定显示行数。 -f: 实时监控文件变化（常用于日志）。 -F: 监控文件，即使文件被替换。 -c 字节数: 显示指定字节数。 场景: 实时监控日志文件（如服务器错误日志）。 查看文件最新内容。 示例: tail -n 20 log.txt: 显示 log.txt 最后 20 行。 tail -f /var/log/apache2/access.log: 实时监控 Apache 访问日志。 tail -c 500 data.bin: 显示 data.bin 最后 500 字节。 高级用法: 结合管道：tail -f log.txt | grep &quot;error&quot;: 实时筛选日志中的错误。 监控多个文件：tail -f file1.txt file2.txt: 显示多个文件尾部。 注意: 使用 -f 时，需按 Ctrl+C 退出监控。 2. 文件编辑 这些命令用于编辑文本文件，适合从简单修改到复杂脚本编写。 nano 功能: 简单、用户友好的终端文本编辑器，适合初学者。 语法: nano [选项] 文件 常用选项: -w: 禁用自动换行。 -i: 自动缩进。 -l: 显示行号。 -m: 启用鼠标支持（若终端支持）。 -B: 保存前备份文件。 场景: 编辑配置文件（如 /etc/apt/sources.list）。 快速修改小型脚本或文本文件。 交互键: Ctrl+O: 保存文件。 Ctrl+X: 退出。 Ctrl+W: 搜索。 Ctrl+\\: 替换。 Ctrl+G: 查看帮助。 示例: nano config.txt: 打开或创建 config.txt 进行编辑。 sudo nano -l /etc/fstab: 以 root 权限编辑文件系统表并显示行号。 nano -B script.sh: 编辑脚本并备份原文件。 高级用法: 语法高亮：nano 默认支持常见文件类型的高亮，可通过 ~/.nanorc 自定义。 打开特定行：nano +10 file.txt 直接跳转到第 10 行。 注意: nano 适合快速编辑，复杂任务建议使用 vim 或 IDE。 vim / vi 功能: 功能强大的终端文本编辑器，支持模式化操作，适合高级用户。 语法: vim [选项] 文件 常用选项: -R: 只读模式（等同于 view 命令）。 -o: 水平分割打开多个文件。 -O: 垂直分割打开多个文件。 +行号: 打开文件并跳转到指定行。 模式: 正常模式: 默认模式，用于导航和命令。 插入模式: 输入 i 进入，用于编辑文本。 命令模式: 输入 : 进入，用于执行命令（如 :w 保存，:q 退出）。 可视模式: 输入 v 或 V 进入，用于选择文本。 场景: 编辑复杂脚本、配置文件或代码。 批量文本处理（如搜索替换）。 常用命令: :w: 保存文件。 :q: 退出。 :wq 或 ZZ: 保存并退出。 /关键字: 搜索。 :%s/old/new/g: 全局替换 old 为 new。 dd: 删除当前行。 yy: 复制当前行。 p: 粘贴。 示例: vim script.py: 编辑 Python 脚本。 sudo vim -o /etc/file1 /etc/file2: 同时编辑两个配置文件。 vim +50 log.txt: 打开 log.txt 并跳转到第 50 行。 高级用法: 插件支持：通过 ~/.vimrc 配置插件（如语法高亮、自动补全）。 批量操作：vim file1 file2 并用 :n 切换文件。 宏录制：按 q 录制宏，重复复杂操作。 注意: 学习曲线较陡，建议初学者从 nano 开始，或使用 vimtutor 学习。 ed 功能: 经典行编辑器，功能简单，适合脚本或低资源环境。 语法: ed [选项] 文件 常用选项: -p 提示: 设置自定义提示符。 -s: 静默模式，减少输出。 场景: 在嵌入式系统或无 nano/vim 的环境中编辑文件。 脚本中自动化编辑。 常用命令: a: 追加文本。 w: 保存文件。 q: 退出。 ,p: 显示全部内容。 示例: ed file.txt: 打开 file.txt 进行行编辑。 echo -e &quot;1i\\nHello\\n.\\nw\\nq&quot; | ed file.txt: 插入 “Hello” 并保存。 高级用法: 脚本化编辑：ed file.txt &lt; script.ed 使用预定义命令编辑文件。 注意: ed 操作复杂，现代系统较少使用，推荐 nano 或 vim。 3. 文本输出与重定向 echo 功能: 输出文本到终端或文件，常用于脚本或创建简单内容。 语法: echo [选项] 字符串 常用选项: -n: 不添加换行符。 -e: 启用转义字符解释（如 \\n 表示换行）。 场景: 快速创建小文件。 在脚本中输出变量或提示。 示例: echo &quot;Hello World&quot; &gt; file.txt: 将文本写入 file.txt。 echo -e &quot;Line1\\nLine2&quot; &gt;&gt; file.txt: 追加两行到 file.txt。 echo $PATH: 显示环境变量 PATH。 高级用法: 结合管道：echo &quot;Error&quot; | tee -a log.txt: 输出到终端并追加到文件。 变量扩展：echo &quot;User: $USER&quot; &gt; user.txt: 写入当前用户名。 注意: 对于复杂输出，考虑使用 printf。 printf 功能: 格式化输出文本到终端或文件，支持复杂格式化。 语法: printf 格式字符串 [参数...] 常用选项: 格式占位符：%s（字符串）、%d（整数）、%f（浮点数）。 场景: 创建格式化配置文件。 在脚本中生成结构化输出。 示例: printf &quot;Name: %s, Age: %d\\n&quot; &quot;Alice&quot; 25: 输出格式化文本。 printf &quot;Value: %.2f\\n&quot; 3.14159 &gt; data.txt: 写入格式化浮点数。 高级用法: 循环输出：for i in &#123;1..3&#125;; do printf &quot;Item %d\\n&quot; $i; done 生成序列。 注意: printf 比 echo 更适合需要精确格式的场景。 4. 高级文本处理（部分重叠搜索/处理） 以下命令虽常用于文本处理，但也可用于查看和编辑场景。 tee 功能: 从标准输入读取数据，同时输出到终端和文件。 语法: tee [选项] 文件 常用选项: -a: 追加而非覆盖文件。 -i: 忽略中断信号。 场景: 保存命令输出到文件并同时查看。 在管道中记录中间结果。 示例: ls -l | tee dirlist.txt: 保存目录列表到 dirlist.txt 并显示。 echo &quot;Log entry&quot; | tee -a log.txt: 追加日志条目到 log.txt。 高级用法: 多文件输出：ls | tee file1.txt file2.txt: 写入多个文件。 结合 sudo：ls /root | sudo tee rootlist.txt: 保存受限目录列表。 注意: 需注意文件权限，尤其是使用 sudo 时。 sed 功能: 流编辑器，用于文本替换、删除、插入等操作。 语法: sed [选项] '命令' 文件 常用选项: -i: 直接修改原文件（建议备份）。 -e: 执行多个命令。 -r: 使用扩展正则表达式。 常用命令: s/old/new/g: 全局替换 old 为 new。 d: 删除匹配行。 p: 打印匹配行。 场景: 批量修改配置文件内容。 提取特定行或字段。 示例: sed 's/error/warning/g' log.txt: 将 log.txt 中的 “error” 替换为 “warning”。 sed -i.bak 's/old/new/' file.txt: 替换并备份原文件到 file.txt.bak。 sed '10,20d' data.txt: 删除第 10 到 20 行。 高级用法: 结合管道：cat config.txt | sed '/^#/d': 删除注释行。 多条件替换：sed -e 's/old1/new1/' -e 's/old2/new2/' file.txt。 注意: -i 修改文件不可恢复，建议测试后使用。 awk 功能: 文本处理工具，适合处理结构化数据（如 CSV、日志）。 语法: awk [选项] '程序' 文件 常用选项: -F 分隔符: 指定字段分隔符。 -v 变量=值: 定义变量。 常用程序: &#123;print $n&#125;: 打印第 n 列。 /模式/ &#123;动作&#125;: 对匹配模式执行动作。 场景: 提取日志或 CSV 文件的特定字段。 统计和格式化文本数据。 示例: awk -F',' '&#123;print $1&#125;' data.csv: 打印 CSV 文件第一列。 awk '/error/ &#123;print&#125;' log.txt: 打印包含 “error” 的行。 awk '&#123;sum+=$2&#125; END &#123;print sum&#125;' numbers.txt: 计算第二列总和。 高级用法: 复杂脚本：awk 'BEGIN &#123;print &quot;Start&quot;&#125; &#123;print $1&#125; END &#123;print &quot;End&quot;&#125;' file.txt。 结合管道：cat log.txt | awk '$3 &gt; 100 &#123;print&#125;': 筛选第三列大于 100 的行。 注意: awk 功能强大，适合数据处理，但学习曲线稍陡。 3. 权限管理（Permissions） 权限管理是 Linux 系统中确保安全和访问控制的核心功能，涉及文件和目录的所有者、所属组、访问权限（读、写、执行）以及特殊权限（如 setuid）。Ubuntu 使用基于用户（user）、组（group）和其他人（others）的权限模型，结合文件系统元数据实现访问控制。以下是与权限管理相关的核心命令及其详细说明。 1. 权限管理基础知识 在讲解命令之前，先简要介绍 Linux 文件权限模型，以便理解命令的作用： 权限组成： 用户（u）: 文件的所有者。 组（g）: 文件所属的组。 其他人（o）: 非所有者、非组成员的用户。 权限类型： r（读，read）：允许查看文件内容或列出目录。 w（写，write）：允许修改文件内容或在目录中创建/删除文件。 x（执行，execute）：允许运行文件（如脚本或二进制文件）或进入目录。 特殊权限： setuid（s）：以文件所有者身份执行（常见于 /usr/bin/passwd）。 setgid（s）：以文件所属组身份执行，或目录中新建文件继承父目录组。 sticky bit（t）：限制目录中文件的删除（仅限文件所有者或 root，如 /tmp）。 权限表示： 符号表示：如 rwxr-xr-x（用户读写执行，组和其他读执行）。 八进制表示：如 755（rwx=4+2+1=7, r-x=4+1=5）。 查看权限：使用 ls -l 查看文件权限，如：1-rwxr-xr-x 1 user group 1234 Sep 14 12:00 script.sh 第一个字符（- 表示文件，d 表示目录）。 接下来 9 个字符表示用户（rwx）、组（r-x）、其他（r-x）权限。 1 表示硬链接数，user 是所有者，group 是所属组。 2. 权限管理命令 2.1 chmod（Change Mode） 功能：修改文件或目录的访问权限（读、写、执行）及特殊权限。 语法： 1chmod [选项] 权限 文件/目录 常用选项： -R：递归修改目录及其内容。 -v：显示修改过程。 -c：仅显示更改的文件。 --reference=参考文件：使用参考文件的权限。 权限指定方式： 符号表示： 格式：[ugoa][+-=][rwxXst] u（用户）、g（组）、o（其他）、a（所有）。 +（添加）、-（移除）、=（设置）。 r（读）、w（写）、x（执行）、X（仅对目录或已有执行权限的文件添加执行）、s（setuid/setgid）、t（sticky bit）。 八进制表示： 读（4）、写（2）、执行（1），相加组成三位数。 如 755 表示 rwxr-xr-x，600 表示 rw-------。 场景： 设置脚本可执行权限。 保护敏感文件（如私钥）。 配置共享目录权限。 示例： chmod 644 file.txt：设置文件为所有者读写（rw-），组和其他只读（r--）。 chmod u+x script.sh：为所有者添加执行权限。 chmod -R 755 /web：递归设置 /web 目录及内容为 rwxr-xr-x。 chmod +t /tmp：为 /tmp 设置 sticky bit，限制非所有者删除文件。 chmod --reference=template.txt file.txt：将 file.txt 权限设为与 template.txt 相同。 高级用法： 设置特殊权限： chmod u+s /bin/program：设置 setuid，程序以所有者身份运行。 chmod g+s /shared：目录中新建文件继承 shared 组。 条件修改： chmod -R u+w,g-w,o-rwx /data：用户添加写权限，组移除写权限，其他移除所有权限。 结合 find：1find /path -type f -exec chmod 644 &#123;&#125; \\; 将目录下所有文件设为 644。 注意： 使用八进制更简洁，符号表示更灵活。 递归修改（-R）需谨慎，避免意外更改子目录权限。 特殊权限（如 setuid）可能引入安全风险，需仔细验证。 2.2 chown（Change Owner） 功能：更改文件或目录的所有者和/或所属组。 语法： 1chown [选项] 用户[:组] 文件/目录 常用选项： -R：递归更改目录及其内容。 -v：显示更改过程。 -c：仅显示更改的文件。 --reference=参考文件：使用参考文件的所有者/组。 --from=当前用户:当前组：仅更改匹配当前用户/组的文件。 参数： 用户：用户名或 UID（如 #1000）。 组：组名或 GID（如 #1000），可省略（如 chown user file）。 场景： 转移文件所有权（如将备份文件交给其他用户）。 修复错误的所有者/组设置。 配置共享目录的组访问。 示例： sudo chown user1 file.txt：将 file.txt 的所有者改为 user1。 sudo chown user1:group1 data.txt：设置所有者和组为 user1:group1。 sudo chown -R user1:group1 /data：递归更改 /data 的所有者和组。 sudo chown --reference=template.txt file.txt：将 file.txt 的所有者/组设为与 template.txt 相同。 sudo chown --from=user2:group2 user1:group1 file.txt：仅当文件属于 user2:group2 时更改。 高级用法： 结合 find：1find /path -type d -exec chown user1:group1 &#123;&#125; \\; 将目录下所有子目录的所有者和组改为 user1:group1。 只更改组：1chown :group1 file.txt 仅更改所属组。 注意： 通常需要 sudo 权限更改系统文件或非当前用户拥有的文件。 UID/GID 格式（如 #1000）需在某些 shell 中转义（如 \\#1000）。 递归操作（-R）需检查目标范围，避免影响无关文件。 2.3 chgrp（Change Group） 功能：更改文件或目录的所属组（功能是 chown 的子集）。 语法： 1chgrp [选项] 组 文件/目录 常用选项： -R：递归更改。 -v：显示更改过程。 -c：仅显示更改的文件。 --reference=参考文件：使用参考文件的组。 参数： 组：组名或 GID（如 #1000）。 场景： 设置共享目录的组权限（如团队协作目录）。 修复组分配错误。 示例： sudo chgrp developers project：将 project 的所属组改为 developers。 sudo chgrp -R staff /shared：递归更改 /shared 的组为 staff。 sudo chgrp --reference=template.txt file.txt：将 file.txt 的组设为与 template.txt 相同。 高级用法： 结合 find：1find /path -type f -exec chgrp users &#123;&#125; \\; 将目录下所有文件的组改为 users。 设置目录继承组：1chmod g+s /shared &amp;&amp; chgrp staff /shared 确保 /shared 中新建文件继承 staff 组。 注意： chgrp 是 chown 的简化版，推荐优先使用 chown :group。 需要 sudo 更改非当前用户组的文件。 2.4 setfacl（Set File Access Control List） 功能：设置访问控制列表（ACL），为文件或目录分配更细粒度的权限（如特定用户/组的权限）。 语法： 1setfacl [选项] -m|-x 规则 文件/目录 常用选项： -m：添加或修改 ACL 规则。 -x：删除指定 ACL 规则。 -R：递归应用。 -b：删除所有 ACL 规则。 --set：完全替换 ACL。 -d：设置默认 ACL（目录中新文件继承）。 规则格式： u:用户:权限：为特定用户设置权限（如 u:user1:rwx）。 g:组:权限：为特定组设置权限。 m:权限：设置掩码（限制 ACL 权限）。 o:权限：设置其他用户权限。 场景： 为特定用户/组设置权限，而不影响标准权限。 配置共享目录的复杂访问控制。 示例： setfacl -m u:user1:rw file.txt：为 user1 设置读写权限。 setfacl -R -m g:developers:rwx /project：为 developers 组递归设置读写执行权限。 setfacl -d -m u:user1:rwx /shared：目录中新文件默认授予 user1 读写执行权限。 setfacl -x u:user1 file.txt：移除 user1 的 ACL 权限。 setfacl -b file.txt：删除所有 ACL 规则。 查看 ACL： getfacl file.txt：显示 file.txt 的 ACL 信息。 高级用法： 结合标准权限：1chmod 700 /data &amp;&amp; setfacl -m u:user1:rwx /data 限制目录仅限所有者和 user1 访问。 递归恢复默认 ACL：1setfacl -R -m d:g:staff:rwx /shared 确保目录及子目录新文件继承 staff 组权限。 注意： 需要文件系统支持 ACL（如 ext4，需启用 acl 挂载选项）。 安装 ACL 工具：sudo apt install acl。 ACL 与标准权限（chmod）共存，掩码（mask）可能限制 ACL 权限。 2.5 umask（User Mask） 功能：设置新建文件和目录的默认权限掩码，影响默认权限（文件默认 666，目录默认 777）。 语法： 1umask [掩码] 掩码格式： 八进制值，如 022（从默认权限减去掩码）。 结果：文件权限为 666 - umask，目录为 777 - umask。 如 umask 022，新建文件为 644（rw-r--r--），目录为 755（rwxr-xr-x）。 场景： 控制用户或脚本创建文件/目录的默认权限。 确保共享目录的安全性。 示例： umask 022：设置掩码，新建文件为 644，目录为 755。 umask 077：新建文件为 600（rw-------），目录为 700（rwx------）。 查看当前掩码：1umask 输出如 0022。 符号表示：1umask u=rwx,g=rx,o=rx 等同于 022。 高级用法： 在 shell 配置文件（如 ~/.bashrc）设置默认 umask：1echo &quot;umask 027&quot; &gt;&gt; ~/.bashrc 新建文件为 640（rw-r-----），目录为 750（rwxr-x---）。 临时修改：1umask 002 &amp;&amp; touch file.txt 创建 file.txt 为 664（rw-rw-r--）。 注意： umask 仅影响新文件/目录，不修改现有文件。 系统默认 umask 通常为 022（普通用户）或 002（共享环境）。 检查 /etc/login.defs 或 /etc/profile 中的全局 umask 设置。 2.6 sudo（与权限管理相关） 功能：以其他用户（通常 root）身份执行命令，间接管理权限敏感操作。 语法（参考前文提供的 sudo_manual.txt 翻译）： 1sudo [选项] 命令 与权限管理相关选项： -u 用户：以指定用户身份运行命令。 -g 组：以指定组身份运行命令。 -e（sudoedit）：编辑文件，保留调用者环境。 场景： 修改系统文件（如 /etc/fstab）的权限。 更改受限文件的所有者或组。 示例： sudo chmod 600 /etc/shadow：设置影子文件仅 root 可读写。 sudo chown root:root /etc/passwd：确保密码文件由 root 拥有。 sudo -u user1 touch /home/user1/file.txt：以 user1 身份创建文件。 高级用法： 编辑受限文件：1sudoedit /etc/nginx/nginx.conf 使用用户编辑器编辑配置文件。 结合 chown：1sudo -u user1 chown user1:group1 /home/user1/data 以 user1 身份更改文件所有者。 注意： sudo 需要在 /etc/sudoers 中配置权限，建议用 visudo 编辑。 滥用 sudo 可能导致安全风险，需谨慎配置。 3. 使用场景与示例 以下是权限管理命令在实际任务中的应用： 保护敏感文件： 设置私钥文件仅所有者可读：12chmod 600 ~/.ssh/id_rsachown user1 ~/.ssh/id_rsa 确保只有 root 访问影子文件：12sudo chmod 600 /etc/shadowsudo chown root:shadow /etc/shadow 配置共享目录： 创建团队共享目录，组内可读写：1234sudo mkdir /sharedsudo chown :developers /sharedsudo chmod 770 /sharedsudo chmod g+s /shared 新文件继承 developers 组。 细粒度权限控制： 允许特定用户访问目录：12sudo setfacl -m u:user1:rwx /datagetfacl /data 设置目录默认 ACL：1sudo setfacl -d -m g:staff:rwx /shared 修复权限错误： 批量恢复 /var/log 权限：123sudo find /var/log -type f -exec chmod 644 &#123;&#125; \\;sudo find /var/log -type d -exec chmod 755 &#123;&#125; \\;sudo chown -R root:adm /var/log 控制默认权限： 设置用户默认创建文件为 640：123echo &quot;umask 027&quot; &gt;&gt; ~/.bashrcsource ~/.bashrctouch newfile.txt # 权限为 rw-r----- 4. 高级用法 自动化权限管理： 使用脚本批量设置权限：1234#!/bin/bashfind /data -type f -exec chmod 644 &#123;&#125; \\;find /data -type d -exec chmod 755 &#123;&#125; \\;chown -R user1:group1 /data 保存为 set_permissions.sh，运行 bash set_permissions.sh。 ACL 与标准权限结合： 限制目录访问，但允许特定用户：12chmod 700 /privatesetfacl -m u:user1:rwx /private 监控权限变化： 使用 inotifywait（需安装 inotify-tools）监控权限变化：12sudo apt install inotify-toolsinotifywait -m /data -e attrib 结合 sudoers 限制权限操作： 编辑 /etc/sudoers 限制用户只能运行特定权限命令：1user1 ALL=(ALL) /bin/chmod, /bin/chown 允许 user1 使用 sudo chmod 和 sudo chown。 5. 注意事项与扩展 权限安全： 避免为非必要文件设置 setuid 或 setgid，防止提权漏洞。 定期检查敏感文件权限（如 /etc/shadow、~/.ssh/*）。 使用 ls -l 或 getfacl 验证权限设置。 递归操作风险： chmod -R、chown -R 等需明确路径，避免影响系统文件。 测试前备份：cp -r /dir /dir.bak。 ACL 支持： 确保文件系统支持 ACL（检查 /etc/fstab 是否有 acl 选项）。 使用 tune2fs -o acl /dev/sdX 启用 ACL（需谨慎）。 学习资源： 查看手册：man chmod, man chown, man setfacl, man umask。 安装 tldr（sudo apt install tldr）获取简明示例。 在线教程：如 Ubuntu 社区文档或 DigitalOcean 的权限管理指南。 相关工具： lsattr / chattr：管理文件属性（如不可变文件）。12sudo chattr +i file.txt # 设为不可修改lsattr file.txt getfacl：查看 ACL 信息。 stat：查看文件元数据（包括权限、所有者）。1stat -c &quot;%A %U %G&quot; file.txt 4. 进程管理（Process Management） 进程管理是 Linux 系统中监控和控制运行程序（进程）的关键任务，涉及查看进程状态、调整优先级、终止进程、后台运行等操作。Ubuntu 的进程管理工具提供了从简单查看（如 ps）到复杂监控（如 htop）的功能，适合系统管理员、开发者和普通用户。以下按功能分类讲解相关命令。 1. 进程查看与监控 这些命令用于查看运行中的进程、资源使用情况和系统状态。 1.1 ps（Process Status） 功能：显示当前系统进程的快照，列出进程 ID（PID）、用户、命令等信息。 语法： 1ps [选项] 常用选项： -e 或 aux：显示所有进程（包括其他用户的）。 -u 用户：显示指定用户的进程。 -f：显示完整格式（包括 PPID、启动时间等）。 -p PID：显示指定 PID 的进程。 --forest：以树状结构显示进程层次。 -o 字段：自定义输出字段（如 pid,comm,%cpu）。 场景： 检查特定进程是否运行。 查看进程的父子关系。 获取进程详细信息（如 CPU/内存使用）。 示例： ps aux：列出所有进程，包含用户、PID、CPU/内存使用等。12USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDuser1 1234 0.0 0.1 123456 7890 pts/0 S 12:00 0:01 bash ps -u user1：显示 user1 用户的进程。 ps -ef --forest：显示进程树，查看父子关系。 ps -p 1234 -o pid,comm：显示 PID 为 1234 的进程名称。 高级用法： 结合 grep 筛选：1ps aux | grep firefox 查找 Firefox 进程。 自定义输出：1ps -eo pid,ppid,%cpu,comm --sort=-%cpu 按 CPU 使用率降序显示进程。 注意： ps aux 是 BSD 风格，ps -ef 是 System V 风格，输出格式略有不同。 输出可能较多，建议结合 less 或 grep 过滤。 1.2 top 功能：实时显示系统进程状态，包括 CPU、内存使用、进程列表等。 语法： 1top [选项] 常用选项： -d 秒：设置刷新间隔（默认 3 秒）。 -p PID：仅监控指定 PID。 -u 用户：显示指定用户的进程。 交互键： q：退出。 k：输入 PID 终止进程。 r：输入 PID 修改进程优先级（nice 值）。 f：进入字段管理，选择显示列。 P：按 CPU 使用排序。 M：按内存使用排序。 场景： 实时监控系统负载和进程资源使用。 识别占用 CPU/内存过高的进程。 示例： top：启动实时监控。 top -d 1：每秒刷新进程状态。 top -u user1：仅显示 user1 的进程。 高级用法： 保存快照：1top -b -n 1 &gt; top_output.txt 运行一次并保存输出（批处理模式）。 监控特定进程：1top -p 1234 注意： top 是交互式工具，适合手动监控。 对于更现代化的界面，推荐使用 htop。 1.3 htop 功能：增强版的 top，提供彩色界面、交互式操作和直观显示（需安装 sudo apt install htop）。 语法： 1htop [选项] 常用选项： -d 秒：设置刷新间隔。 -u 用户：仅显示指定用户的进程。 -s 列：按指定列排序（如 CPU、MEM）。 交互键： F2：配置界面（调整显示列）。 F3 或 /：搜索进程。 F5：显示进程树。 F9：终止进程（选择信号）。 F7/F8：降低/提高进程优先级（nice 值）。 q：退出。 场景： 直观监控系统性能。 快速终止或调整进程优先级。 示例： htop：启动交互界面。 htop -u user1：显示 user1 的进程。 htop -s PERCENT_CPU：按 CPU 使用率排序。 高级用法： 筛选进程： 按 F3 输入关键字（如 “python”）过滤。 批量操作： 使用 F7/F8 调整多个进程优先级。 注意： htop 需要安装，默认不包含在 Ubuntu 中。 比 top 更用户友好，支持鼠标操作。 1.4 pstree 功能：以树状结构显示进程层次关系，突出父子进程。 语法： 1pstree [选项] [PID|用户] 常用选项： -p：显示 PID。 -u：显示用户转换（当进程切换用户时）。 -a：显示命令行参数。 -h：高亮当前用户的进程。 场景： 查看进程的父子关系（如服务进程的子进程）。 分析复杂进程结构。 示例： pstree：显示所有进程树。 pstree -p user1：显示 user1 的进程树，包含 PID。 pstree -a 1234：显示 PID 为 1234 的进程及其子进程的命令行。 高级用法： 结合 grep：1pstree -a | grep apache 查看 Apache 相关的进程树。 注意： 输出可能较长，建议结合 less 查看。 2. 进程控制 这些命令用于控制进程的运行状态，如终止、暂停、调整优先级等。 2.1 kill 功能：向指定进程发送信号（默认 SIGTERM）以终止或控制其行为。 语法： 1kill [选项] PID... 常用选项： -信号：指定信号编号或名称（如 -9 或 -SIGKILL）。 -l：列出支持的信号。 常用信号： 1（SIGHUP）：重新加载配置（常用于服务）。 2（SIGINT）：中断进程（类似 Ctrl+C）。 9（SIGKILL）：强制终止（不可捕获）。 15（SIGTERM）：优雅终止（默认）。 场景： 终止无响应的进程。 重新加载服务配置。 示例： kill 1234：向 PID 1234 发送 SIGTERM。 kill -9 1234：强制终止 PID 1234。 kill -HUP 5678：使 PID 5678 重新加载配置。 kill -l：列出所有信号名称。 高级用法： 批量终止：1kill $(pgrep firefox) 终止所有 Firefox 进程。 结合 ps：1ps aux | grep python | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill 终止所有 Python 进程。 注意： SIGKILL（-9）不可捕获，可能导致数据丢失，优先使用 SIGTERM。 需确保 PID 正确，避免误杀系统进程。 2.2 killall 功能：按进程名称（而非 PID）发送信号终止进程。 语法： 1killall [选项] 进程名 常用选项： -i：交互式，逐个确认。 -u 用户：终止指定用户的进程。 -s 信号：指定信号（如 -s SIGKILL）。 场景： 快速终止所有同名进程（如停止所有 apache2 实例）。 清理用户会话中的进程。 示例： killall firefox：终止所有 Firefox 进程。 killall -u user1：终止 user1 的所有进程。 killall -i python：交互式终止 Python 进程。 高级用法： 结合信号：1killall -s SIGHUP nginx 重新加载 Nginx 配置。 注意： 进程名需精确匹配，避免终止无关进程。 需要 sudo 终止非当前用户的进程。 2.3 pkill 功能：按进程名、用户或其他属性发送信号，类似 killall 但更灵活。 语法： 1pkill [选项] 模式 常用选项： -u 用户：匹配指定用户的进程。 -f：匹配完整命令行（而非仅进程名）。 -signal：指定信号（如 -9）。 场景： 按模式终止进程（如正则匹配）。 清理特定用户的进程。 示例： pkill firefox：终止所有 Firefox 进程。 pkill -u user1：终止 user1 的所有进程。 pkill -f &quot;python script.py&quot;：终止运行 script.py 的 Python 进程。 高级用法： 按正则匹配：1pkill -f &quot;.*python.*&quot; 终止所有包含 “python” 的进程。 注意： -f 选项可能匹配过多，需谨慎使用。 建议先用 pgrep 验证匹配的进程。 2.4 pgrep 功能：查找匹配进程名或其他属性的进程 PID。 语法： 1pgrep [选项] 模式 常用选项： -u 用户：匹配指定用户的进程。 -f：匹配完整命令行。 -l：显示 PID 和进程名。 -c：输出匹配进程数量。 场景： 获取进程 PID 供 kill 或其他命令使用。 检查特定进程是否运行。 示例： pgrep firefox：输出所有 Firefox 进程的 PID。 pgrep -l python：显示 Python 进程的 PID 和名称。 pgrep -u user1：列出 user1 的进程 PID。 pgrep -c apache2：统计 Apache2 进程数量。 高级用法： 结合 kill：1pgrep nginx | xargs kill -HUP 重新加载所有 Nginx 进程。 注意： 模式是正则表达式，需避免匹配无关进程。 使用 -f 时需精确匹配命令行。 3. 进程优先级与调度 这些命令用于调整进程的优先级和调度行为。 3.1 nice 功能：设置新启动进程的优先级（nice 值，范围 -20 到 19，值越大优先级越低）。 语法： 1nice [选项] 命令 常用选项： -n 值：设置 nice 值（默认 +10）。 场景： 降低后台任务的优先级，减少对系统的干扰。 为关键任务设置高优先级。 示例： nice -n 10 backup.sh：以 nice 值 10 运行备份脚本。 nice -n -5 critical_task：以高优先级（-5）运行任务（需 sudo）。 高级用法： 结合 sudo：1sudo nice -n -10 service start 以高优先级启动服务。 注意： 普通用户只能增加 nice 值（降低优先级），降低 nice 值需 sudo。 nice 值影响 CPU 调度，非实时优先级。 3.2 renice 功能：修改运行中进程的 nice 值。 语法： 1renice 值 -p PID 常用选项： -p PID：指定进程 PID。 -u 用户：修改指定用户的所有进程。 -g 组：修改指定组的进程。 场景： 调整正在运行的进程优先级。 优化系统资源分配。 示例： renice 10 -p 1234：将 PID 1234 的 nice 值设为 10。 sudo renice -5 -u user1：将 user1 的所有进程优先级设为 -5。 高级用法： 批量调整：1renice 15 -p $(pgrep python) 降低所有 Python 进程的优先级。 注意： 降低 nice 值（提高优先级）需 sudo。 调整优先级对 I/O 密集型任务影响有限。 4. 后台与作业控制 这些命令用于管理前台/后台进程和 shell 作业。 4.1 bg 功能：将暂停的作业移到后台运行。 语法： 1bg [作业ID] 场景： 恢复暂停的进程（如 Ctrl+Z 暂停的程序）。 在终端运行长时间任务。 示例： 运行脚本并暂停：123sleep 1000# 按 Ctrl+Z 暂停bg 将 sleep 移到后台运行。 指定作业：1bg %1 恢复作业 ID 为 1 的进程。 高级用法： 查看作业：1jobs 显示当前 shell 的作业列表。 注意： 作业 ID 通过 jobs 查看。 后台进程断开终端后可能终止（除非使用 nohup 或 disown）。 4.2 fg 功能：将后台或暂停的作业移到前台运行。 语法： 1fg [作业ID] 场景： 恢复后台进程以交互。 继续暂停的任务。 示例： fg %1：将作业 ID 1 移到前台。 暂停后恢复：123sleep 1000# 按 Ctrl+Zfg 高级用法： 结合 jobs：12jobsfg %2 查看并恢复特定作业。 注意： 前台进程会占用终端，直到完成或再次暂停。 4.3 nohup 功能：使进程在终端断开后继续运行，忽略挂起信号（SIGHUP）。 语法： 1nohup 命令 [参数] &amp; 常用选项： 输出默认写入 nohup.out。 场景： 运行长时间任务（如备份、编译），即使终端关闭。 远程 SSH 会话中保持进程运行。 示例： nohup python script.py &amp;：后台运行 Python 脚本，输出到 nohup.out。 nohup backup.sh &gt; backup.log 2&gt;&amp;1 &amp;：重定向输出到 backup.log。 高级用法： 结合 nice：1nohup nice -n 10 long_task.sh &amp; 以低优先级运行后台任务。 注意： 进程仍在后台运行，需用 ps 或 jobs 检查。 建议重定向输出，避免 nohup.out 过大。 4.4 disown 功能：从当前 shell 的作业表中移除进程，使其不受终端关闭影响。 语法： 1disown [选项] [作业ID] 常用选项： -h：保持作业接收 SIGHUP。 -a：移除所有作业。 场景： 防止后台进程因终端关闭而终止。 清理 shell 作业表。 示例： sleep 1000 &amp; 后：1disown %1 移除作业 ID 1，终端关闭后继续运行。 disown -a：移除所有后台作业。 高级用法： 结合 nohup：1nohup sleep 1000 &amp; disown 确保进程完全独立。 注意： disown 不重定向输出，建议结合 &gt; file。 5. 使用场景与示例 以下是进程管理命令在实际任务中的应用： 监控高负载进程： 查找占用 CPU 最高的进程：123top# 按 P 排序，或：ps -eo pid,comm,%cpu --sort=-%cpu | head 使用 htop 筛选：1htop -s PERCENT_CPU 终止无响应进程： 查找并终止 Firefox：12pgrep firefoxkillall firefox 强制终止：1pkill -9 -f firefox 管理后台任务： 运行长时间备份：12nohup tar -czf backup.tar.gz /data &gt; backup.log 2&gt;&amp;1 &amp;disown 检查后台进程：12jobsps aux | grep tar 调整进程优先级： 降低编译任务优先级：1nice -n 15 make 提高数据库进程优先级：1sudo renice -10 -p $(pgrep mysqld) 分析进程树： 查看 Nginx 进程结构：1pstree -a -p nginx 6. 高级用法 自动化进程管理： 脚本监控进程并重启：12345#!/bin/bashif ! pgrep -f &quot;myapp&quot; &gt; /dev/null; then nohup /path/to/myapp &amp; echo &quot;Restarted myapp&quot;fi 保存为 monitor.sh，用 crontab 定时运行。 实时监控： 使用 watch 动态查看：1watch -n 1 &#x27;ps -eo pid,comm,%cpu --sort=-%cpu | head -5&#x27; 每秒显示 CPU 使用最高的 5 个进程。 进程信号处理： 优雅重启服务：1kill -HUP $(pgrep nginx) 结合 systemd： 管理服务进程：12sudo systemctl restart apache2systemctl status apache2 查看服务状态和日志。 7. 注意事项与扩展 安全提示： 避免随意使用 kill -9，可能导致数据丢失或系统不稳定。 终止系统进程（如 init 或 systemd）需谨慎。 修改优先级或终止其他用户进程需 sudo。 性能优化： 大量进程时，使用 pgrep 或 htop 替代 ps aux | grep。 实时监控大文件日志可能影响性能，建议用 tail -f 结合 grep。 相关工具： systemctl：管理 systemd 服务进程。1sudo systemctl stop nginx lsof：查看进程打开的文件。1lsof -p 1234 strace：跟踪进程系统调用。1strace -p 1234 pidstat（需安装 sysstat）：监控进程资源使用。1pidstat -p 1234 1 学习资源： 查看手册：man ps, man kill, man htop。 安装 tldr（sudo apt install tldr）获取简明示例。 在线教程：如 Ubuntu 社区文档或 DigitalOcean 的进程管理指南。 高级替代工具： btop：更现代化的 htop 替代（需安装）。 glances：系统监控工具，包含进程管理。12sudo apt install glancesglances 5. 系统信息和监控（System Information） 系统信息和监控是 Ubuntu/Linux 系统中用于了解系统状态、硬件配置、资源使用和性能瓶颈的关键任务。这些命令帮助管理员和用户诊断问题、优化性能并确保系统稳定。以下按功能分类讲解相关命令，涵盖硬件信息、系统状态、资源监控和日志分析。 1. 系统硬件信息 这些命令用于查看 CPU、内存、磁盘、设备等硬件信息。 1.1 lscpu 功能：显示 CPU 架构和详细信息，如核心数、频率、架构等。 语法： 1lscpu [选项] 常用选项： -p：以机器可读格式输出（适合脚本）。 -e：显示扩展信息（如每核状态）。 -c：仅显示在线 CPU。 场景： 检查 CPU 核心数和虚拟化支持。 分析多核系统性能。 示例： lscpu：显示 CPU 详细信息。123456Architecture: x86_64CPU(s): 8Thread(s) per core: 2Core(s) per socket: 4Vendor ID: GenuineIntelModel name: Intel(R) Core(TM) i7-9700 lscpu -p：输出机器可读格式，适合脚本解析。 lscpu -e：显示每核详细信息。 高级用法： 检查虚拟化支持：1lscpu | grep Virtualization 统计 CPU 核心：1lscpu | grep &quot;^CPU(s):&quot; 注意： 输出依赖于 /proc/cpuinfo，确保权限正常。 虚拟机中可能显示虚拟 CPU 而非物理 CPU。 1.2 lsmem 功能：显示系统内存信息，包括总量、可用量和内存块状态。 语法： 1lsmem [选项] 常用选项： -s：以人类可读格式显示（如 MB、GB）。 -a：显示所有内存块（包括离线）。 场景： 检查内存分配和 NUMA 架构。 诊断内存不足问题。 示例： lsmem：显示内存状态。123RANGE SIZE STATE REMOVABLE BLOCK0x0000000000000000-0x00000000ffffffff 4G online yes 0-31Total online memory: 4G lsmem -s：以 GB 显示内存信息。 高级用法： 结合 free：1lsmem | grep &quot;Total online&quot; &amp;&amp; free -h 对比内存总量和使用情况。 注意： 需要 util-linux 包支持（默认安装）。 NUMA 系统可能显示复杂内存分布。 1.3 lsblk 功能：列出块设备（如硬盘、SSD、USB）及其分区信息。 语法： 1lsblk [选项] 常用选项： -a：显示所有设备（包括空设备）。 -f：显示文件系统类型（如 ext4、ntfs）。 -o 字段：自定义输出（如 NAME,SIZE,FSTYPE）。 -p：显示完整设备路径（如 /dev/sda）。 场景： 检查磁盘分区和挂载点。 识别新插入的存储设备。 示例： lsblk：列出所有块设备。1234NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsda 8:0 0 500G 0 disk├─sda1 8:1 0 100G 0 part /boot└─sda2 8:2 0 400G 0 part / lsblk -f：显示文件系统和挂载点。 lsblk -o NAME,SIZE,TYPE：仅显示设备名、大小和类型。 高级用法： 筛选未挂载分区：1lsblk -f | grep -v &quot;[SWAP]\\|/&quot; 检查 USB 设备：1lsblk -p | grep /dev/sd[b-z] 注意： 需要 sudo 查看某些受限设备。 配合 fdisk 或 parted 管理分区。 1.4 lshw 功能：列出系统硬件详细信息，包括 CPU、内存、磁盘、网络等（需安装 sudo apt install lshw）。 语法： 1lshw [选项] 常用选项： -C 类：显示特定硬件类别（如 cpu、memory、disk）。 -short：简洁输出。 -html：输出 HTML 格式。 场景： 收集硬件清单（如服务器审计）。 诊断硬件兼容性问题。 示例： sudo lshw：显示完整硬件信息。 sudo lshw -C cpu：显示 CPU 详情。12345678*-cpu description: CPU product: Intel(R) Core(TM) i7-9700 vendor: Intel Corp. physical id: 4 bus info: cpu@0 size: 3600MHz capacity: 4600MHz sudo lshw -short：简洁硬件概览。 高级用法： 输出到文件：1sudo lshw -html &gt; hardware.html 筛选网络设备：1sudo lshw -C network 注意： 需要 sudo 获取完整信息。 输出较详细，建议结合 grep 或 less。 1.5 dmidecode 功能：读取 DMI/SMBIOS 信息，显示硬件细节（如 BIOS、主板、内存）。 语法： 1dmidecode [选项] 常用选项： -t 类型：指定类型（如 bios、memory、processor）。 -s 关键字：提取特定字段（如 bios-version）。 场景： 检查 BIOS 版本或硬件序列号。 验证服务器硬件规格。 示例： sudo dmidecode -t processor：显示 CPU 信息。 sudo dmidecode -s bios-version：显示 BIOS 版本。11.2.3 sudo dmidecode -t memory：显示内存条信息。 高级用法： 提取主板信息：1sudo dmidecode -t baseboard 结合脚本：1sudo dmidecode -s system-serial-number &gt; serial.txt 注意： 需要 sudo 访问硬件信息。 某些虚拟机可能无法获取完整 DMI 数据。 2. 系统资源监控 这些命令用于监控 CPU、内存、磁盘和网络的实时使用情况。 2.1 free 功能：显示系统内存和交换空间的使用情况。 语法： 1free [选项] 常用选项： -h：人类可读格式（如 GB、MB）。 -s 秒：每隔几秒刷新。 -m：以 MB 显示。 -t：显示总计行。 场景： 检查可用内存。 诊断内存泄漏或高负载。 示例： free -h：显示内存使用情况。123 total used free shared buff/cache availableMem: 7.8Gi 2.5Gi 3.2Gi 0.1Gi 2.0Gi 5.0GiSwap: 2.0Gi 0.0Gi 2.0Gi free -s 2：每 2 秒刷新内存状态。 free -mt：以 MB 显示并包含总计。 高级用法： 结合 watch：1watch -n 1 free -h 每秒刷新内存状态。 检查低内存：1free -h | grep Mem | awk &#x27;&#123;print $7&#125;&#x27; # 输出 available 内存 注意： available 比 free 更准确反映可用内存。 高 buff/cache 通常正常（Linux 缓存机制）。 2.2 vmstat 功能：报告虚拟内存、进程、CPU 和 I/O 统计信息。 语法： 1vmstat [选项] [间隔 [次数]] 常用选项： -s：显示详细统计表。 -m：显示内存 slab 信息。 -d：显示磁盘统计。 -t：添加时间戳。 场景： 监控内存交换和 CPU 活动。 分析 I/O 瓶颈。 示例： vmstat 2：每 2 秒刷新统计。123procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 3200000 200000 1800000 0 0 0 0 100 200 10 5 85 0 0 vmstat -s：显示内存统计表。 vmstat -d：显示磁盘读写统计。 高级用法： 监控 I/O 瓶颈：1vmstat -t 1 | grep -v procs 每秒显示带时间戳的统计。 注意： si/so（swap in/out）高表示内存压力，可能需增加 RAM。 需要结合其他工具（如 iostat）分析具体问题。 2.3 iostat 功能：报告 CPU 和 I/O（磁盘、网络）统计信息（需安装 sudo apt install sysstat）。 语法： 1iostat [选项] [间隔 [次数]] 常用选项： -c：仅显示 CPU 统计。 -d：仅显示磁盘统计。 -x：显示扩展统计（如设备利用率）。 -h：人类可读格式。 场景： 分析磁盘读写性能。 检查 CPU 负载分布。 示例： iostat：显示 CPU 和磁盘概览。1234avg-cpu: %user %nice %system %iowait %steal %idle 10.00 0.00 5.00 0.10 0.00 84.90Device tps kB_read/s kB_wrtn/s kB_read kB_wrtnsda 5.00 100.00 50.00 100000 50000 iostat -x 2：每 2 秒显示扩展磁盘统计。 iostat -c：仅显示 CPU 统计。 高级用法： 监控特定设备：1iostat -x /dev/sda 1 结合 grep：1iostat -x | grep sda 注意： 需要 sysstat 包支持。 高 %iowait 表示磁盘 I/O 瓶颈。 2.4 top 功能：实时显示系统进程状态、CPU 和内存使用情况（已在进程管理中介绍，此处侧重系统监控）。 语法： 1top [选项] 常用选项： -d 秒：设置刷新间隔。 -b：批处理模式（输出到文件）。 -n 次数：运行指定次数后退出。 场景： 实时监控系统负载。 识别高资源占用进程。 示例： top：启动实时监控。 top -b -n 1 &gt; top_output.txt：保存一次快照。 高级用法： 筛选用户进程：1top -u user1 动态调整显示： 按 f 进入字段管理，添加 %CPU 或 MEM 列。 注意： 按 1 显示每个 CPU 核心的负载。 适合交互式监控，脚本中建议用 vmstat 或 iostat。 2.5 htop 功能：增强版 top，提供彩色界面和交互式监控（需安装 sudo apt install htop）。 语法： 1htop [选项] 常用选项： -d 秒：设置刷新间隔。 -s 列：按指定列排序（如 CPU、MEM）。 场景： 直观查看系统资源使用。 快速调整进程优先级或终止进程。 示例： htop：启动交互界面。 htop -s PERCENT_CPU：按 CPU 使用率排序。 高级用法： 过滤进程： 按 F3 输入关键字（如 “apache”）。 导出数据：1htop --tree &gt; htop_output.txt 注意： 比 top 更直观，支持鼠标操作。 建议安装以替换 top。 3. 磁盘与文件系统监控 这些命令用于检查磁盘使用量和文件系统状态。 3.1 df 功能：显示文件系统的磁盘使用情况。 语法： 1df [选项] [文件系统] 常用选项： -h：人类可读格式（如 GB、MB）。 -T：显示文件系统类型（如 ext4）。 -i：显示 inode 使用情况。 --output=字段：自定义输出（如 source,fstype,used,avail）。 场景： 检查磁盘剩余空间。 验证挂载点状态。 示例： df -h：显示磁盘使用情况。123Filesystem Size Used Avail Use% Mounted on/dev/sda2 400G 200G 180G 53% //dev/sda1 100G 10G 90G 10% /boot df -T /home：显示 /home 的文件系统类型。 df -i：检查 inode 使用情况。 高级用法： 筛选特定挂载点：1df -h --output=source,avail / | grep /dev 监控磁盘满载：1watch -n 5 &#x27;df -h /&#x27; 注意： inode 耗尽可能导致无法创建新文件，即使磁盘有空间。 需 sudo 查看某些受限文件系统。 3.2 du 功能：计算目录或文件的磁盘使用量。 语法： 1du [选项] [路径] 常用选项： -h：人类可读格式。 -s：汇总目录总大小。 -c：显示总计。 --max-depth=N：限制目录深度。 场景： 查找占用磁盘空间大的目录。 清理无用文件。 示例： du -sh /home/user：显示用户家目录总大小。12.5G /home/user du -h --max-depth=1 /var：显示 /var 下子目录大小。 du -hc *.log：统计当前目录下 .log 文件的总大小。 高级用法： 排序大文件：1du -h /var | sort -hr | head -n 10 显示 /var 下占用空间最大的 10 个目录。 结合 find：1find / -type d -exec du -sh &#123;&#125; \\; | sort -hr 注意： 递归扫描可能较慢，建议指定路径。 需 sudo 访问受限目录。 4. 网络监控 这些 commands monitor network interfaces and traffic. 4.1 ifconfig（或 ip） 功能：显示和配置网络接口信息（ifconfig 可能需安装 sudo apt install net-tools）。 语法： 12ifconfig [接口]ip addr 常用选项（ifconfig）： -a：显示所有接口（包括未激活的）。 常用选项（ip）： ip addr show：显示网络接口。 ip -s link：显示接口统计。 场景： 检查网络接口的 IP 地址和状态。 诊断网络连接问题。 示例： ifconfig：显示活动接口。12eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 ip addr：显示所有接口信息。 ip -s link：显示接口流量统计。 高级用法： 筛选特定接口：1ip addr show eth0 监控流量：1watch -n 1 &#x27;ip -s link&#x27; 注意： ip 是现代替代工具，ifconfig 可能在某些系统上不可用。 需要 sudo 配置接口。 4.2 netstat（需安装 sudo apt install net-tools） 功能：显示网络连接、路由表和接口统计。 语法： 1netstat [选项] 常用选项： -a：显示所有连接（包括监听）。 -t：显示 TCP 连接。 -u：显示 UDP 连接。 -p：显示关联进程。 -n：显示数字地址（不解析 DNS）。 场景： 检查开放端口和连接状态。 识别网络服务进程。 示例： netstat -tuln：显示监听的 TCP/UDP 端口。12Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN netstat -ap：显示连接和关联进程。 高级用法： 筛选特定端口：1netstat -tuln | grep :80 统计连接：1netstat -an | grep ESTABLISHED | wc -l 注意： netstat 被 ss 替代，推荐使用 ss。 需要 sudo 查看某些连接。 4.3 ss 功能：现代网络连接查看工具，替代 netstat，更高效。 语法： 1ss [选项] 常用选项： -t：显示 TCP 连接。 -u：显示 UDP 连接。 -l：显示监听端口。 -p：显示关联进程。 -n：不解析地址/端口。 场景： 检查服务器开放端口。 监控网络连接状态。 示例： ss -tuln：显示监听的 TCP/UDP 端口。12Netid State Recv-Q Send-Q Local Address:Port Peer Address:Porttcp LISTEN 0 128 0.0.0.0:22 0.0.0.0:* ss -tp：显示 TCP 连接和进程。 高级用法： 筛选特定端口：1ss -tuln | grep :80 监控活跃连接：1watch -n 1 &#x27;ss -tn state established&#x27; 注意： 比 netstat 更快，适合现代系统。 需要 sudo 查看详细进程信息。 5. 日志与系统事件监控 这些命令用于查看系统日志和事件，诊断问题。 5.1 journalctl 功能：查看 systemd 日志，包含系统和服务日志。 语法： 1journalctl [选项] 常用选项： -u 服务：显示指定服务日志（如 systemd-networkd）。 -b：显示当前启动的日志。 -f：实时监控日志（类似 tail -f）。 -p 优先级：过滤日志级别（如 3 表示错误）。 -n 行数：显示最后指定行数。 场景： 排查系统启动或服务错误。 实时监控系统事件。 示例： journalctl -b：显示当前启动的日志。 journalctl -u sshd：显示 SSH 服务日志。 journalctl -f：实时监控系统日志。 journalctl -p 3：显示错误级别日志。 高级用法： 筛选时间范围：1journalctl --since &quot;2025-09-14 14:00&quot; --until &quot;2025-09-14 15:00&quot; 结合 grep：1journalctl -u apache2 | grep &quot;error&quot; 注意： 需要 sudo 查看某些系统日志。 日志可能占用大量空间，定期清理（sudo journalctl --vacuum-time=7d）。 5.2 dmesg 功能：显示内核环形缓冲区的日志，包含硬件和驱动信息。 语法： 1dmesg [选项] 常用选项： -T：显示人类可读时间。 -L：彩色输出。 -w：实时监控（类似 tail -f）。 -l 级别：过滤日志级别（如 err、warn）。 场景： 诊断硬件问题（如 USB 设备失败）。 检查内核启动消息。 示例： dmesg：显示所有内核日志。 dmesg -T | grep usb：显示 USB 相关日志，带时间戳。 dmesg -w：实时监控内核日志。 dmesg -l err：显示错误级别日志。 高级用法： 结合 grep：1dmesg | grep -i &quot;error\\|fail&quot; 导出日志：1dmesg &gt; kernel.log 注意： 需要 sudo 查看某些受限日志。 缓冲区有限，老日志可能被覆盖。 6. 使用场景与示例 以下是系统信息和监控命令在实际任务中的应用： 检查系统硬件配置： 获取 CPU 和内存信息：1lscpu &amp;&amp; free -h 收集完整硬件清单：1sudo lshw -short &gt; hardware.txt 监控系统性能： 实时查看 CPU 和内存：123htop# 或watch -n 1 &#x27;vmstat -t 1 2&#x27; 检查磁盘 I/O 瓶颈：1iostat -x 1 诊断磁盘空间问题： 检查磁盘使用：1df -h 查找大目录：1du -h /var | sort -hr | head -n 10 网络问题排查： 检查开放端口：1ss -tuln 监控网络流量：1watch -n 1 &#x27;ip -s link&#x27; 分析系统日志： 查看最近错误：1journalctl -p 3 -b 实时监控服务：1journalctl -u nginx -f 7. 高级用法 自动化监控脚本： 监控内存并报警：123456#!/bin/bashTHRESHOLD=10AVAIL=$(free -m | grep Mem | awk &#x27;&#123;print $7&#125;&#x27;)if [ $AVAIL -lt $THRESHOLD ]; then echo &quot;Low memory: $AVAIL MB&quot; | mail -s &quot;Memory Alert&quot; admin@example.comfi 保存为 monitor_memory.sh，用 crontab 定时运行。 实时性能仪表板： 使用 glances（需安装 sudo apt install glances）：1glances 提供 CPU、内存、磁盘、网络的综合监控。 日志分析： 提取特定时间段的错误：1journalctl --since &quot;2025-09-14 14:00&quot; -p 3 | grep &quot;error&quot; 硬件故障检测： 检查磁盘健康（需安装 smartmontools）：12sudo apt install smartmontoolssudo smartctl -a /dev/sda 8. 注意事项与扩展 安全提示： 查看系统信息（如 lshw、dmidecode）或日志（journalctl）通常需要 sudo。 定期清理日志（sudo journalctl --vacuum-size=100M）以释放空间。 性能优化： 监控大日志文件时，结合 grep 或 tail 减少输出。 使用 watch 或 htop 替代频繁运行 top。 相关工具： glances：综合系统监控工具。12sudo apt install glancesglances nmon：性能监控工具（需安装）。12sudo apt install nmonnmon iotop：监控进程 I/O（需安装）。12sudo apt install iotopsudo iotop 6. 包管理（Package Management） - Ubuntu 专属 APT 以下是对 Ubuntu 中 包管理（Package Management） 工具 APT（Advanced Package Tool）的详细讲解，涵盖其功能、语法、常用命令、选项、实际使用场景、高级用法和示例。内容基于 Ubuntu 22.04/24.04 环境，参考了 Ubuntu 官方文档、man 页、DigitalOcean 和 ItsFOSS 等权威来源，确保全面、深入且易于理解。讲解采用清晰的列表格式，包含丰富细节，结合实际场景和注意事项，专注于 Ubuntu 的 APT 系统（包括 apt, apt-get, apt-cache 等工具）。当前时间为 2025 年 9 月 14 日下午 3:03（JST）。 APT 是 Ubuntu 的默认包管理工具，用于安装、更新、移除和管理软件包及其依赖。它通过与软件源（repositories）交互，从在线存储库或本地缓存获取 .deb 格式的软件包。APT 包括几个核心命令（如 apt, apt-get, apt-cache），其中 apt 是现代用户友好的前端，而 apt-get 和 apt-cache 提供更细粒度的控制。以下详细讲解 APT 的功能、命令和使用方法。 1. APT 概述 功能： 安装、更新、移除软件包。 管理依赖关系，自动解决冲突。 配置和更新软件源。 查询包信息和搜索软件。 核心组件： apt: 用户友好的前端，结合 apt-get 和 apt-cache 的常用功能，推荐日常使用。 apt-get: 功能全面的底层工具，适合脚本和高级操作。 apt-cache: 查询包信息和依赖。 dpkg: 低级工具，直接操作 .deb 文件（通常由 APT 调用）。 软件源： 配置文件：/etc/apt/sources.list 和 /etc/apt/sources.list.d/*.list。 源类型：main（官方支持）、universe（社区维护）、restricted（专有驱动）、multiverse（非自由软件）。 典型源格式：1deb http://archive.ubuntu.com/ubuntu jammy main universe deb: 二进制包。 http://...: 源 URL。 jammy: 发行版代号（如 Ubuntu 22.04）。 main universe: 组件。 缓存：APT 将下载的包和元数据存储在 /var/cache/apt 和 /var/lib/apt。 2. 核心命令与语法 2.1 apt 功能：用户友好的命令行工具，整合 apt-get 和 apt-cache 的常用功能，提供进度条和彩色输出。 语法： 1apt [选项] 命令 [包名...] 常用命令： update: 更新软件源的包索引。 upgrade: 升级所有已安装的包到最新版本。 full-upgrade: 升级包，允许移除或安装新依赖（更激进）。 install 包名: 安装指定包及其依赖。 remove 包名: 删除包，保留配置文件。 purge 包名: 删除包及其配置文件。 autoremove: 移除不再需要的依赖包。 search 关键字: 搜索包名或描述。 show 包名: 显示包的详细信息。 list: 列出包状态（如已安装、可升级）。 常用选项： -y: 自动确认（适合脚本）。 -s: 模拟操作，不实际执行。 --no-install-recommends: 仅安装必要依赖。 --allow-downgrades: 允许降级安装。 场景： 日常软件安装和更新。 查询可用包或检查系统状态。 示例： 更新包索引：1sudo apt update 刷新 /var/lib/apt/lists 中的源数据。 升级所有包：1sudo apt upgrade 更新已安装的包到最新版本。 安装软件：1sudo apt install vim 安装 Vim 编辑器及其依赖。 删除软件：1sudo apt remove nginx 删除 Nginx，保留配置文件。 清理无用依赖：1sudo apt autoremove 搜索包：1apt search python3 查找包含 “python3” 的包。 查看包信息：1apt show htop 显示 htop 的版本、描述等。 列出可升级包：1apt list --upgradable 高级用法： 模拟安装：1apt install -s nginx 显示安装过程但不执行。 安装特定版本：1sudo apt install python3=3.10.6-1~22.04 批量安装：1sudo apt install vim htop curl -y 注意： apt 是用户交互工具，脚本中建议用 apt-get。 运行 update 前需确保网络连接和源配置正确。 需要 sudo 执行修改操作。 2.2 apt-get 功能：功能全面的包管理工具，适合高级用户和脚本，提供比 apt 更细粒度的控制。 语法： 1apt-get [选项] 命令 [包名...] 常用命令（与 apt 重叠的部分略，重点补充独特功能）： dist-upgrade: 升级系统，可能更改依赖结构（类似 full-upgrade）。 clean: 清除已下载的包缓存（/var/cache/apt/archives）。 autoclean: 清除过期的包缓存。 check: 检查依赖是否完整。 source 包名: 下载包的源代码。 build-dep 包名: 安装包的编译依赖。 常用选项： -y: 自动确认。 -q: 安静模式，减少输出。 --reinstall: 重新安装包。 --download-only: 仅下载包不安装。 场景： 系统升级或修复依赖。 清理缓存以释放磁盘空间。 开发者编译软件时获取源代码。 示例： 清理缓存：1sudo apt-get clean 删除 /var/cache/apt/archives 中的包。 检查依赖：1sudo apt-get check 验证系统依赖完整性。 下载源代码：1apt-get source bash 下载 Bash 的源代码。 安装编译依赖：1sudo apt-get build-dep nginx 重新安装包：1sudo apt-get install --reinstall vim 高级用法： 下载但不安装：1sudo apt-get install --download-only nginx 包保存在 /var/cache/apt/archives。 修复损坏依赖：1sudo apt-get install -f 系统大版本升级：1sudo apt-get update &amp;&amp; sudo apt-get dist-upgrade 注意： dist-upgrade 可能移除包，需谨慎。 确保 /etc/apt/sources.list 配置正确以避免错误。 2.3 apt-cache 功能：查询包信息、依赖和软件源数据，不执行安装或删除操作。 语法： 1apt-cache [选项] 命令 [包名...] 常用命令： search 关键字: 搜索包名或描述。 show 包名: 显示包的详细信息。 depends 包名: 显示包的依赖。 rdepends 包名: 显示依赖此包的其他包。 pkgnames: 列出所有可用包名。 policy 包名: 显示包的版本和源优先级。 常用选项： -i: 显示重要信息（如依赖）。 -p: 显示所有版本的包。 场景： 查询包的版本、依赖或来源。 排查依赖冲突。 示例： 搜索包：1apt-cache search webserver 查找包含 “webserver” 的包。 查看包信息：1apt-cache show nginx 显示 Nginx 的版本、描述等。 检查依赖：1apt-cache depends python3 查看反向依赖：1apt-cache rdepends apache2 显示源优先级：1apt-cache policy vim 输出：123456vim: Installed: 2:8.2.3995-1ubuntu2 Candidate: 2:8.2.3995-1ubuntu2 Version table: *** 2:8.2.3995-1ubuntu2 500 500 http://archive.ubuntu.com/ubuntu jammy/main amd64 Packages 高级用法： 查找依赖链：1apt-cache depends --recurse python3 显示 Python3 的完整依赖树。 列出所有包：1apt-cache pkgnames | grep python 注意： apt-cache 不修改系统，仅查询。 需要先运行 apt update 确保索引最新。 2.4 dpkg 功能：低级包管理工具，直接操作 .deb 文件，处理安装、移除和查询。 语法： 1dpkg [选项] 动作 [包名|.deb 文件] 常用动作： -i 文件: 安装 .deb 文件。 -r 包名: 删除包，保留配置文件。 -P 包名: 删除包及其配置文件。 -l [模式]: 列出已安装包。 -S 文件: 查找包含指定文件的包。 -s 包名: 显示包状态。 常用选项： --force-all: 强制执行（如忽略依赖错误）。 --configure -a: 配置所有未配置的包。 场景： 安装本地 .deb 文件。 修复 APT 无法解决的包问题。 查询已安装包。 示例： 安装本地包：1sudo dpkg -i package.deb 列出已安装包：1dpkg -l | grep nginx 查找文件所属包：1dpkg -S /usr/bin/vim 删除包：1sudo dpkg -r nginx 高级用法： 修复依赖：12sudo dpkg -i package.debsudo apt-get install -f 安装 .deb 后修复依赖。 列出包文件：1dpkg -L nginx 显示 Nginx 安装的文件列表。 注意： dpkg 不自动处理依赖，需配合 apt-get install -f。 手动安装可能导致冲突，建议优先使用 apt。 3. 软件源管理 软件源决定了 APT 从哪里获取包，配置文件位于 /etc/apt/sources.list 和 /etc/apt/sources.list.d/。 3.1 add-apt-repository 功能：添加或移除 APT 软件源（如 PPA，Personal Package Archive）。 语法： 1add-apt-repository [选项] 源 常用选项： -r: 移除指定源。 -y: 自动确认。 -s: 添加源代码源。 场景： 添加第三方软件源（如最新版软件）。 启用 Ubuntu 的 universe 或 multiverse 源。 示例： 添加 PPA：12sudo add-apt-repository ppa:deadsnakes/ppasudo apt update 添加 Python 最新版本的 PPA。 启用 universe 源：1sudo add-apt-repository universe 移除源：1sudo add-apt-repository -r ppa:deadsnakes/ppa 高级用法： 添加源代码：1sudo add-apt-repository -s ppa:deadsnakes/ppa 手动编辑源：1sudo nano /etc/apt/sources.list 添加如 deb http://archive.ubuntu.com/ubuntu jammy universe. 注意： 添加第三方 PPA 需谨慎，可能影响系统稳定性。 每次修改源后需运行 sudo apt update。 3.2 apt-key（或 gpg） 功能：管理 APT 软件源的 GPG 密钥，确保包来源可信（Ubuntu 22.04 后推荐用 /etc/apt/trusted.gpg.d）。 语法： 1apt-key [命令] 常用命令： add 文件: 添加 GPG 密钥。 list: 列出已导入的密钥。 del 密钥ID: 删除指定密钥。 场景： 验证第三方源的安全性。 修复源签名错误。 示例： 添加 GPG 密钥：1wget -qO - https://example.com/key.asc | sudo apt-key add - 列出密钥：1apt-key list 新方式（推荐）：1wget -qO - https://example.com/key.asc | sudo tee /etc/apt/trusted.gpg.d/example.asc 高级用法： 验证签名：1apt-key verify package.deb 注意： apt-key 在 Ubuntu 22.04 后已废弃，推荐使用 gpg 和 /etc/apt/trusted.gpg.d。 确保密钥来源可靠。 4. 使用场景与示例 以下是 APT 在实际任务中的应用： 安装和更新软件： 安装 Nginx 并更新：123sudo apt updatesudo apt install nginxsudo apt upgrade 安装特定版本：1sudo apt install python3=3.10.6-1~22.04 清理系统： 清理缓存和无用依赖：12sudo apt-get cleansudo apt autoremove 删除孤立包：1sudo apt-get autoremove --purge 添加第三方源： 安装最新 Node.js：123sudo add-apt-repository ppa:chris-lea/node.jssudo apt updatesudo apt install nodejs 修复依赖问题： 修复损坏依赖：12sudo apt-get install -fsudo dpkg --configure -a 重新配置包：1sudo dpkg-reconfigure nginx 查询和搜索： 查找 Python 相关包：1apt search python3 | grep library 检查包状态：1dpkg -l | grep vim 5. 高级用法 自动化脚本： 批量安装软件：1234#!/bin/bashPACKAGES=&quot;vim htop curl&quot;sudo apt updatesudo apt install -y $PACKAGES 保存为 install_tools.sh，运行 bash install_tools.sh。 PPA 管理： 列出所有 PPA：1ls /etc/apt/sources.list.d/ 禁用 PPA：1sudo mv /etc/apt/sources.list.d/ppa.list /etc/apt/sources.list.d/ppa.list.disabled 缓存备份： 备份已下载包：1sudo cp -r /var/cache/apt/archives /backup/apt_cache 离线安装： 下载包及其依赖：1sudo apt-get install --download-only nginx 复制到另一台机器：12sudo cp /var/cache/apt/archives/*.deb /media/usbsudo dpkg -i /media/usb/*.deb 7. 网络命令（Networking） 1. 网络接口管理 这些命令用于查看和配置网络接口（如以太网、Wi-Fi）。 1.1 ip 功能：现代网络配置工具，用于显示和管理系统网络接口、IP 地址、路由和邻居表，替代过时的 ifconfig。 语法： 1ip [选项] 对象 &#123;命令 | help&#125; 常用对象： link：管理网络接口状态。 addr：管理 IP 地址。 route：管理路由表。 neigh：管理 ARP 表（邻居）。 常用选项： -s：显示统计信息（如流量）。 -4 / -6：仅显示 IPv4/IPv6。 -c：彩色输出。 场景： 检查网络接口状态和 IP 地址。 配置临时 IP 或路由。 监控接口流量。 示例： 查看所有接口：1ip link 输出：12341: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:002: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP link/ether 00:16:3e:12:34:56 brd ff:ff:ff:ff:ff:ff 查看 IP 地址：1ip addr show 输出：122: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 inet 192.168.1.100/24 brd 192.168.1.255 scope global eth0 添加临时 IP：1sudo ip addr add 192.168.1.101/24 dev eth0 查看路由表：1ip route 输出：12default via 192.168.1.1 dev eth0192.168.1.0/24 dev eth0 proto kernel scope link src 192.168.1.100 查看接口统计：1ip -s link 高级用法： 启用/禁用接口：12sudo ip link set eth0 downsudo ip link set eth0 up 添加静态路由：1sudo ip route add 10.0.0.0/24 via 192.168.1.1 清理 ARP 缓存：1sudo ip neigh flush dev eth0 注意： 配置更改是临时的，重启后失效，需修改配置文件（如 /etc/netplan/）。 需要 sudo 执行修改操作。 推荐用 ip 替代 ifconfig，因为它是现代标准。 1.2 ifconfig 功能：传统工具，用于查看和配置网络接口（需安装 sudo apt install net-tools）。 语法： 1ifconfig [接口] [选项] 常用选项： -a：显示所有接口（包括未激活的）。 up / down：启用/禁用接口。 地址：设置 IP 地址。 场景： 快速检查接口 IP 和状态。 兼容旧脚本或系统。 示例： 查看所有接口：1ifconfig -a 输出：12eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 192.168.1.100 netmask 255.255.255.0 broadcast 192.168.1.255 设置 IP 地址：1sudo ifconfig eth0 192.168.1.101 netmask 255.255.255.0 禁用接口：1sudo ifconfig eth0 down 高级用法： 结合 grep：1ifconfig eth0 | grep inet 提取 IP 地址。 注意： ifconfig 已逐渐被 ip 取代，某些系统可能未预装 net-tools。 配置更改临时，需修改配置文件持久化。 1.3 nmcli（NetworkManager CLI） 功能：管理 NetworkManager 配置的网络连接，适用于桌面和服务器环境（需安装 network-manager）。 语法： 1nmcli [选项] 对象 &#123;命令&#125; 常用对象： connection（con）：管理连接配置。 device（dev）：管理网络设备。 general：显示 NetworkManager 状态。 常用命令： show：显示状态或配置。 up / down：启用/禁用连接。 add / modify：添加/修改连接。 场景： 配置 Wi-Fi 或有线连接。 管理 DHCP 或静态 IP。 自动化网络配置。 示例： 查看连接状态：1nmcli connection show 输出：12NAME UUID TYPE DEVICEWired conn 123e4567-e89b-12d3-a456-426614174000 ethernet eth0 连接 Wi-Fi：1nmcli device wifi connect SSID password PASSWORD 设置静态 IP：1234nmcli connection modify &quot;Wired conn&quot; ipv4.addresses 192.168.1.100/24nmcli connection modify &quot;Wired conn&quot; ipv4.gateway 192.168.1.1nmcli connection modify &quot;Wired conn&quot; ipv4.method manualnmcli connection up &quot;Wired conn&quot; 查看 Wi-Fi 热点：1nmcli device wifi list 高级用法： 批量配置：1nmcli connection add type ethernet ifname eth0 con-name eth0-static ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.dns 8.8.8.8 监控连接状态：1watch -n 1 nmcli device status 注意： 需确保 NetworkManager 服务运行（systemctl status NetworkManager）。 配置存储在 /etc/NetworkManager/system-connections/。 服务器可能使用 netplan 而非 NetworkManager。 1.4 netplan 功能：Ubuntu 默认网络配置工具，通过 YAML 文件管理网络设置（/etc/netplan/）。 语法： 1netplan [命令] 常用命令： apply：应用配置文件更改。 generate：生成配置文件缓存。 try：测试配置，超时后回滚。 场景： 配置持久化网络设置（如静态 IP）。 管理复杂网络（如桥接、VLAN）。 示例： 编辑配置文件：1sudo nano /etc/netplan/01-netcfg.yaml 示例内容：123456789network: version: 2 ethernets: eth0: dhcp4: no addresses: [192.168.1.100/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8, 8.8.4.4] 应用配置：1sudo netplan apply 测试配置（120 秒回滚）：1sudo netplan try 高级用法： 配置 Wi-Fi：12345678network: version: 2 wifis: wlan0: dhcp4: yes access-points: &quot;MySSID&quot;: password: &quot;MyPassword&quot; 备份配置：1sudo cp /etc/netplan/01-netcfg.yaml /etc/netplan/01-netcfg.yaml.bak 注意： YAML 格式对缩进敏感（2 空格）。 需要 sudo 编辑和应用配置。 检查语法：sudo netplan generate。 2. 网络连接测试 这些命令用于测试网络连通性和延迟。 2.1 ping 功能：发送 ICMP 数据包测试主机连通性和延迟。 语法： 1ping [选项] 目标 常用选项： -c 次数：发送指定次数的包。 -i 秒：设置发送间隔。 -s 大小：设置数据包大小（字节）。 -4 / -6：强制 IPv4/IPv6。 场景： 测试服务器是否可达。 测量网络延迟。 示例： 测试 Google：1ping -c 4 google.com 输出：12345PING google.com (142.250.190.78) 56(84) bytes of data.64 bytes from 142.250.190.78: icmp_seq=1 ttl=117 time=20.1 ms...--- google.com ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3004ms 设置间隔：1ping -i 0.5 192.168.1.1 高级用法： 测试本地网络：1ping -c 4 192.168.1.1 检查丢包：1ping -c 100 google.com | grep &quot;packet loss&quot; 注意： 某些服务器禁用 ICMP，可能无法 ping。 需 sudo 使用特殊选项（如 -s 调整包大小）。 2.2 traceroute 功能：跟踪数据包到目标主机的路由路径（需安装 sudo apt install traceroute）。 语法： 1traceroute [选项] 目标 常用选项： -n：不解析主机名，显示 IP。 -m 跳数：设置最大跳数。 -w 秒：设置每跳超时时间。 -4 / -6：强制 IPv4/IPv6。 场景： 诊断网络路由问题。 确定数据包路径和延迟。 示例： 跟踪到 Google：1traceroute google.com 输出：1231 192.168.1.1 0.5 ms2 10.0.0.1 1.2 ms3 142.250.190.78 20.3 ms 不解析主机名：1traceroute -n google.com 高级用法： 限制跳数：1traceroute -m 10 google.com 结合 grep：1traceroute google.com | grep &quot;ms&quot; 注意： 需 sudo 在某些系统上运行。 防火墙可能阻止 traceroute 数据包。 2.3 mtr 功能：结合 ping 和 traceroute，实时跟踪路由并显示丢包和延迟（需安装 sudo apt install mtr）。 语法： 1mtr [选项] 目标 常用选项： -r：报告模式（非交互）。 -c 次数：发送指定次数的包。 -n：不解析主机名。 --tcp：使用 TCP 而非 ICMP。 场景： 实时诊断网络抖动或丢包。 分析长距离路由性能。 示例： 实时跟踪：1mtr google.com 输出：123Host Loss% Snt Last Avg Best Wrst StDev1. 192.168.1.1 0.0% 10 0.5 0.6 0.4 0.8 0.12. 10.0.0.1 0.0% 10 1.2 1.3 1.1 1.5 0.2 报告模式：1mtr -r -c 10 google.com 高级用法： 保存报告：1mtr -r -c 100 google.com &gt; mtr_report.txt 使用 TCP：1mtr --tcp google.com 注意： 比 traceroute 更适合动态分析。 需 sudo 使用某些协议（如 TCP）。 3. 网络流量与端口监控 这些命令用于监控网络流量和开放端口。 3.1 netstat 功能：显示网络连接、路由表和接口统计（需安装 sudo apt install net-tools）。 语法： 1netstat [选项] 常用选项： -a：显示所有连接（包括监听）。 -t：显示 TCP 连接。 -u：显示 UDP 连接。 -p：显示关联进程。 -n：显示数字地址/端口（不解析）。 -r：显示路由表。 场景： 检查开放端口和服务。 查看当前网络连接。 示例： 显示监听端口：1netstat -tuln 输出：12Proto Recv-Q Send-Q Local Address Foreign Address Statetcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 显示进程：1netstat -tulnp 查看路由：1netstat -r 高级用法： 筛选特定端口：1netstat -tuln | grep :80 统计连接：1netstat -an | grep ESTABLISHED | wc -l 注意： netstat 被 ss 取代，推荐使用 ss。 需要 sudo 查看某些连接。 3.2 ss 功能：现代工具，显示网络连接和端口信息，替代 netstat，更高效。 语法： 1ss [选项] 常用选项： -t：显示 TCP 连接。 -u：显示 UDP 连接。 -l：显示监听端口。 -p：显示关联进程。 -n：不解析地址/端口。 -a：显示所有连接。 场景： 检查服务器开放端口。 监控活跃连接。 示例： 显示监听端口：1ss -tuln 输出：12Netid State Recv-Q Send-Q Local Address:Port Peer Address:Porttcp LISTEN 0 128 0.0.0.0:22 0.0.0.0:* 显示 TCP 连接和进程：1ss -tnp 高级用法： 筛选活跃连接：1ss -tn state established 实时监控：1watch -n 1 &#x27;ss -tuln&#x27; 注意： 比 netstat 更快，适合现代系统。 需要 sudo 查看详细进程信息。 3.3 nmap 功能：网络扫描工具，用于端口扫描、主机发现和服务探测（需安装 sudo apt install nmap）。 语法： 1nmap [选项] 目标 常用选项： -p 端口：扫描指定端口。 -sS：TCP SYN 扫描（快速）。 -sU：UDP 扫描。 -O：探测操作系统。 -sV：探测服务版本。 -A：全面扫描（端口、服务、OS）。 场景： 检查本地或远程主机的开放端口。 识别网络服务和版本。 示例： 扫描本地主机：1nmap localhost 输出：1234Starting Nmap 7.80 ( https://nmap.org )Nmap scan report for localhost (127.0.0.1)PORT STATE SERVICE22/tcp open ssh 扫描特定端口：1nmap -p 80,443 192.168.1.100 全面扫描：1nmap -A 192.168.1.100 高级用法： 扫描子网：1nmap 192.168.1.0/24 保存结果：1nmap -oN scan.txt 192.168.1.100 注意： 扫描外部主机可能触发防火墙或被视为攻击。 需要 sudo 执行某些扫描（如 -sS、-O）。 3.4 iftop 功能：实时监控网络接口的流量（需安装 sudo apt install iftop）。 语法： 1iftop [选项] 常用选项： -i 接口：监控指定接口。 -B：以字节显示（默认比特）。 -f 过滤器：应用过滤规则。 场景： 分析网络带宽使用。 识别高流量主机或连接。 示例： 监控 eth0：1sudo iftop -i eth0 显示字节：1sudo iftop -B 高级用法： 过滤特定 IP：1sudo iftop -f &quot;host 192.168.1.100&quot; 注意： 需要 sudo 运行。 适合实时流量分析，长期监控建议用 nload。 4. 网络服务与协议 这些命令用于管理网络服务和测试协议。 4.1 curl 功能：传输数据，支持 HTTP、HTTPS、FTP 等协议，常用于测试 API 或下载文件。 语法： 1curl [选项] URL 常用选项： -o 文件：保存输出到文件。 -O：以远程文件名保存。 -I：仅获取 HTTP 头。 -X 方法：指定 HTTP 方法（如 POST）。 -d 数据：发送 POST 数据。 -H 头：添加 HTTP 头。 场景： 测试 Web 服务器响应。 调用 REST API。 下载文件。 示例： 获取网页：1curl https://example.com 下载文件：1curl -O https://example.com/file.zip 发送 POST 请求：1curl -X POST -d &#x27;&#123;&quot;key&quot;:&quot;value&quot;&#125;&#x27; -H &quot;Content-Type: application/json&quot; http://api.example.com 查看响应头：1curl -I https://example.com 高级用法： 批量下载：1curl -O https://example.com/file[1-3].txt 认证请求：1curl -u user:pass https://example.com 注意： 支持多种协议，适合脚本和自动化。 调试时使用 -v 查看详细交互。 4.2 wget 功能：下载文件，支持 HTTP、HTTPS、FTP，适合非交互式下载。 语法： 1wget [选项] URL 常用选项： -O 文件：指定输出文件。 -c：断点续传。 -r：递归下载。 -q：安静模式。 --limit-rate=速率：限制下载速度。 场景： 下载大文件或镜像。 爬取网站内容。 示例： 下载文件：1wget https://example.com/file.zip 断点续传：1wget -c https://example.com/large.iso 递归下载：1wget -r -np http://example.com/docs/ 高级用法： 限制速度：1wget --limit-rate=500k https://example.com/file.zip 下载列表：1wget -i urls.txt 注意： 比 curl 更适合简单下载任务。 递归下载需谨慎，可能消耗大量资源。 4.3 ssh 功能：通过 SSH 协议远程登录或执行命令。 语法： 1ssh [选项] 用户@主机 [命令] 常用选项： -p 端口：指定 SSH 端口。 -i 密钥：使用指定私钥。 -X：启用 X11 转发（图形界面）。 -L：本地端口转发。 场景： 远程管理服务器。 安全传输文件（通过 scp 或 sftp）。 示例： 登录远程主机：1ssh user@192.168.1.100 执行远程命令：1ssh user@192.168.1.100 &#x27;uptime&#x27; 使用非标准端口：1ssh -p 2222 user@192.168.1.100 高级用法： 端口转发：1ssh -L 8080:localhost:80 user@remote 将远程主机的 80 端口映射到本地 8080。 使用密钥登录：1ssh -i ~/.ssh/id_rsa user@remote 注意： 需配置 ~/.ssh/config 简化连接。 确保 SSH 服务运行（sudo systemctl status sshd）。 5. 使用场景与示例 以下是网络命令在实际任务中的应用： 配置网络接口： 设置静态 IP：12sudo nmcli connection modify &quot;Wired conn&quot; ipv4.addresses 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.method manualsudo nmcli connection up &quot;Wired conn&quot; 或通过 netplan：12sudo nano /etc/netplan/01-netcfg.yamlsudo netplan apply 诊断网络问题： 测试连通性：1ping -c 4 google.com 跟踪路由：1mtr -r -c 10 google.com 监控网络流量： 查看实时流量：1sudo iftop -i eth0 检查开放端口：1ss -tuln 测试 Web 服务： 检查 HTTP 响应：1curl -I http://example.com 下载网站：1wget -r http://example.com 远程管理： 登录服务器并查看日志：1ssh user@192.168.1.100 &#x27;tail -f /var/log/syslog&#x27; 6. 高级用法 自动化网络测试： 脚本检查连接：12#!/bin/bashping -c 4 192.168.1.1 || echo &quot;Network down&quot; 保存为 check_network.sh，用 crontab 定时运行。 端口扫描脚本：1nmap -p 1-1000 192.168.1.0/24 -oN scan_results.txt 流量监控仪表板： 使用 nload（需安装 sudo apt install nload）：1nload eth0 SSH 隧道： 反向隧道（远程访问本地服务）：1ssh -R 8080:localhost:80 user@remote 7. 注意事项与扩展 安全提示： 使用 nmap 扫描外部主机可能触发防火墙或被视为攻击。 SSH 默认端口（22）易受攻击，建议修改（/etc/ssh/sshd_config）。 定期检查开放端口（ss -tuln）。 性能优化： 监控大流量时，使用 iftop 或 nload 而非 netstat。 批量下载（wget -r）需限制深度（-l）避免过载。 相关工具： tcpdump：捕获网络数据包。12sudo apt install tcpdumpsudo tcpdump -i eth0 wireshark：图形化网络分析工具。12sudo apt install wiresharkwireshark &amp; dig / nslookup：DNS 查询工具。1dig example.com 8. 压缩和归档（Compression &amp; Archiving） tar: 创建/提取 tar 归档。 示例: tar -czf archive.tar.gz folder/。 gzip: 压缩文件。 示例: gzip file.txt。 gunzip: 解压 gz 文件。 示例: gunzip file.txt.gz。 zip: 创建 zip 归档。 示例: zip archive.zip file.txt。 unzip: 解压 zip 文件。 示例: unzip archive.zip。 9. 搜索和文本处理（Search &amp; Text Processing） grep: 在文件中搜索文本。 示例: grep &quot;error&quot; log.txt。 find: 搜索文件（见文件管理）。 locate: 快速搜索文件位置（需更新数据库）。 示例: locate filename。 which: 显示命令的可执行路径。 示例: which ls。 whereis: 查找命令的二进制、源和手册位置。 示例: whereis ls。 whatis: 显示命令的简短描述。 示例: whatis ls。 man: 显示命令的手册。 示例: man ls。 apropos: 根据关键词搜索命令。 示例: apropos network。 10. 服务和系统管理（Services &amp; System Admin） service: 管理系统服务。 示例: sudo service ssh start。 systemctl: 管理 systemd 服务（现代版）。 示例: sudo systemctl status ssh。 reboot: 重启系统。 示例: sudo reboot。 shutdown: 关机或重启。 示例: sudo shutdown -h now。 history: 显示命令历史。 示例: history。 clear: 清空终端屏幕。 示例: clear。 alias: 创建命令别名。 示例: alias ll='ls -la'。 env: 显示当前环境变量。 示例: env。 export: 设置环境变量。 示例: export PATH=$PATH:/newpath。 11. 其他实用命令（Miscellaneous） bc: 命令行计算器。 示例: echo &quot;2+2&quot; | bc。 sort: 排序文件行。 示例: sort file.txt。 uniq: 去除重复行。 示例: sort file.txt | uniq。 wc: 统计行数/字数。 示例: wc -l file.txt。 diff: 比较两个文件差异。 示例: diff file1.txt file2.txt。 paste: 合并文件行。 示例: paste file1.txt file2.txt。 cut: 提取文件列。 示例: cut -d',' -f1 csvfile.csv。 tr: 转换/删除字符。 示例: tr 'a-z' 'A-Z' &lt; file.txt。 sed: 流编辑器，替换文本。 示例: sed 's/old/new/g' file.txt。 awk: 文本处理工具。 示例: awk '&#123;print $1&#125;' file.txt (打印第一列)。","categories":[],"tags":[{"name":"service","slug":"service","permalink":"https://borrowyourhuaji.github.io/tags/service/"}]},{"title":"数位dp","slug":"数位dp","date":"2025-09-13T15:00:51.000Z","updated":"2025-09-13T15:01:40.205Z","comments":true,"path":"2025/09/13/数位dp/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E6%95%B0%E4%BD%8Ddp/","excerpt":"","text":"数位统计 DP（Digit DP）详细解析 数位统计 DP（Digit Dynamic Programming，简称 Digit DP）是一种基于动态规划的算法技术，广泛应用于 ACM 竞赛、算法设计和计数问题中。它主要用于解决与数字的位数相关的计数问题，例如统计某个范围内满足特定条件的整数个数。数位 DP 特别适合处理大范围（如 ( 10^{18} )）的计数问题，通过逐位构造数字并结合动态规划避免暴力枚举。 1. 数位统计 DP 的基本概念 1.1 定义 数位 DP 是一种用于统计某个范围内整数个数（或满足特定条件的数字）的动态规划方法，通常问题形式如下： 给定一个范围 ([L, R])（例如 ( L, R \\leq 10^{18} )）。 要求统计 ([L, R]) 内满足特定条件的整数个数，例如： 数字的各位之和为某个值（如和为 ( K )）。 数字中不含某位（如不含 4）。 数字是某个数的倍数（如是 3 的倍数）。 数字的各位满足某种模式（如单调递增）。 目标： 计算满足条件的整数个数。 （可选）输出满足条件的数字。 输出： 满足条件的整数个数（可能需要模 ( 10^9+7 )）。 （可选）一个或多个满足条件的数字。 示例： 输入：( L = 1, R = 100 )，条件：数字的各位之和是 5。 满足条件的数字： 5（( 5 = 5 )） 14（( 1 + 4 = 5 )） 23（( 2 + 3 = 5 )） 32（( 3 + 2 = 5 )） 41（( 4 + 1 = 5 )） 50（( 5 + 0 = 5 )） 输出：6（满足条件的数字个数）。 答案计算：统计 ([1, 100]) 内各位之和为 5 的数字个数，通常用 ( f® - f(L-1) )，其中 ( f(x) ) 表示 ( [1, x] ) 内满足条件的数字个数。 关键特点： 逐位构造：从高位到低位逐位确定数字，动态维护状态。 范围处理：通过 ( f® - f(L-1) ) 计算 ([L, R]) 的答案。 状态压缩：用 DP 状态记录前缀信息（如当前数字、前缀和、模数等）。 记忆化：避免重复计算重叠子问题。 大范围适用：适合 ( R \\leq 10^{18} )，暴力枚举不可行。 1.2 数学模型 输入： 范围：( L, R )（整数，( 1 \\leq L \\leq R \\leq 10^{18} )）。 条件：数字的性质（例如，各位之和、模 ( K )、不含某位）。 目标： 计算 ([L, R]) 内满足条件的整数个数 ( C )。 通常通过 ( f® - f(L-1) )，其中 ( f(x) ) 是 ( [1, x] ) 内满足条件的个数。 输出： ( C )（整数，可能模 ( 10^9+7 )）。 （可选）满足条件的数字。 约束： 数字范围大（( 10^{18} )），需高效算法。 条件基于数字的位（十进制或二进制）。 1.3 与其他问题的对比 问题 定义 Goal DP 状态 Complexity 数位 DP 统计范围内满足位数条件的整数个数 满足条件的个数 ( dp[pos][state] ): 第 pos 位的状态 ( O(\\log R \\cdot S) ) 子集和 集合中找子集和为 T 判断是否存在子集 ( dp[i][s] ): 前 i 个元素和为 s ( O(n \\times T) ) 布尔括号 加括号使布尔表达式为 True 的方案数 True 方案数 ( dp[i][j][b] ): 子表达式 [i:j] 为 b ( O(n^3) ) 矩阵链乘法 确定矩阵乘法顺序，最小化乘法次数 最小乘法次数 ( dp[i][j] ): 子链 [i:j] 最小代价 ( O(n^3) ) 数位 DP vs 子集和： 数位 DP：基于数字位，计数问题。 子集和：基于集合，存在性问题。 数位 DP vs 布尔括号： 数位 DP：逐位构造，范围计数。 布尔括号：区间 DP，括号计数。 数位 DP vs 矩阵链乘法： 数位 DP：数字位优化，计数。 矩阵链乘法：乘法顺序优化，最小代价。 1.4 应用场景 ACM 竞赛： 计数问题：Codeforces 1036C（Classy Numbers）。 模运算：AtCoder ABC 162F（Digits）。 路径恢复：SPOJ NDIGITS（输出数字）。 变种：HDU 4352（XHXJ’s LIS，数位 DP + 状态压缩）。 实际应用： 密码学：统计满足条件的数字（如模 ( K )）。 数据库：范围查询优化。 数据分析：数字模式统计。 编码：数字编码方案计数。 2. 数位 DP 的解法 数位 DP 通过逐位构造数字并维护状态，结合动态规划解决计数问题。以下详细讲解主要解法：记忆化递归、动态规划、路径恢复。 2.1 记忆化递归（标准数位 DP） 思路： 将数字从高位到低位逐位构造，记录当前状态（如当前位、是否贴近上界、前缀和等）。 使用记忆化递归避免重复计算。 计算 ( f(x) )，即 ( [1, x] ) 内满足条件的数字个数。 答案为 ( f® - f(L-1) ). 状态定义： ( dp[pos][state] )：从第 ( pos ) 位开始构造，当前状态为 ( state )，满足条件的数字个数。 常见状态： ( pos ): 当前处理的位（从高到低）。 ( tight ): 是否贴近上界（1: 必须 ≤ 当前位的数字，0: 可取 0-9）。 ( sum ): 前缀数字之和（若条件是和为 ( K )）。 ( mod ): 前缀模 ( K )（若条件是 ( K ) 的倍数）。 ( lead ): 是否允许前导零（1: 允许，0: 不允许）。 状态转移： 对于第 ( pos ) 位： 若 ( tight = 1 )，可选数字 ( d \\in [0, \\text{digit[pos]}] ). 若 ( tight = 0 )，可选数字 ( d \\in [0, 9] ). 新状态： ( new_tight = 1 ) 若 ( d = \\text{digit[pos]} ) 且 ( tight = 1 )，否则 0。 更新 ( sum, mod, lead ) 等状态。 递归到下一位： [ dp[pos][state] = \\sum_{d} dp[pos+1][new_state] ] 终止条件： ( pos = \\text{len(digits)} )，检查是否满足条件（如 ( sum = K )）。 初始调用： ( solve(0, 1, 0, 1) )，表示从第 0 位开始，贴近上界，无前缀和，允许前导零。 复杂度： 时间：( O(\\log R \\cdot S) )，其中 ( S ) 是状态数（如 ( 10 \\cdot K )）。 空间：( O(\\log R \\cdot S) )，记忆化表格。 适用性：ACM 竞赛标配，适合 ( R \\leq 10^{18} )，时间 ≥ 1 秒。 2.2 动态规划 思路： 将记忆化递归转为递推形式，填充 DP 表格。 从低位到高位迭代，状态同记忆化。 实现： 较少使用，因数位 DP 通常递归更直观。 适用场景：状态简单，需显式 DP 表格。 复杂度： 同记忆化递归。 适用性：调试复杂问题或需显式表格。 2.3 路径恢复 目标： 输出一个或多个满足条件的数字。 方法： 在 DP 过程中记录每个状态的选择（选的数字 ( d )）。 从 ( dp[0][初始状态] ) 回溯，构造数字。 实现： 用数组 ( choice[pos][state] ) 记录 ( d ). 回溯构造数字字符串。 复杂度： 时间：( O(\\log R \\cdot S) )（DP）+ ( O(\\log R) )（回溯）。 空间：( O(\\log R \\cdot S) ). 适用性：ACM 题目要求输出数字。 2.4 变种与优化 模运算： 答案模 ( 10^9+7 ). 前导零： 控制是否允许前导零（常见于严格递增条件）。 状态压缩： 若条件复杂（如 LIS），用位掩码压缩状态。 多条件： 同时满足多个条件（如和为 ( K )，是 ( M ) 的倍数）。 空间优化： 滚动数组或清空记忆化表格，空间降到 ( O(S) ). 3. 复杂度分析 方法 时间复杂度 空间复杂度 适用场景 记忆化递归 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 标准问题，( R \\leq 10^{18} )，时间 ≥ 1s 动态规划 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 调试复杂状态，显式表格 路径恢复 ( O(\\log R \\cdot S) ) ( O(\\log R \\cdot S) ) 需输出数字，( R \\leq 10^{18} ) 时间：( O(\\log R \\cdot S) )，( \\log R ) 是位数，( S ) 是状态数（例如 ( 10 \\cdot K )）。 空间：( O(\\log R \\cdot S) )，可优化到 ( O(S) ). ACM 限制： ( R \\leq 10^{18} )，位数 ( \\leq 18 )，时间 ≥ 1 秒，Python 适用。 复杂状态（( S \\geq 10^6 )）需 C++. 4. 在 ACM 竞赛中的应用 数位 DP 是 ACM 竞赛中的核心计数技术，常见于大范围计数、模运算和变种问题。以下是应用场景和解题思路： 标准数位 DP： 题目：Codeforces 1036C（Classy Numbers，非零位 ≤ 3）。 解法：记忆化递归。 方法： 状态：( dp[pos][tight][cnt] )，( cnt ) 为非零位数。 转移：枚举当前位 ( d )，更新 ( cnt ). 答案：( f® - f(L-1) ). 复杂度：时间 ( O(\\log R \\cdot 10 \\cdot 4) ). Python 优势：字符串和列表操作简洁。 路径恢复： 题目：SPOJ NDIGITS（输出满足条件的数字）。 解法：DP + 路径恢复。 方法： DP 计算满足条件的个数。 记录选择，回溯构造数字。 复杂度：时间 ( O(\\log R \\cdot S) ). Python 优势：字符串拼接和回溯直观。 变种问题： 模运算：HDU 3652（B-number，含 13 且被 13 整除）。 状态压缩：HDU 4352（XHXJ’s LIS，数位 DP + LIS）。 多条件：AtCoder ABC 162F（Digits，多个约束）。 示例：Codeforces 628D（Magic Numbers）。 方法：扩展状态（如模、模式匹配）。 Python 优势：条件判断和多维数组简洁。 ACM 优化技巧： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 模运算：防止溢出，模 ( 10^9+7 ). 状态压缩：用位掩码或整数压缩复杂状态。 调试：打印 DP 表格或构造的数字，验证转移。 边界处理：注意 ( L=1 )、前导零、紧界。 Python 在 ACM 中的适用性： 优点： 代码简洁：DP 约 40-60 行，路径恢复 60-80 行，比赛中 10-15 分钟实现。 调试方便：打印状态或数字，验证正确性。 适用：( \\log R \\leq 18 )，状态 ( S \\leq 10^5 )，时间 ≥ 1 秒。 缺点： 效率：Python 比 C++ 慢 5-10 倍，复杂状态可能 TLE。 内存：Python 数组占用较多，需优化。 优化： 快速 I/O：input = sys.stdin.readline. 滚动数组：空间降到 ( O(S) ). Cython/Numba：加速循环（非比赛场景）。 ACM 题目推荐： Codeforces 1036C：Classy Numbers（非零位 ≤ 3）。 HDU 3652：B-number（含 13 且被 13 整除）。 SPOJ NDIGITS：Number of Digits（路径恢复）。 AtCoder ABC 162F：Digits（多条件）。 Codeforces 628D：Magic Numbers（模运算）。 5. Python 实现 以下通过数位 DP 的两种典型问题（各位之和为 ( K )、路径恢复）提供 Python 实现，带详细注释，适合 ACM 竞赛。代码格式优化以确保在 OneNote 中清晰显示。 5.1 各位之和为 K（记忆化递归） 1234567891011121314151617181920212223242526272829303132333435import sysinput = sys.stdin.readlineMOD = 1000000007def digit_dp_sum_k(L: int, R: int, K: int) -&gt; int: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数&quot;&quot;&quot; def solve(digits: list, pos: int, tight: int, sum_digits: int, lead: int) -&gt; int: if pos == len(digits): return 1 if sum_digits == K and lead == 0 else 0 if sum_digits &gt; K: return 0 if dp[pos][tight][sum_digits][lead] != -1: return dp[pos][tight][sum_digits][lead] ans = 0 limit = digits[pos] if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit new_sum = sum_digits + d new_lead = lead and d == 0 ans = (ans + solve(digits, pos + 1, new_tight, new_sum, new_lead)) % MOD dp[pos][tight][sum_digits][lead] = ans return ans def count(x: int) -&gt; int: if x &lt; 0: return 0 digits = [int(d) for d in str(x)] global dp dp = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] return solve(digits, 0, 1, 0, 1) return (count(R) - count(L - 1)) % MOD# 测试L, R, K = map(int, input().split())print(&quot;Count of numbers with sum of digits =&quot;, K, &quot;:&quot;, digit_dp_sum_k(L, R, K)) 5.2 路径恢复（输出一个满足条件的数字） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import sysinput = sys.stdin.readlineMOD = 1000000007def digit_dp_path(L: int, R: int, K: int) -&gt; tuple: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位之和为 K 的数字个数，并返回一个数字&quot;&quot;&quot; def solve(digits: list, pos: int, tight: int, sum_digits: int, lead: int) -&gt; int: if pos == len(digits): return 1 if sum_digits == K and lead == 0 else 0 if sum_digits &gt; K: return 0 if dp[pos][tight][sum_digits][lead] != -1: return dp[pos][tight][sum_digits][lead] ans = 0 limit = digits[pos] if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit new_sum = sum_digits + d new_lead = lead and d == 0 cnt = solve(digits, pos + 1, new_tight, new_sum, new_lead) if cnt &gt; 0 and choice[pos][tight][sum_digits][lead] == -1: choice[pos][tight][sum_digits][lead] = d ans = (ans + cnt) % MOD dp[pos][tight][sum_digits][lead] = ans return ans def count(x: int) -&gt; int: if x &lt; 0: return 0 digits = [int(d) for d in str(x)] global dp, choice dp = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] choice = [[[[-1] * 2 for _ in range(K + 1)] for _ in range(2)] for _ in range(len(digits) + 1)] return solve(digits, 0, 1, 0, 1) # 回溯构造数字 def construct(digits: list) -&gt; str: result = [] pos, tight, sum_digits, lead = 0, 1, 0, 1 while pos &lt; len(digits): d = choice[pos][tight][sum_digits][lead] if d == -1: return &quot;&quot; result.append(str(d)) tight = tight and d == digits[pos] sum_digits += d lead = lead and d == 0 pos += 1 return &quot;&quot;.join(result) if sum_digits == K and lead == 0 else &quot;&quot; # 计算答案 ans = (count(R) - count(L - 1)) % MOD digits = [int(d) for d in str(R)] number = construct(digits) return ans, number# 测试L, R, K = map(int, input().split())count, number = digit_dp_path(L, R, K)print(&quot;Count of numbers with sum of digits =&quot;, K, &quot;:&quot;, count)print(&quot;One such number:&quot;, number if number else &quot;None&quot;) 6. 运行过程 输入 11 100 5 ( L = 1, R = 100, K = 5 ) 条件：各位之和为 5。 6.1 记忆化递归 计算 ( f(100) )： 数字：( [1, 0, 0] )，3 位。 初始：( solve(0, 1, 0, 1) ). ( pos=0, tight=1, sum=0, lead=1 ): ( d=0 ): ( solve(1, 1, 0, 1) ). ( d=1 ): ( solve(1, 1, 1, 0) ). ( d=2 ): ( solve(1, 0, 2, 0) ). … ( pos=3 ): 检查 ( sum == 5 ). 结果：6（14, 23, 32, 41, 50, 5）。 计算 ( f(0) )： 结果：0（无数字）。 答案：( f(100) - f(0) = 6 - 0 = 6 ). Space：( O(\\log R \\cdot 10 \\cdot K) = O(3 \\cdot 2 \\cdot 6) ). Output: 1Count of numbers with sum of digits = 5 : 6 6.2 路径恢复 DP 和 choice 表格： 同记忆化，( f(100) = 6 ). ( choice[0][1][0][1] = 1 )（选 1）。 ( choice[1][1][1][0] = 4 )（选 4）。 回溯： ( pos=0, tight=1, sum=0, lead=1 ): ( d=1 ). ( pos=1, tight=1, sum=1, lead=0 ): ( d=4 ). ( pos=2 ): ( sum=5 )，结束。 结果：( 14 ). 答案：个数 6，数字 14（可能不同，如 23）。 Space：( O(\\log R \\cdot 10 \\cdot K) ). Output: 12Count of numbers with sum of digits = 5 : 6One such number: 14 7. 数位 DP 的优缺点 7.1 优点 高效计数：( O(\\log R \\cdot S) )，适合 ( R \\leq 10^{18} ). 灵活状态：支持多种条件（如和、模、模式）。 ACM 友好：Python 实现约 40-80 行，比赛中 10-15 分钟完成。 调试方便：打印状态或构造数字，验证正确性。 路径恢复：可输出满足条件的数字。 7.2 缺点 状态设计复杂：需根据条件设计状态（如模、LIS）。 空间需求：( O(\\log R \\cdot S) )，大状态数超内存。 ACM 限制： 复杂状态（( S \\geq 10^6 )）需 C++. 路径恢复增加实现难度。 边界处理： 注意 ( L=1 )、前导零、紧界。 7.3 改进方向 空间优化：滚动数组，空间降到 ( O(S) ). 状态压缩：用位掩码或整数压缩。 快速 I/O：Python 用 sys.stdin.readline. Cython/Numba：加速 Python 循环（非比赛场景）. 预处理：常见条件预计算（如模表）。 8. 与其他问题的对比 数位 DP vs 子集和： 数位 DP：逐位构造，范围计数。 子集和：组合优化，存在性. 数位 DP vs 布尔括号： 数位 DP：数字位计数。 布尔括号：区间 DP，逻辑计数. 数位 DP vs 矩阵链乘法： 数位 DP：计数问题。 矩阵链乘法：优化代价. ACM 适用性： 数位 DP：大范围计数。 子集和：背包 DP。 布尔括号：区间 DP。 矩阵链乘法：区间 DP。 9. 总结 数位 DP 是解决大范围数字计数问题的强大工具，通过逐位构造和动态规划高效统计： 核心方法： 记忆化递归：时间 ( O(\\log R \\cdot S) )，ACM 标配。 路径恢复：输出满足条件的数字。 ACM 应用： 标准计数（Codeforces 1036C）。 路径恢复（SPOJ NDIGITS）。 变种（HDU 4352）。 Python 实现：约 40-80 行，比赛中 10-15 分钟，适合 ( \\log R \\leq 18 )，时间 ≥ 1 秒。 优化：模运算、快速 I/O、状态压缩。 通过记忆化递归和路径恢复的 Python 代码及模拟，展示了数位 DP 的实现和运行过程。在 ACM 竞赛中，数位 DP 是处理大范围计数的核心技术，Python 实现简洁高效。 学习建议： 手动模拟： 用小数据（如 ( R=20, K=5 )）手动构造数字，验证状态转移。 ACM 练习： Codeforces 1036C、HDU 3652、SPOJ NDIGITS，用 Python 实现。 深入扩展： 学习状态压缩（HDU 4352）、多条件、模运算。 比赛策略： 优先实现记忆化递归，验证正确性。 若需数字，添加路径恢复。 若时间严格，考虑 C++.","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"yolo","slug":"yolo","date":"2025-09-13T13:57:08.000Z","updated":"2025-09-13T14:01:34.318Z","comments":true,"path":"2025/09/13/yolo/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/yolo/","excerpt":"","text":"使用 Ultralytics YOLO 进行模型预测 简介 在机器学习和计算机视觉领域，对视觉数据进行理解处理的过程称为“推理”（‘inference’）或“预测”（‘prediction’）。Ultralytics YOLO11 提供了一项强大的功能，即预测模式，专为对各种数据源进行高性能、实时推理而量身定制。 实际应用 制造业 体育 安全 汽车备件检测 足球运动员检测 人员跌倒检测 为什么选择 Ultralytics YOLO 进行推理？ 以下是你应该考虑将 YOLO11 的预测模式用于各种推理需求的原因： 多功能性：能够对图像、视频甚至直播流进行推理。 性能：专为实时、高速处理而设计，同时不牺牲准确性。 易用性：直观的 Python 和 CLI 界面，可实现快速部署和测试。 高度可定制：提供各种设置和参数，以根据你的特定要求调整模型的推理行为。 预测模式的关键功能 YOLO11 的预测模式设计得既稳健又通用，具备以下特点： 多数据源兼容性：无论你的数据是单个图像、一系列图像、视频文件还是实时视频流，预测模式都能处理。 流式处理模式：使用流式处理功能可以生成一个内存高效的 Results 对象生成器。通过在预测器的调用方法中设置 stream=True 来启用此功能。 批量处理：能够一次性处理多张图像或视频帧，进一步加快推理时间。 易于集成：由于其灵活的 API，可以轻松集成到现有的数据管道和其他软件组件中。 Ultralytics YOLO 模型在推理时，如果传递了 stream=True，则返回一个内存高效的 Results 对象生成器；否则，返回一个 Results 对象列表。 !!! example “预测” 12345678910111213141516171819202122232425262728293031323334353637383940414243=== &quot;使用 `stream=False` 返回列表&quot; ```python from ultralytics import YOLO # 加载模型 model = YOLO(&quot;yolo11n.pt&quot;) # 预训练的 YOLO11n 模型 # 对图像列表进行批量推理 results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;]) # 返回一个 Results 对象列表 # 处理结果列表 for result in results: boxes = result.boxes # 用于边界框输出的 Boxes 对象 masks = result.masks # 用于分割掩码输出的 Masks 对象 keypoints = result.keypoints # 用于姿态输出的 Keypoints 对象 probs = result.probs # 用于分类输出的 Probs 对象 obb = result.obb # 用于 OBB 输出的定向框对象 result.show() # 显示到屏幕 result.save(filename=&quot;result.jpg&quot;) # 保存到磁盘 ```=== &quot;使用 `stream=True` 返回生成器&quot; ```python from ultralytics import YOLO # 加载模型 model = YOLO(&quot;yolo11n.pt&quot;) # 预训练的 YOLO11n 模型 # 对图像列表进行批量推理 results = model([&quot;image1.jpg&quot;, &quot;image2.jpg&quot;], stream=True) # 返回一个 Results 对象生成器 # 处理结果生成器 for result in results: boxes = result.boxes # 用于边界框输出的 Boxes 对象 masks = result.masks # 用于分割掩码输出的 Masks 对象 keypoints = result.keypoints # 用于姿态输出的 Keypoints 对象 probs = result.probs # 用于分类输出的 Probs 对象 obb = result.obb # 用于 OBB 输出的定向框对象 result.show() # 显示到屏幕 result.save(filename=&quot;result.jpg&quot;) # 保存到磁盘 ``` 推理源 YOLO11 可以处理不同类型的输入源进行推理，如下表所示。来源包括静态图像、视频流和各种数据格式。该表还指出每个源是否可以使用参数 stream=True 在流式处理模式下使用 ✅。流式处理模式对于处理视频或直播流很有用，因为它会创建一个结果生成器，而不是将所有帧都加载到内存中。 !!! tip 1使用 `stream=True` 来处理长视频或大型数据集，以高效地管理内存。当 `stream=False` 时，所有帧或数据点的结果都存储在内存中，这可能很快累积并导致大型输入出现内存不足错误。相比之下，`stream=True` 使用生成器，它只将当前帧或数据点的结果保存在内存中，从而显著减少内存消耗并防止内存不足问题。 源 示例 类型 备注 图像 'image.jpg' str 或 Path 单个图像文件。 URL 'https://ultralytics.com/images/bus.jpg' str 图像的 URL。 截图 'screen' str 捕获屏幕截图。 PIL Image.open('image.jpg') PIL.Image HWC 格式，带有 RGB 通道。 OpenCV cv2.imread('image.jpg') np.ndarray HWC 格式，带有 BGR 通道 uint8 (0-255)。 numpy np.zeros((640,1280,3)) np.ndarray HWC 格式，带有 BGR 通道 uint8 (0-255)。 torch torch.zeros(16,3,320,640) torch.Tensor BCHW 格式，带有 RGB 通道 float32 (0.0-1.0)。 CSV 'sources.csv' str 或 Path 包含图像、视频或目录路径的 CSV 文件。 视频 ✅ 'video.mp4' str 或 Path 格式为 MP4、AVI 等的视频文件。 目录 ✅ 'path/' str 或 Path 包含图像或视频的目录路径。 glob ✅ 'path/*.jpg' str 用于匹配多个文件的 glob 模式。使用 * 字符作为通配符。 YouTube ✅ 'https://youtu.be/LNwODJXcvt4' str YouTube 视频的 URL。 流 ✅ 'rtsp://example.com/media.mp4' str 用于 RTSP、RTMP、TCP 等流媒体协议或 IP 地址的 URL。 多流 ✅ 'list.streams' str 或 Path .streams 文本文件，每行一个流 URL，即 8 个流将以批量大小 8 运行。 摄像头 ✅ 0 int 连接的摄像头设备的索引，用于运行推理。 以下是使用每种源类型的代码示例： !!! example “预测源” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264=== &quot;图像&quot; 对图像文件运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义图像文件路径 source = &quot;path/to/image.jpg&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;截图&quot; 将当前屏幕内容作为截图运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义当前截图为源 source = &quot;screen&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;URL&quot; 对通过 URL 远程托管的图像或视频运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义远程图像或视频 URL source = &quot;https://ultralytics.com/images/bus.jpg&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;PIL&quot; 对使用 Python Imaging Library (PIL) 打开的图像运行推理。 ```python from PIL import Image from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 使用 PIL 打开图像 source = Image.open(&quot;path/to/image.jpg&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;OpenCV&quot; 对使用 OpenCV 读取的图像运行推理。 ```python import cv2 from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 使用 OpenCV 读取图像 source = cv2.imread(&quot;path/to/image.jpg&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;numpy&quot; 对表示为 numpy 数组的图像运行推理。 ```python import numpy as np from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 创建一个 HWC 形状 (640, 640, 3)，值范围 [0, 255]，类型为 uint8 的随机 numpy 数组 source = np.random.randint(low=0, high=255, size=(640, 640, 3), dtype=&quot;uint8&quot;) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;torch&quot; 对表示为 **PyTorch** 张量的图像运行推理。 ```python import torch from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 创建一个 BCHW 形状 (1, 3, 640, 640)，值范围 [0, 1]，类型为 float32 的随机 torch 张量 source = torch.rand(1, 3, 640, 640, dtype=torch.float32) # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;CSV&quot; 对 CSV 文件中列出的图像、URL、视频和目录集合运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义一个包含图像、URL、视频和目录的 CSV 文件的路径 source = &quot;path/to/file.csv&quot; # 对源运行推理 results = model(source) # Results 对象列表 ```=== &quot;视频&quot; 对视频文件运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少内存使用。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义视频文件路径 source = &quot;path/to/video.mp4&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;目录&quot; 对目录中的所有图像和视频运行推理。若要同时捕获子目录中的图像和视频，请使用 glob 模式，例如 `path/to/dir/**/*`。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义包含用于推理的图像和视频的目录路径 source = &quot;path/to/dir&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;glob&quot; 对所有与带有 `*` 字符的 glob 表达式匹配的图像和视频运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义一个 glob 搜索，以查找目录中的所有 JPG 文件 source = &quot;path/to/dir/*.jpg&quot; # 或者定义一个递归 glob 搜索，以查找包括子目录在内的所有 JPG 文件 source = &quot;path/to/dir/**/*.jpg&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;YouTube&quot; 对 YouTube 视频运行推理。通过使用 `stream=True`，你可以创建一个 `Results` 对象生成器以减少长视频的内存使用。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 定义源为 YouTube 视频 URL source = &quot;https://youtu.be/LNwODJXcvt4&quot; # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ```=== &quot;流&quot; 使用流模式通过 RTSP、RTMP、TCP 或 IP 地址协议对直播流进行推理。如果提供单个流，模型将以**批量大小**为 1 运行推理。对于多个流，可以使用 `.streams` 文本文件执行批量推理，其中批量大小由提供的流数量决定（例如，8 个流的批量大小为 8）。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 批量大小为 1 的单个流推理 source = &quot;rtsp://example.com/media.mp4&quot; # RTSP、RTMP、TCP 或 IP 流地址 # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ``` 对于单个流使用，批量大小默认为 1，从而实现对视频流的高效实时处理。=== &quot;多流&quot; 要同时处理多个视频流，请使用包含流源的 `.streams` 文本文件。模型将运行批量推理，其中批量大小等于流的数量。此设置可实现对多个视频流的并发高效处理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 多个流进行批量推理（例如，8 个流的批量大小为 8） source = &quot;path/to/list.streams&quot; # *.streams 文本文件，每行一个流地址 # 对源运行推理 results = model(source, stream=True) # Results 对象生成器 ``` `.streams` 文本文件示例： ```text rtsp://example.com/media1.mp4 rtsp://example.com/media2.mp4 rtmp://example2.com/live tcp://192.168.1.100:554 ... ``` 文件中的每一行都代表一个流源，让你能够同时监控和对多个视频流进行推理。=== &quot;摄像头&quot; 你可以通过传递特定摄像头的索引来对连接的摄像头设备运行推理。 ```python from ultralytics import YOLO # 加载预训练的 YOLO11n 模型 model = YOLO(&quot;yolo11n.pt&quot;) # 对源运行推理 results = model(source=0, stream=True) # Results 对象生成器 ``` 推理参数 model.predict() 接受多个参数，这些参数可以在推理时传递以覆盖默认值： !!! example 123456789```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对 &#x27;bus.jpg&#x27; 运行推理，并带有参数model.predict(&quot;https://ultralytics.com/images/bus.jpg&quot;, save=True, imgsz=320, conf=0.5)``` 推理参数： 参数 类型 默认值 描述 source str, int, Path 'ultralytics.com/images/bus.jpg' 输入源的路径。可以是文件、目录、URL、视频或 RTMP 流。 model str 'yolov11n.pt' 要运行推理的模型文件的路径。 conf float 0.25 对象置信度阈值。 iou float 0.7 边界框交并比 (IoU) 阈值，用于非最大抑制 (NMS)。 imgsz int 或 tuple 640 输入图像的大小，可以是单个整数（正方形）或 (高度, 宽度) 元组。 half bool False 如果 GPU 可用，则使用 FP16 半精度推理。 device int 或 str None 要使用的设备（例如 cuda:0 或 0,1,2,3 或 cpu）。 show bool False 是否在屏幕上显示结果。 save bool False 是否将预测结果保存到文件中。 save_txt bool False 是否将预测结果以 .txt 格式保存。 save_conf bool False 是否在保存的标签中包含置信度分数。 save_crop bool False 是否保存裁剪后的预测结果。 hide_labels bool False 是否隐藏预测标签。 hide_conf bool False 是否隐藏预测置信度分数。 max_det int 300 每张图像的最大检测数量。 vid_stride int 1 视频帧步长。 stream_buffer bool False 是否缓冲流帧。 line_thickness int 2 边界框的线条粗细（以像素为单位）。 visualize bool False 在模型推理期间可视化模型特征。 augment bool False 在推理时应用图像增强（测试时增强）。 agnostic_nms bool False 执行类别无关的非最大抑制（NMS）。 retina_masks bool False 使用高分辨率分割掩码。 boxes bool True 是否在结果中显示边界框。 可视化参数： 参数 类型 描述 默认值 conf bool 包含检测置信度分数。 True line_width float 边界框的线条宽度。如果为 None，则随图像大小缩放。 None font_size float 文本字体大小。如果为 None，则随图像大小缩放。 None font str 文本注释的字体名称。 'Arial.ttf' pil bool 将图像作为 PIL Image 对象返回。 False img np.ndarray 用于绘图的替代图像。如果为 None，则使用原始图像。 None im_gpu torch.Tensor 用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。 None kpt_radius int 绘制的关键点的半径。 5 kpt_line bool 用线条连接关键点。 True labels bool 在注释中包含类别标签。 True boxes bool 在图像上叠加边界框。 True masks bool 在图像上叠加掩码。 True probs bool 包含分类概率。 True show bool 使用默认图像查看器直接显示带注释的图像。 False save bool 将带注释的图像保存到由 filename 指定的文件。 False filename str 如果 save 为 True，则为保存带注释的图像的文件路径和名称。 None color_mode str 指定颜色模式，例如 ‘instance’ 或 ‘class’。 'class' txt_color tuple[int, int, int] 边界框和图像分类标签的 RGB 文本颜色。 (255, 255, 255) 图像和视频格式 YOLO11 支持多种图像和视频格式，具体请参见 ultralytics/data/utils.py。下表列出了有效的后缀和预测命令示例。 图像 下表包含有效的 Ultralytics 图像格式。 !!! note 1HEIC 图像仅支持推理，不支持训练。 图像后缀 预测命令示例 参考 .bmp yolo predict source=image.bmp Microsoft BMP 文件格式 .dng yolo predict source=image.dng Adobe DNG .jpeg yolo predict source=image.jpeg JPEG .jpg yolo predict source=image.jpg JPEG .mpo yolo predict source=image.mpo 多图片对象 .png yolo predict source=image.png 便携式网络图形 .tif yolo predict source=image.tif 标签图像文件格式 .tiff yolo predict source=image.tiff 标签图像文件格式 .webp yolo predict source=image.webp WebP .pfm yolo predict source=image.pfm 便携式浮点地图 .HEIC yolo predict source=image.HEIC 高效图像文件格式 视频 下表包含有效的 Ultralytics 视频格式。 视频后缀 预测命令示例 参考 .asf yolo predict source=video.asf 高级系统格式 .avi yolo predict source=video.avi 音频视频交错 .gif yolo predict source=video.gif 图形交换格式 .m4v yolo predict source=video.m4v MPEG-4 Part 14 .mkv yolo predict source=video.mkv Matroska .mov yolo predict source=video.mov QuickTime 文件格式 .mp4 yolo predict source=video.mp4 MPEG-4 Part 14 - Wikipedia .mpeg yolo predict source=video.mpeg MPEG-1 Part 2 .mpg yolo predict source=video.mpg MPEG-1 Part 2 .ts yolo predict source=video.ts MPEG 传输流 .wmv yolo predict source=video.wmv Windows Media Video .webm yolo predict source=video.webm WebM 项目 处理结果 所有 Ultralytics 的 predict() 调用都将返回一个 Results 对象列表： !!! example “结果” 123456789101112131415```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;)results = model( [ &quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;, ]) # 批量推理``` Results 对象具有以下属性： 属性 类型 描述 orig_img np.ndarray 作为 numpy 数组的原始图像。 orig_shape tuple 原始图像形状，格式为 (高度, 宽度)。 boxes Boxes, optional 包含检测边界框的 Boxes 对象。 masks Masks, optional 包含检测掩码的 Masks 对象。 probs Probs, optional 包含用于分类任务的每个类别的概率的 Probs 对象。 keypoints Keypoints, optional 包含每个对象检测到的关键点的 Keypoints 对象。 obb OBB, optional 包含定向边界框的 OBB 对象。 speed dict 字典，包含每个图像的预处理、推理和后处理速度（以毫秒为单位）。 names dict 将类别索引映射到类别名称的字典。 path str 图像文件路径。 save_dir str, optional 保存结果的目录。 Results 对象具有以下方法： 方法 返回类型 描述 update() None 使用新的检测数据（框、掩码、概率、OBB、关键点）更新 Results 对象。 cpu() Results 返回 Results 对象的副本，所有张量都已移动到 CPU 内存。 numpy() Results 返回 Results 对象的副本，所有张量都已转换为 numpy 数组。 cuda() Results 返回 Results 对象的副本，所有张量都已移动到 GPU 内存。 to() Results 返回 Results 对象的副本，其中张量已移动到指定的设备和数据类型。 new() Results 创建一个具有相同图像、路径、名称和速度属性的新 Results 对象。 plot() np.ndarray 在输入的 RGB 图像上绘制检测结果并返回带注释的图像。 show() None 显示带有注释的推理结果图像。 save() str 将带有注释的推理结果图像保存到文件并返回文件名。 verbose() str 返回每个任务的日志字符串，详细说明检测和分类结果。 save_txt() str 将检测结果保存到文本文件并返回保存文件的路径。 save_crop() None 将裁剪后的检测图像保存到指定的目录。 summary() List[Dict[str, Any]] 将推理结果转换为摘要字典，并可选择进行归一化。 to_df() DataFrame 将检测结果转换为 Polars DataFrame。 to_csv() str 将检测结果转换为 CSV 格式。 to_json() str 将检测结果转换为 JSON 格式。 有关更多详细信息，请参阅 Results 类文档。 Boxes Boxes 对象可用于索引、操作和将边界框转换为不同格式。 !!! example “Boxes” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.boxes) # 打印包含检测边界框的 Boxes 对象``` 下表列出了 Boxes 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 将对象移动到 CPU 内存。 numpy() 方法 将对象转换为 numpy 数组。 cuda() 方法 将对象移动到 CUDA 内存。 to() 方法 将对象移动到指定的设备。 xyxy 属性 (torch.Tensor) 以 xyxy 格式返回框。 conf 属性 (torch.Tensor) 返回框的置信度值。 cls 属性 (torch.Tensor) 返回框的类别值。 id 属性 (torch.Tensor) 返回框的跟踪 ID（如果可用）。 xywh 属性 (torch.Tensor) 以 xywh 格式返回框。 xyxyn 属性 (torch.Tensor) 以 xyxy 格式返回归一化后的框（通过原始图像大小）。 xywhn 属性 (torch.Tensor) 以 xywh 格式返回归一化后的框（通过原始图像大小）。 有关更多详细信息，请参阅 Boxes 类文档。 Masks Masks 对象可用于索引、操作和将掩码转换为段。 !!! example “Masks” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-seg 分割模型model = YOLO(&quot;yolo11n-seg.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.masks) # 打印包含检测到的实例掩码的 Masks 对象``` 下表列出了 Masks 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回掩码张量。 numpy() 方法 将掩码张量作为 numpy 数组返回。 cuda() 方法 在 GPU 内存上返回掩码张量。 to() 方法 返回具有指定设备和数据类型的掩码张量。 xyn 属性 (torch.Tensor) 表示为张量的归一化段列表。 xy 属性 (torch.Tensor) 表示为张量的像素坐标中的段列表。 有关更多详细信息，请参阅 Masks 类文档。 Keypoints Keypoints 对象可用于索引、操作和归一化坐标。 !!! example “Keypoints” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-pose 姿态模型model = YOLO(&quot;yolo11n-pose.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.keypoints) # 打印包含检测到的关键点的 Keypoints 对象``` 下表列出了 Keypoints 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回关键点张量。 numpy() 方法 将关键点张量作为 numpy 数组返回。 cuda() 方法 在 GPU 内存上返回关键点张量。 to() 方法 返回具有指定设备和数据类型的关键点张量。 xyn 属性 (torch.Tensor) 表示为张量的归一化关键点列表。 xy 属性 (torch.Tensor) 表示为张量的像素坐标中的关键点列表。 conf 属性 (torch.Tensor) 如果可用，返回关键点的置信度值，否则为 None。 有关更多详细信息，请参阅 Keypoints 类文档。 Probs Probs 对象可用于索引，获取分类的 top1 和 top5 索引和分数。 !!! example “Probs” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n-cls 分类模型model = YOLO(&quot;yolo11n-cls.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/bus.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.probs) # 打印包含检测到的类别概率的 Probs 对象``` 下表总结了 Probs 类的方法和属性： 名称 类型 描述 cpu() 方法 在 CPU 内存上返回概率张量的副本。 numpy() 方法 将概率张量作为 numpy 数组返回副本。 cuda() 方法 在 GPU 内存上返回概率张量的副本。 to() 方法 返回具有指定设备和数据类型的概率张量的副本。 top1 属性 (int) top 1 类别的索引。 top5 属性 (list[int]) top 5 类别的索引。 top1conf 属性 (torch.Tensor) top 1 类别的置信度。 top5conf 属性 (torch.Tensor) top 5 类别的置信度。 有关更多详细信息，请参阅 Probs 类文档。 OBB OBB 对象可用于索引、操作和将定向边界框转换为不同格式。 !!! example “OBB” 12345678910111213```pythonfrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n-obb.pt&quot;)# 对图像运行推理results = model(&quot;https://ultralytics.com/images/boats.jpg&quot;) # 结果列表# 查看结果for r in results: print(r.obb) # 打印包含定向检测边界框的 OBB 对象``` 下表列出了 OBB 类的方法和属性，包括它们的名称、类型和描述： 名称 类型 描述 cpu() 方法 将对象移动到 CPU 内存。 numpy() 方法 将对象转换为 numpy 数组。 cuda() 方法 将对象移动到 CUDA 内存。 to() 方法 将对象移动到指定的设备。 conf 属性 (torch.Tensor) 返回框的置信度值。 cls 属性 (torch.Tensor) 返回框的类别值。 id 属性 (torch.Tensor) 返回框的跟踪 ID（如果可用）。 xyxy 属性 (torch.Tensor) 以 xyxy 格式返回水平框。 xywhr 属性 (torch.Tensor) 以 xywhr 格式返回旋转框。 xyxyxyxy 属性 (torch.Tensor) 以 xyxyxyxy 格式返回旋转框。 xyxyxyxyn 属性 (torch.Tensor) 以 xyxyxyxy 格式返回归一化后的旋转框（通过图像大小）。 有关更多详细信息，请参阅 OBB 类文档。 绘制结果 Results 对象中的 plot() 方法通过在原始图像上叠加检测到的对象（如边界框、掩码、关键点和概率）来方便可视化预测。此方法将带注释的图像作为 NumPy 数组返回，便于显示或保存。 !!! example “绘图” 1234567891011121314151617181920212223```pythonfrom PIL import Imagefrom ultralytics import YOLO# 加载预训练的 YOLO11n 模型model = YOLO(&quot;yolo11n.pt&quot;)# 对 &#x27;bus.jpg&#x27; 运行推理results = model([&quot;https://ultralytics.com/images/bus.jpg&quot;, &quot;https://ultralytics.com/images/zidane.jpg&quot;]) # 结果列表# 可视化结果for i, r in enumerate(results): # 绘制结果图像 im_bgr = r.plot() # BGR 顺序的 numpy 数组 im_rgb = Image.fromarray(im_bgr[..., ::-1]) # RGB 顺序的 PIL 图像 # 将结果显示到屏幕（在支持的环境中） r.show() # 将结果保存到磁盘 r.save(filename=f&quot;results&#123;i&#125;.jpg&quot;)``` plot() 方法参数 plot() 方法支持各种参数来自定义输出： 参数 类型 描述 默认值 conf bool 包含检测置信度分数。 True line_width float 边界框的线条宽度。如果为 None，则随图像大小缩放。 None font_size float 文本字体大小。如果为 None，则随图像大小缩放。 None font str 文本注释的字体名称。 'Arial.ttf' pil bool 将图像作为 PIL Image 对象返回。 False img np.ndarray 用于绘图的替代图像。如果为 None，则使用原始图像。 None im_gpu torch.Tensor 用于更快掩码绘图的 GPU 加速图像。形状：(1, 3, 640, 640)。 None kpt_radius int 绘制的关键点的半径。 5 kpt_line bool 用线条连接关键点。 True labels bool 在注释中包含类别标签。 True boxes bool 在图像上叠加边界框。 True masks bool 在图像上叠加掩码。 True probs bool 包含分类概率。 True show bool 使用默认图像查看器直接显示带注释的图像。 False save bool 将带注释的图像保存到由 filename 指定的文件。 False filename str 如果 save 为 True，则为保存带注释的图像的文件路径和名称。 None color_mode str 指定颜色模式，例如 ‘instance’ 或 ‘class’。 'class' txt_color tuple[int, int, int] 边界框和图像分类标签的 RGB 文本颜色。 (255, 255, 255) 线程安全推理 当你在不同线程中并行运行多个 YOLO 模型时，确保推理的线程安全至关重要。线程安全推理可确保每个线程的预测是隔离的，并且不会相互干扰，从而避免竞态条件并确保一致且可靠的输出。 在多线程应用程序中使用 YOLO 模型时，为每个线程实例化单独的模型对象或采用线程本地存储以防止冲突非常重要： !!! example “线程安全推理” 123456789101112131415161718在每个线程内实例化一个模型，以实现线程安全推理：```pythonfrom threading import Threadfrom ultralytics import YOLOdef thread_safe_predict(model, image_path): &quot;&quot;&quot;使用本地实例化的 YOLO 模型对图像执行线程安全预测。&quot;&quot;&quot; model = YOLO(model) results = model.predict(image_path) # 处理结果# 启动每个线程都有自己模型实例的线程Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image1.jpg&quot;)).start()Thread(target=thread_safe_predict, args=(&quot;yolo11n.pt&quot;, &quot;image2.jpg&quot;)).start()``` 要深入了解 YOLO 模型的线程安全推理和分步说明，请参阅我们的 YOLO 线程安全推理指南。本指南将为你提供所有必要的信息，以避免常见陷阱并确保你的多线程推理顺利运行。 流式处理源 for 循环 这是一个使用 OpenCV (cv2) 和 YOLO 对视频帧运行推理的 Python 脚本。该脚本假设你已安装所需的包（opencv-python 和 ultralytics）。 !!! example “流式处理 for 循环” 1234567891011121314151617181920212223242526272829303132333435363738```pythonimport cv2from ultralytics import YOLO# 加载 YOLO 模型model = YOLO(&quot;yolo11n.pt&quot;)# 打开视频文件video_path = &quot;path/to/your/video/file.mp4&quot;cap = cv2.VideoCapture(video_path)# 循环遍历视频帧while cap.isOpened(): # 从视频中读取一帧 success, frame = cap.read() if success: # 在帧上运行 YOLO 推理 results = model(frame) # 在帧上可视化结果 annotated_frame = results[0].plot() # 显示带注释的帧 cv2.imshow(&quot;YOLO Inference&quot;, annotated_frame) # 如果按下 &#x27;q&#x27; 键，则中断循环 if cv2.waitKey(1) &amp; 0xFF == ord(&quot;q&quot;): break else: # 如果到达视频末尾，则中断循环 break# 释放视频捕获对象并关闭显示窗口cap.release()cv2.destroyAllWindows()``` 该脚本将在视频的每一帧上运行预测，可视化结果，并在窗口中显示它们。可以通过按 ‘q’ 键退出循环。 常见问题 (FAQ) 什么是 Ultralytics YOLO 及其用于实时推理的预测模式？ Ultralytics YOLO 是一种用于实时目标检测、分割和分类的最新模型。其预测模式允许用户对各种数据源（如图像、视频和直播流）执行高速推理。它专为性能和多功能性而设计，还提供批量处理和流式处理模式。有关其功能的更多详细信息，请查看 Ultralytics YOLO 预测模式。 如何使用 Ultralytics YOLO 对不同的数据源运行推理？ Ultralytics YOLO 可以处理各种数据源，包括单个图像、视频、目录、URL 和流。你可以在 model.predict() 调用中指定数据源。例如，对于本地图像，使用 'image.jpg'；对于 URL，使用 'https://ultralytics.com/images/bus.jpg'。请查看文档中关于各种推理源的详细示例。 如何优化 YOLO 推理速度和内存使用？ 要优化推理速度并高效管理内存，你可以通过在预测器的调用方法中设置 stream=True 来使用流式处理模式。流式处理模式会生成一个内存高效的 Results 对象生成器，而不是将所有帧加载到内存中。对于处理长视频或大型数据集，流式处理模式特别有用。了解有关流式处理模式的更多信息。 Ultralytics YOLO 支持哪些推理参数？ YOLO 中的 model.predict() 方法支持各种参数，例如 conf、iou、imgsz、device 等。这些参数允许你自定义推理过程，设置置信度阈值、图像大小和用于计算的设备等参数。这些参数的详细说明可以在推理参数部分找到。 如何可视化和保存 YOLO 预测结果？ 使用 YOLO 运行推理后，Results 对象包含用于显示和保存带注释图像的方法。你可以使用 result.show() 和 result.save(filename=&quot;result.jpg&quot;) 等方法来可视化和保存结果。有关这些方法的完整列表，请参阅处理结果部分。 []: # []: # []: #","categories":[],"tags":[{"name":"文档、库","slug":"文档、库","permalink":"https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"}]},{"title":"线段树","slug":"线段树","date":"2025-09-13T12:57:08.000Z","updated":"2025-09-13T13:37:52.139Z","comments":true,"path":"2025/09/13/线段树/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"1. 什么是线段树？ 线段树是一种二叉树数据结构，用于存储区间（或称为“线段”）的信息，并支持快速的查询和更新操作。它特别适合解决与区间相关的动态问题，例如： 求某个区间的和。 查找某个区间的最大值或最小值。 对某个区间进行批量更新。 线段树的核心思想是将一个大区间递归地划分成多个小子区间，并通过树形结构高效地维护和查询这些区间的聚合信息。 2. 线段树的结构 线段树的结构可以用以下方式描述： 节点：每个节点代表一个区间。 根节点：代表整个区间（例如数组的范围[1, n]）。 叶子节点：代表单个元素（例如数组中的某个值）。 中间节点：代表某个子区间（介于根节点和叶子节点之间）。 例如，对于一个数组[1, 3, 5, 7, 9, 11]，线段树的结构如下： 根节点表示区间[1, 6]。 根的左子节点表示[1, 3]，右子节点表示[4, 6]。 进一步划分后，叶子节点分别表示[1, 1]、[2, 2]、[3, 3]、[4, 4]、[5, 5]和[6, 6]。 这种递归划分的方式使得线段树能够高效地处理区间问题。 3. 线段树的基本操作 线段树主要支持以下两种核心操作： 查询（Query） 查询操作用于获取某个区间的聚合信息，例如： 区间的和。 区间的最大值或最小值。 更新（Update） 更新操作用于修改数据，例如： 修改单个元素的值（单点更新）。 对某个区间的元素进行批量修改（区间更新）。 这两种操作的时间复杂度均为O(log n)，其中n是数组的大小。这是对数级别的高效性使得线段树非常适合动态查询问题。 4. 线段树的构建 线段树的构建是一个递归过程，通常自底向上完成。以下是构建线段树的基本步骤： 从根节点开始：根节点表示整个区间，例如[1, n]。 划分区间：将当前区间划分为两个子区间，例如[1, mid]和[mid+1, n]，其中mid = (left + right) / 2。 递归构建子树：对左子区间和右子区间分别递归构建子树，直到达到叶子节点。 合并信息：在回溯时，根据具体问题将子节点的信息合并到当前节点。例如，对于区间求和问题，当前节点的值是左子节点和右子节点值的和。 示例： 对于数组[1, 3, 5, 7, 9, 11]： 根节点存储[1, 6]的和：1 + 3 + 5 + 7 + 9 + 11 = 36。 左子节点存储[1, 3]的和：1 + 3 + 5 = 9。 右子节点存储[4, 6]的和：7 + 9 + 11 = 27。 递归继续，直到叶子节点存储单个元素。 5. 线段树的查询 查询操作同样是递归进行的，用于在O(log n)时间内获取某个区间的聚合信息。查询步骤如下： 判断当前区间与查询区间的关系： 完全包含：如果当前区间完全在查询区间内，直接返回当前节点的值。 无交集：如果当前区间与查询区间无重叠，返回一个不影响结果的值（例如求和时返回0，求最大值时返回负无穷）。 部分重叠：递归查询左子树和右子树，并合并结果。 合并结果：根据具体问题合并子查询的结果。例如，求和时将左右子树的结果相加。 示例： 查询数组[1, 3, 5, 7, 9, 11]中区间[2, 5]的和： 根节点[1, 6]与[2, 5]部分重叠，递归查询子节点。 左子节点[1, 3]与[2, 5]部分重叠，继续递归，最终得到[2, 3]的和3 + 5 = 8。 右子节点[4, 6]与[2, 5]部分重叠，最终得到[4, 5]的和7 + 9 = 16。 合并结果：8 + 16 = 24。 6. 线段树的更新 更新操作分为两种类型： 单点更新 修改数组中某个元素的值，并更新线段树中所有相关节点： 递归找到对应的叶子节点。 更新叶子节点的值。 回溯时，更新所有包含该叶子节点的父节点。 示例： 将数组[1, 3, 5, 7, 9, 11]中的第2个元素从3改为10： 找到叶子节点[2, 2]，更新值为10。 向上更新：[1, 3]的和从9变为1 + 10 + 5 = 16，根节点[1, 6]的和从36变为43。 区间更新 对某个区间的元素进行批量修改，例如将区间[2, 4]的所有值增加5。通常使用**延迟标记（Lazy Propagation）**优化，避免直接更新所有叶子节点： 在需要更新的节点上记录延迟标记。 在下次查询或更新时，将标记传播到子节点。 7. 线段树的空间复杂度 线段树是一个近似满二叉树，节点总数约为2n-1，因此空间复杂度为O(n)，其中n是数组的大小。 8. 线段树的应用 线段树在算法问题中有广泛应用，包括但不限于： 区间求和：计算任意区间的和。 区间最值：查找任意区间的最大值或最小值。 区间更新：对某个区间批量加减一个值。 动态规划优化：加速某些状态转移。 9. 线段树的优点与缺点 优点 查询和更新时间复杂度均为O(log n)，高效处理动态问题。 灵活性强，可根据问题定制功能。 缺点 实现相对复杂，代码量较大。 空间消耗较高，需要额外的O(n)存储。 9. 手动实现线段树 由于 Python 标准库和主流第三方库中没有直接提供线段树，开发者通常会根据问题需求手动实现。以下是一个简单的 Python 线段树实现，用于支持区间求和和单点更新，并包含详细注释以便理解。 代码实现：区间求和线段树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from typing import Listclass SegmentTree: def __init__(self, arr: List[int]): &quot;&quot;&quot;初始化线段树，arr 是输入数组&quot;&quot;&quot; self.n = len(arr) # 数组长度 self.tree = [0] * (4 * self.n) # 线段树数组，4n 足以容纳所有节点 self.arr = arr # 保存原始数组 if self.n &gt; 0: self._build(0, 0, self.n - 1) # 递归构建线段树 def _build(self, node: int, start: int, end: int): &quot;&quot;&quot;递归构建线段树，node 是当前节点，[start, end] 是当前区间&quot;&quot;&quot; if start == end: # 叶子节点，直接存储数组元素 self.tree[node] = self.arr[start] return mid = (start + end) // 2 left_node = 2 * node + 1 # 左子节点 right_node = 2 * node + 2 # 右子节点 # 递归构建左右子树 self._build(left_node, start, mid) self._build(right_node, mid + 1, end) # 合并子节点信息：当前节点存储左右子节点的和 self.tree[node] = self.tree[left_node] + self.tree[right_node] def update(self, index: int, value: int): &quot;&quot;&quot;单点更新：将 arr[index] 更新为 value&quot;&quot;&quot; self.arr[index] = value self._update(0, 0, self.n - 1, index, value) def _update(self, node: int, start: int, end: int, index: int, value: int): &quot;&quot;&quot;递归更新线段树，index 是要更新的位置，value 是新值&quot;&quot;&quot; if start == end: # 叶子节点，直接更新 self.tree[node] = value return mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归更新左子树或右子树 if index &lt;= mid: self._update(left_node, start, mid, index, value) else: self._update(right_node, mid + 1, end, index, value) # 合并更新后的子节点信息 self.tree[node] = self.tree[left_node] + self.tree[right_node] def query(self, left: int, right: int) -&gt; int: &quot;&quot;&quot;查询区间 [left, right] 的和&quot;&quot;&quot; return self._query(0, 0, self.n - 1, left, right) def _query(self, node: int, start: int, end: int, left: int, right: int) -&gt; int: &quot;&quot;&quot;递归查询 [left, right] 的和&quot;&quot;&quot; if left &lt;= start and end &lt;= right: # 当前区间完全包含在查询区间内，直接返回节点值 return self.tree[node] if right &lt; start or left &gt; end: # 当前区间与查询区间无交集，返回 0 return 0 mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 # 递归查询左右子树，并合并结果 left_sum = self._query(left_node, start, mid, left, right) right_sum = self._query(right_node, mid + 1, end, left, right) return left_sum + right_sum# 测试代码if __name__ == &quot;__main__&quot;: # 初始数组 arr = [1, 3, 5, 7, 9, 11] seg_tree = SegmentTree(arr) # 测试查询 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：3 + 5 + 7 = 15 # 测试更新 seg_tree.update(1, 10) # 将 arr[1] 从 3 更新为 10 print(seg_tree.query(1, 3)) # 查询 [1, 3] 的和：10 + 5 + 7 = 22 代码说明 初始化 (__init__)： 创建线段树数组 tree，大小为 4n（足以容纳所有节点）。 调用 _build 递归构建线段树，存储每个区间的和。 构建 (_build)： 递归划分区间，直到叶子节点。 叶子节点存储原始数组元素，中间节点存储子节点和。 更新 (update 和 _update)： 单点更新：递归找到对应的叶子节点，更新值。 回溯时更新所有相关父节点的和。 查询 (query 和 _query)： 查询区间 [left, right] 的和。 递归处理三种情况：完全包含、无交集、部分重叠。 时间复杂度： 构建：( O(n) ) 查询：( O(\\log n) ) 更新：( O(\\log n) ) 空间复杂度： ( O(n) )，线段树需要 ( 4n ) 的空间。 10. 线段树的高级功能（需要时可扩展实现） 手动实现的线段树可以根据问题需求扩展，以下是常见的高级功能： 区间更新（Lazy Propagation）： 支持对整个区间批量修改（如将 [l, r] 的值增加一个常数）。 使用延迟标记（lazy tag）记录未传播的更新，减少时间开销。 适用场景：动态修改大范围数据。 区间最值： 修改线段树存储最大值或最小值，而不是和。 例如，查询 [l, r] 的最大值，只需将合并操作从 + 改为 max。 动态线段树： 支持动态添加或删除节点，适用于数据范围不确定的场景。 实现较复杂，通常结合指针或动态分配。 持久化线段树： 保留线段树的历史版本，支持查询历史状态。 常用于函数式编程或需要回溯的问题。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"动态规划","slug":"动态规划","date":"2025-09-13T11:16:41.000Z","updated":"2025-09-14T04:36:12.417Z","comments":true,"path":"2025/09/13/动态规划/","permalink":"https://borrowyourhuaji.github.io/2025/09/13/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"动态规划（Dynamic Programming，简称 DP）是算法设计中的一种重要方法，用于解决具有 重叠子问题 和 最优子结构 的优化问题。它通过将问题分解为较小的子问题，存储子问题的解以避免重复计算，从而高效求解复杂问题。在 ACM 竞赛 中，DP 是核心技巧，广泛应用于序列、图、树、背包、区间等问题。 1. 动态规划的基本概念 1.1 定义 动态规划是一种通过 分阶段 解决问题的方法，每个阶段的决策依赖于前几个阶段的解。DP 的核心思想是： 分解问题：将原问题分解为若干子问题。 存储中间结果：用表格（数组或哈希表）保存子问题的解，避免重复计算。 递归求解：通过子问题的解递归构建原问题的解。 DP 通常用于求解 最优化问题（如最大值、最小值、最短路径）或 计数问题（如方案数），其适用条件包括： 最优子结构：原问题的最优解可由子问题的最优解构成。 重叠子问题：子问题在递归分解中被多次求解，适合存储优化。 无后效性：当前阶段的决策只依赖于之前阶段的状态，不受后续决策影响。 示例： 斐波那契数列：第 ( n ) 项 ( F(n) = F(n-1) + F(n-2) )，子问题重叠，直接递归效率低，DP 存储中间结果优化。 最长公共子序列（LCS）：字符串 ( A ) 和 ( B ) 的 LCS 依赖于前缀的 LCS，具有最优子结构。 1.2 关键性质 状态（State）：用变量表示子问题的解，通常是数组或多维表格，如 ( dp[i] ) 表示前 ( i ) 项的最优解。 状态转移方程（Transition）：描述如何从已知状态推导新状态，如 ( dp[i] = \\max(dp[i-1], dp[i-2]) )。 初始条件（Base Case）：DP 表格的起点，如 ( dp[0] = 0 )。 目标：最终求解的状态，如 ( dp[n] )。 时间复杂度：通常为 ( O(\\text{状态数} \\times \\text{转移复杂度}) ). 空间复杂度：取决于状态存储，通常为 ( O(\\text{状态数}) )，可通过滚动数组优化。 1.3 DP 与其他方法的区别 与递归（Recursion）： 递归直接分解问题，可能重复计算子问题（指数复杂度）。 DP 存储子问题解（通常多项式复杂度）。 与分治（Divide and Conquer）： 分治将问题分为独立子问题（如归并排序）。 DP 处理重叠子问题，子问题间有依赖。 与贪心（Greedy）： 贪心基于局部最优，适用于特定问题（如活动选择）。 DP 考虑全局最优，适用范围更广（如 0-1 背包）。 1.4 DP 的设计步骤 定义状态：确定 ( dp[i][j]… ) 表示什么，通常与子问题相关。 推导状态转移方程：分析当前状态如何由前几个状态得出。 确定初始条件：初始化边界状态（如 ( dp[0][0] )。 计算顺序：确保状态按依赖顺序计算（自底向上或记忆化递归）。 求解目标：输出最终状态（如 ( dp[n][m] \\）。 优化空间：若状态只依赖前几行/列，用滚动数组减少空间。 1.5 常见 DP 类型 线性 DP：状态沿一维序列转移，如斐波那契、LIS（最长递增子序列）。 背包 DP：处理资源分配，如 0-1 背包、完全背包。 区间 DP：处理区间合并或分割，如石子合并、括号匹配。 树形 DP：在树上进行状态转移，如树的最小支配集。 状态压缩 DP：用二进制表示状态，适合小规模集合问题。 数位 DP：处理数字范围内的计数问题，如数字和。 概率/期望 DP：计算概率或期望值，如博弈问题。 多维 DP：处理多变量状态，如 LCS、编辑距离。 1.6 应用场景 ACM 竞赛： 序列问题：LIS、LCS、编辑距离。 背包问题：0-1 背包、完全背包、多重背包。 区间问题：石子合并、区间调度。 树上问题：树形 DP、最小点覆盖。 图上问题：最短路径、DAG 上的 DP。 实际应用： 机器学习：隐马尔可夫模型（HMM）、Viterbi 算法。 运筹学：资源分配、调度优化。 生物信息学：序列比对。 1.7 复杂度分析 时间复杂度：( O(\\text{状态数} \\times \\text{转移复杂度}) )。 例：LCS 为 ( O(n \\times m) )，状态数 ( n \\times m )，转移 ( O(1) )。 空间复杂度：( O(\\text{状态数}) )，可通过滚动数组优化到 ( O(\\text{较小维度}) )。 记忆化递归：与递推等价，适合状态空间稀疏或难以确定计算顺序。 2. 动态规划的编程方法 DP 的实现方式主要分为 递推（Bottom-Up） 和 记忆化递归（Top-Down），以下详细讲解两种方法的特点和实现步骤。 2.1 递推（Bottom-Up） 特点： 自底向上计算，从初始状态递推到目标状态。 使用循环填充 DP 表格，适合状态空间连续。 空间效率高，易于优化（如滚动数组）。 步骤： 定义 DP 数组（如 ( dp[i][j] )）。 初始化边界条件。 按状态依赖顺序循环，计算状态转移。 返回目标状态。 适用场景：状态空间明确，计算顺序简单（如线性 DP、背包 DP）。 优点： 避免递归开销，运行效率高。 易于调试，状态计算顺序清晰。 缺点： 状态空间稀疏时可能浪费计算。 复杂状态转移可能难以推导。 示例：0-1 背包问题 问题：给定 ( n ) 个物品，重量 ( w[i] )，价值 ( v[i] )，背包容量 ( W )，求最大价值。 状态：( dp[i][j] ) 表示前 ( i ) 个物品，容量 ( j ) 时的最大价值。 转移：( dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) )（若 ( j \\geq w[i] )）。 初始：( dp[0][j] = 0 )，( dp[i][0] = 0 )。 目标：( dp[n][W] ). 2.2 记忆化递归（Top-Down） 特点： 自顶向下递归，从目标状态分解到子问题。 使用记忆化（Memoization）存储已计算的子问题解。 适合状态空间稀疏或状态转移复杂。 步骤： 定义递归函数，参数表示状态。 创建记忆化表格（如字典或数组）。 在递归中检查是否已计算，若是返回缓存结果。 计算状态转移，存储结果。 适用场景：状态空间不规则、递归关系复杂（如树形 DP、数位 DP）。 优点： 代码直观，递归逻辑易于理解。 仅计算用到的状态，适合稀疏问题。 缺点： 递归栈开销大，可能导致栈溢出。 Python 递归深度有限，需调整或转为递推。 示例：最长公共子序列（LCS） 问题：给定字符串 ( A ) 和 ( B )，求最长公共子序列长度。 状态：( dp[i][j] ) 表示 ( A[0:i] ) 和 ( B[0:j] ) 的 LCS 长度。 转移： 若 ( A[i-1] == B[j-1] )，则 ( dp[i][j] = dp[i-1][j-1] + 1 )。 否则，( dp[i][j] = \\max(dp[i-1][j], dp[i][j-1]) )。 初始：( dp[0][j] = 0 )，( dp[i][0] = 0 ). 目标：( dp[|A|][|B|] ). 2.3 空间优化 滚动数组： 若状态只依赖前几行/列，用小数组覆盖大数组。 例：0-1 背包从 ( dp[n][W] ) 优化到 ( dp[W] )，空间 ( O(W) ). 状态压缩： 用位运算表示状态，适合状态压缩 DP。 例：TSP（旅行商问题），状态从 ( O(n \\times 2^n) ) 压缩到 ( O(2^n) ). 稀疏存储： 用字典或哈希表存储非零状态，适合记忆化递归。 2.4 调试与优化 调试： 打印 DP 表格，验证状态转移。 检查边界条件和初始值。 用小数据手动模拟，确保逻辑正确。 优化： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 常数优化：减少循环内操作，如提前计算常量。 并行化：复杂 DP 可分块并行（非比赛场景）。 Cython/Numba：加速 Python 循环（非比赛场景）。 3. 在 ACM 竞赛中的应用 DP 在 ACM 竞赛中是解决优化和计数问题的核心工具，因其 通用性 和 高效性 广泛应用于各种题型。以下是常见类型和解题思路： 线性 DP： 题目：求序列的最优解，如最长递增子序列（LIS）。 解法：定义 ( dp[i] ) 为以 ( i ) 结尾的最优解，转移考虑前序状态。 示例：Luogu P1020（导弹拦截，LIS）。 方法： 状态：( dp[i] ) 表示以 ( a[i] ) 结尾的 LIS 长度。 转移：( dp[i] = \\max(dp[j]) + 1 )，其中 ( j &lt; i )，( a[j] &lt; a[i] ). 复杂度：( O(n^2) )，可优化到 ( O(n \\log n) )（二分）。 Python 优势：列表操作简洁，调试方便。 背包 DP： 题目：资源分配，如 0-1 背包、完全背包。 解法：定义 ( dp[i][j] ) 为前 ( i ) 项容量 ( j ) 的最优解，转移考虑是否选择当前项。 示例：Luogu P1048（采药，0-1 背包）。 方法： 状态：( dp[i][j] ) 表示前 ( i ) 种草药，容量 ( j ) 的最大价值。 转移：( dp[i][j] = \\max(dp[i-1][j], dp[i-1][j-w[i]] + v[i]) ). 滚动数组：优化到 ( dp[j] )，空间 ( O(W) ). Python 优势：数组操作直观，滚动数组实现简单。 区间 DP： 题目：处理区间合并或分割，如石子合并。 解法：定义 ( dp[l][r] ) 为区间 ( [l, r] ) 的最优解，转移枚举分割点。 示例：Luogu P1880（石子合并）。 方法： 状态：( dp[l][r] ) 表示合并 ( [l, r] ) 石子的最小代价。 转移：( dp[l][r] = \\min(dp[l][k] + dp[k+1][r] + \\text{sum}[l,r]) )，( k \\in [l, r-1] ). 复杂度：( O(n^3) ). Python 优势：二维数组操作简洁，调试区间状态方便。 树形 DP： 题目：树上优化，如最小支配集。 解法：定义 ( dp[u][s] ) 为节点 ( u ) 在状态 ( s ) 下的最优解，递归转移。 示例：Luogu P1352（没有上司的舞会）。 方法： 状态：( dp[u][0/1] ) 表示节点 ( u ) 不选/选的最大快乐值。 转移：( dp[u][0] = \\sum \\max(dp[v][0], dp[v][1]) )，( dp[u][1] = r[u] + \\sum dp[v][0] ). 复杂度：( O(n) ). Python 优势：递归实现直观，邻接表管理树结构。 状态压缩 DP： 题目：小规模集合优化，如 TSP、棋盘覆盖。 解法：用二进制表示状态，转移枚举子集。 示例：POJ 1185（炮兵阵地）。 方法： 状态：( dp[i][s][t] ) 表示第 ( i ) 行，当前状态 ( s )，前一行状态 ( t )。 转移：枚举合法状态，检查兼容性。 复杂度：( O(n \\times 2^m \\times 2^m) )，( m ) 为列数。 Python 优势：位运算简洁，调试状态转换方便。 数位 DP： 题目：数字范围计数，如满足条件的数字个数。 解法：定义 ( dp[pos][state] ) 为前 ( pos ) 位在某状态下的方案数，递归转移。 示例：Luogu P2657（Scenic Number）。 方法： 状态：( dp[pos][prev][lead] ) 表示第 ( pos ) 位，前一位数字，是否前导零。 转移：枚举当前位数字，检查条件。 复杂度：( O(\\log n \\times \\text{状态数}) ). Python 优势：记忆化递归简洁，调试状态直观。 ACM 优化技巧： 快速 I/O：Python 用 sys.stdin.readline 加速输入。 滚动数组：背包、区间 DP 优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态空间。 边界处理：注意空状态、负索引、越界。 调试：打印 DP 表格或递归路径，验证转移。 Python 在 ACM 中的适用性： 优点： 简洁：Python 实现 DP 约 50-100 行，比赛中 10-20 分钟完成。 调试：print DP 表格或状态，验证正确性。 适用：( n \\leq 10^5 )，时间限制 ≥ 1 秒，Python 通常通过。 缺点： 效率：Python 比 C++ 慢 5-10 倍，复杂 DP 可能 TLE。 内存：Python 数组和递归占用较多内存。 严格限制：( n \\geq 10^6 ) 或时间 &lt; 1 秒，可能 TLE。 优化： 用 array 存储 DP 表格，减少内存。 迭代实现，降低递归开销。 预处理输入，减少 I/O 瓶颈。 ACM 题目推荐： Luogu P1020：导弹拦截（LIS）。 Luogu P1048：采药（0-1 背包）。 Luogu P1880：石子合并（区间 DP）。 Luogu P1352：没有上司的舞会（树形 DP）。 POJ 1185：炮兵阵地（状态压缩 DP）。 Luogu P2657：Scenic Number（数位 DP）。 4. Python 实现 以下是几种典型 DP 问题的 Python 实现，包含递推和记忆化递归，带详细注释，适合 ACM 竞赛快速部署。 4.1 0-1 背包（递推） 12345678910111213141516171819202122import sysinput = sys.stdin.readlinedef knapsack(n: int, W: int, w: list, v: list) -&gt; int: &quot;&quot;&quot;0-1 背包：n 物品，容量 W，重量 w[i]，价值 v[i]，求最大价值&quot;&quot;&quot; # dp[j] 表示容量 j 的最大价值 dp = [0] * (W + 1) # 枚举物品 for i in range(n): # 逆序枚举容量（滚动数组） for j in range(W, w[i] - 1, -1): dp[j] = max(dp[j], dp[j - w[i]] + v[i]) return dp[W]# 测试n, W = map(int, input().split())w, v = [], []for _ in range(n): wi, vi = map(int, input().split()) w.append(wi) v.append(vi)print(&quot;0-1 Knapsack:&quot;, knapsack(n, W, w, v)) 4.2 最长公共子序列（记忆化递归） 1234567891011121314151617181920212223import sysinput = sys.stdin.readlinedef lcs(A: str, B: str) -&gt; int: &quot;&quot;&quot;最长公共子序列：字符串 A 和 B 的 LCS 长度&quot;&quot;&quot; m, n = len(A), len(B) memo = &#123;&#125; def dp(i: int, j: int) -&gt; int: if i == 0 or j == 0: return 0 if (i, j) in memo: return memo[(i, j)] if A[i-1] == B[j-1]: memo[(i, j)] = dp(i-1, j-1) + 1 else: memo[(i, j)] = max(dp(i-1, j), dp(i, j-1)) return memo[(i, j)] return dp(m, n)# 测试A = input().strip()B = input().strip()print(&quot;LCS Length:&quot;, lcs(A, B)) 4.3 石子合并（区间 DP，递推） 12345678910111213141516171819202122232425262728import sysinput = sys.stdin.readlinedef stone_merge(n: int, a: list) -&gt; int: &quot;&quot;&quot;石子合并：n 堆石子，合并成一堆的最小代价&quot;&quot;&quot; # 前缀和 s = [0] * (n + 1) for i in range(n): s[i + 1] = s[i] + a[i] # dp[l][r] 表示合并 [l, r] 的最小代价 dp = [[float(&#x27;inf&#x27;)] * n for _ in range(n)] for i in range(n): dp[i][i] = 0 # 单堆无需合并 # 枚举区间长度 for length in range(2, n + 1): # 枚举左端点 for l in range(n - length + 1): r = l + length - 1 # 枚举分割点 for k in range(l, r): dp[l][r] = min(dp[l][r], dp[l][k] + dp[k+1][r] + s[r+1] - s[l]) return dp[0][n-1]# 测试n = int(input())a = list(map(int, input().split()))print(&quot;Stone Merge Cost:&quot;, stone_merge(n, a)) 5. 运行过程 5.1 0-1 背包 输入： 123454 52 31 23 42 2 ( n=4 )，( W=5 )，物品：( (w_1=2, v_1=3) ), ( (w_2=1, v_2=2) ), ( (w_3=3, v_3=4) ), ( (w_4=2, v_4=2) ). 步骤： 初始化：( dp = [0, 0, 0, 0, 0, 0] ). 物品 1 (( w_1=2, v_1=3 ))： ( j=5 \\to 2 ): ( dp[5] = \\max(0, dp[3]+3)=3 ), …, ( dp[2] = 3 ). ( dp = [0, 0, 3, 0, 0, 3] ). 物品 2 (( w_2=1, v_2=2 ))： ( j=5 \\to 1 ): ( dp[5] = \\max(3, dp[4]+2)=3 ), …, ( dp[1] = 2 ). ( dp = [0, 2, 3, 5, 2, 3] ). 物品 3 (( w_3=3, v_3=4 ))： ( j=5 \\to 3 ): ( dp[5] = \\max(3, dp[2]+4)=7 ), …, ( dp[3] = 5 ). ( dp = [0, 2, 3, 5, 6, 7] ). 物品 4 (( w_4=2, v_4=2 ))： ( j=5 \\to 2 ): ( dp[5] = \\max(7, dp[3]+2)=7 ), …, ( dp[2] = 3 ). ( dp = [0, 2, 3, 5, 6, 7] ). 结果：( dp[5] = 7 ). 输出： 10-1 Knapsack: 7 5.2 最长公共子序列 输入： 12ABCDBECAD 字符串 ( A = “ABCD” )，( B = “BECAD” ). 步骤： 记忆化递归： ( dp(4, 5) ): ( A[3]=D ), ( B[4]=D ), 相等，( dp(4, 5) = dp(3, 4) + 1 ). ( dp(3, 4) ): ( A[2]=C ), ( B[3]=A ), 不等，( dp(3, 4) = \\max(dp(2, 4), dp(3, 3)) ). ( dp(2, 4) ): ( A[1]=B ), ( B[3]=A ), 不等，( dp(2, 4) = \\max(dp(1, 4), dp(2, 3)) ). 递归继续，计算所有状态。 最终：( dp(4, 5) = 3 )（LCS 为 “BCD”）。 记忆化表格（部分）：12345 B E C A DA 0 0 0 0 0B 1 1 1 1 1C 1 1 2 2 2D 1 1 2 2 3 输出： 1LCS Length: 3 5.3 石子合并 输入： 1241 3 5 2 ( n=4 )，石子：( a = [1, 3, 5, 2] ). 步骤： 前缀和：( s = [0, 1, 4, 9, 11] ). 初始化：( dp[i][i] = 0 ). 长度 2： ( dp[0][1] = s[2]-s[0] = 4 ). ( dp[1][2] = s[3]-s[1] = 8 ). ( dp[2][3] = s[4]-s[2] = 7 ). 长度 3： ( dp[0][2] = \\min(dp[0][0]+dp[1][2], dp[0][1]+dp[2][2]) + s[3]-s[0] = \\min(0+8, 4+0)+9 = 12 ). ( dp[1][3] = \\min(dp[1][1]+dp[2][3], dp[1][2]+dp[3][3]) + s[4]-s[1] = \\min(0+7, 8+0)+10 = 17 ). 长度 4： ( dp[0][3] = \\min(dp[0][k]+dp[k+1][3]+s[4]-s[0]) = \\min(0+17, 4+7, 12+0)+11 = 18 ). 结果：( dp[0][3] = 18 ). 输出： 1Stone Merge Cost: 18 6. DP 的优缺点 6.1 优点 高效性：将指数复杂度降为多项式（如斐波那契从 ( O(2^n) ) 到 ( O(n) )）。 通用性：适用于优化、计数、概率等多种问题。 ACM 友好：Python 实现简洁，约 50-100 行，比赛中 10-20 分钟完成。 可优化：滚动数组、状态压缩显著降低空间复杂度。 调试方便：DP 表格直观，易于验证。 6.2 缺点 状态设计复杂：需要准确定义状态和转移，初学者易出错。 空间限制：多维 DP 可能占用大量内存。 ACM 限制： 大输入（( n \\geq 10^6 )）或时间 &lt; 1 秒，Python 可能 TLE。 复杂状态压缩或数位 DP 实现难度高。 依赖经验：状态转移方程推导需熟练，比赛中时间紧迫。 6.3 改进方向 滚动数组：优化空间到 ( O(\\min(n, m)) ). 状态压缩：用位运算减少状态数。 迭代实现：将记忆化递归转为递推，降低递归开销。 快速 I/O：优化 Python 输入输出。 Cython/Numba：加速 Python 循环（非比赛场景）。 7. 与其他方法的对比 7.1 与贪心算法 目标： 贪心：局部最优，快速决策。 DP：全局最优，考虑所有可能。 适用性： 贪心：活动选择、Huffman 编码。 DP：0-1 背包、LCS。 ACM 适用性： 贪心：简单问题，Python 实现快。 DP：复杂优化问题，Python 通用。 Python 实现： 贪心：代码短，逻辑简单。 DP：代码稍长，状态设计复杂。 7.2 与分治算法 目标： 分治：分解为独立子问题。 DP：分解为重叠子问题。 适用性： 分治：归并排序、快速排序。 DP：LIS、背包问题。 ACM 适用性： 分治：分治 + 递归，适合无重叠问题。 DP：优化重叠子问题，适合序列、图。 Python 实现： 分治：递归简洁，但可能重复计算。 DP：存储优化，效率更高。 7.3 与数据结构结合 DP + 线段树： 题目：动态区间优化。 解法：DP 定义状态，线段树维护区间最优值。 示例：Codeforces 474E（Pillars，LIS + 线段树）。 DP + 单调队列/栈： 题目：序列优化。 解法：单调队列维护 DP 转移的最优候选。 示例：Luogu P1725（琪露诺，单调队列 DP）。 DP + 树： 题目：树上优化。 解法：树形 DP 递归转移。 示例：Luogu P1352（没有上司的舞会）。 8. 模拟运行过程（补充数位 DP） 8.1 数位 DP 问题：统计区间 ([L, R]) 内，数字各位之和为 ( K ) 的数的个数。 代码： 12345678910111213141516171819202122232425262728293031import sysinput = sys.stdin.readlinedef digit_dp(L: int, R: int, K: int) -&gt; int: &quot;&quot;&quot;数位 DP：统计 [L, R] 内各位和为 K 的数的个数&quot;&quot;&quot; def count(num: str, K: int) -&gt; int: n = len(num) memo = &#123;&#125; def dp(pos: int, sum: int, tight: bool) -&gt; int: if pos == n: return 1 if sum == K else 0 if sum &gt; K: return 0 if (pos, sum, tight) in memo: return memo[(pos, sum, tight)] ans = 0 limit = int(num[pos]) if tight else 9 for d in range(limit + 1): new_tight = tight and d == limit ans += dp(pos + 1, sum + d, new_tight) memo[(pos, sum, tight)] = ans return ans return dp(0, 0, True) return count(str(R), K) - count(str(L-1), K)# 测试L, R, K = map(int, input().split())print(&quot;Digit DP Count:&quot;, digit_dp(L, R, K)) 输入： 11 20 5 区间 ([1, 20])，各位和为 5. 步骤： 计算 ( \\text{count}(20, 5) )： ( dp(0, 0, \\text{True}) ): 枚举第一位 ( d=0 \\to 2 )： ( d=1 ): ( dp(1, 1, \\text{True}) ). ( d=2 ): ( dp(1, 2, \\text{True}) ). ( dp(1, 1, \\text{True}) ): 第二位 ( d=0 \\to 0 )，( dp(2, 1+0, \\text{True}) = 0 )（sum=1 &lt; 5）。 ( dp(1, 2, \\text{True}) ): ( d=0 )，( dp(2, 2+0, \\text{True}) = 0 )（sum=2 &lt; 5）。 结果：0（20 各位和 ≠ 5）。 计算 ( \\text{count}(0, 5) )：类似，0（无数字和 5）。 枚举 ([1, 20])：和为 5 的数为 5, 14。 结果：( 2 ). 输出： 1Digit DP Count: 2 9. 总结 动态规划是解决优化和计数问题的核心方法，通过状态设计和转移高效分解问题： 核心性质：最优子结构、重叠子问题、无后效性。 编程方法：递推（自底向上）、记忆化递归（自顶向下）、空间优化。 ACM 应用：线性 DP、背包、区间 DP、树形 DP、状态压缩、数位 DP。 Python 实现：约 50-100 行，调试方便，适合 ( n \\leq 10^5 )，时间 ≥ 1 秒。 优化：滚动数组、状态压缩、快速 I/O。 通过 Python 代码和样例模拟，展示了 DP 的常见类型和运行过程。在 ACM 竞赛中，DP 是不可或缺的工具，Python 实现适合快速原型和中小规模问题。 学习建议： 手动模拟：用小数据（如 ( n=4 )）画 DP 表格，推导转移。 ACM 练习：尝试 Luogu P1020、P1048、P1880，用 Python 实现 DP。 深入扩展：学习单调队列 DP、斜率优化、凸包优化。 比赛策略： 优先 Python 快速实现，验证正确性。 若 TLE，优化 I/O 或切换 C++. 如果你有其他问题、需要优化 Python 代码、或想探讨 ACM 题目（如复杂 DP 优化、数据结构结合），请随时告诉我！","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"}]}],"categories":[],"tags":[{"name":"service","slug":"service","permalink":"https://borrowyourhuaji.github.io/tags/service/"},{"name":"算法","slug":"算法","permalink":"https://borrowyourhuaji.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"文档、库","slug":"文档、库","permalink":"https://borrowyourhuaji.github.io/tags/%E6%96%87%E6%A1%A3%E3%80%81%E5%BA%93/"}]}